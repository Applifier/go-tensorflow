// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tensorflow_serving/model_server_config.proto

package tensorflow_serving

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// The type of model.
// TODO(b/31336131): DEPRECATED.
type ModelType int32

const (
	ModelType_MODEL_TYPE_UNSPECIFIED ModelType = 0
	ModelType_TENSORFLOW             ModelType = 1
	ModelType_OTHER                  ModelType = 2
)

var ModelType_name = map[int32]string{
	0: "MODEL_TYPE_UNSPECIFIED",
	1: "TENSORFLOW",
	2: "OTHER",
}
var ModelType_value = map[string]int32{
	"MODEL_TYPE_UNSPECIFIED": 0,
	"TENSORFLOW":             1,
	"OTHER":                  2,
}

func (x ModelType) String() string {
	return proto.EnumName(ModelType_name, int32(x))
}
func (ModelType) EnumDescriptor() ([]byte, []int) { return fileDescriptorModelServerConfig, []int{0} }

// Common configuration for loading a model being served.
type ModelConfig struct {
	// Name of the model.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Base path to the model, excluding the version directory.
	// E.g> for a model at /foo/bar/my_model/123, where 123 is the version, the
	// base path is /foo/bar/my_model.
	//
	// (This can be changed once a model is in serving, *if* the underlying data
	// remains the same. Otherwise there are no guarantees about whether the old
	// or new data will be used for model versions currently loaded.)
	BasePath string `protobuf:"bytes,2,opt,name=base_path,json=basePath,proto3" json:"base_path,omitempty"`
	// Type of model.
	// TODO(b/31336131): DEPRECATED. Please use 'model_platform' instead.
	ModelType ModelType `protobuf:"varint,3,opt,name=model_type,json=modelType,proto3,enum=tensorflow.serving.ModelType" json:"model_type,omitempty"`
	// Type of model (e.g. "tensorflow").
	//
	// (This cannot be changed once a model is in serving.)
	ModelPlatform string `protobuf:"bytes,4,opt,name=model_platform,json=modelPlatform,proto3" json:"model_platform,omitempty"`
	// Version policy for the model indicating which version(s) of the model to
	// load and make available for serving simultaneously.
	// The default option is to serve only the latest version of the model.
	//
	// (This can be changed once a model is in serving.)
	ModelVersionPolicy *FileSystemStoragePathSourceConfig_ServableVersionPolicy `protobuf:"bytes,7,opt,name=model_version_policy,json=modelVersionPolicy" json:"model_version_policy,omitempty"`
	// String labels to associate with versions of the model, allowing inference
	// queries to refer to versions by label instead of number. Multiple labels
	// can map to the same version, but not vice-versa.
	//
	// An envisioned use-case for these labels is canarying tentative versions.
	// For example, one can assign labels "stable" and "canary" to two specific
	// versions. Perhaps initially "stable" is assigned to version 0 and "canary"
	// to version 1. Once version 1 passes canary, one can shift the "stable"
	// label to refer to version 1 (at that point both labels map to the same
	// version -- version 1 -- which is fine). Later once version 2 is ready to
	// canary one can move the "canary" label to version 2. And so on.
	VersionLabels map[string]int64 `protobuf:"bytes,8,rep,name=version_labels,json=versionLabels" json:"version_labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// Configures logging requests and responses, to the model.
	//
	// (This can be changed once a model is in serving.)
	LoggingConfig *LoggingConfig `protobuf:"bytes,6,opt,name=logging_config,json=loggingConfig" json:"logging_config,omitempty"`
}

func (m *ModelConfig) Reset()                    { *m = ModelConfig{} }
func (m *ModelConfig) String() string            { return proto.CompactTextString(m) }
func (*ModelConfig) ProtoMessage()               {}
func (*ModelConfig) Descriptor() ([]byte, []int) { return fileDescriptorModelServerConfig, []int{0} }

func (m *ModelConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ModelConfig) GetBasePath() string {
	if m != nil {
		return m.BasePath
	}
	return ""
}

func (m *ModelConfig) GetModelType() ModelType {
	if m != nil {
		return m.ModelType
	}
	return ModelType_MODEL_TYPE_UNSPECIFIED
}

func (m *ModelConfig) GetModelPlatform() string {
	if m != nil {
		return m.ModelPlatform
	}
	return ""
}

func (m *ModelConfig) GetModelVersionPolicy() *FileSystemStoragePathSourceConfig_ServableVersionPolicy {
	if m != nil {
		return m.ModelVersionPolicy
	}
	return nil
}

func (m *ModelConfig) GetVersionLabels() map[string]int64 {
	if m != nil {
		return m.VersionLabels
	}
	return nil
}

func (m *ModelConfig) GetLoggingConfig() *LoggingConfig {
	if m != nil {
		return m.LoggingConfig
	}
	return nil
}

// Static list of models to be loaded for serving.
type ModelConfigList struct {
	Config []*ModelConfig `protobuf:"bytes,1,rep,name=config" json:"config,omitempty"`
}

func (m *ModelConfigList) Reset()                    { *m = ModelConfigList{} }
func (m *ModelConfigList) String() string            { return proto.CompactTextString(m) }
func (*ModelConfigList) ProtoMessage()               {}
func (*ModelConfigList) Descriptor() ([]byte, []int) { return fileDescriptorModelServerConfig, []int{1} }

func (m *ModelConfigList) GetConfig() []*ModelConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

// ModelServer config.
type ModelServerConfig struct {
	// ModelServer takes either a static file-based model config list or an Any
	// proto representing custom model config that is fetched dynamically at
	// runtime (through network RPC, custom service, etc.).
	//
	// Types that are valid to be assigned to Config:
	//	*ModelServerConfig_ModelConfigList
	//	*ModelServerConfig_CustomModelConfig
	Config isModelServerConfig_Config `protobuf_oneof:"config"`
}

func (m *ModelServerConfig) Reset()         { *m = ModelServerConfig{} }
func (m *ModelServerConfig) String() string { return proto.CompactTextString(m) }
func (*ModelServerConfig) ProtoMessage()    {}
func (*ModelServerConfig) Descriptor() ([]byte, []int) {
	return fileDescriptorModelServerConfig, []int{2}
}

type isModelServerConfig_Config interface {
	isModelServerConfig_Config()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ModelServerConfig_ModelConfigList struct {
	ModelConfigList *ModelConfigList `protobuf:"bytes,1,opt,name=model_config_list,json=modelConfigList,oneof"`
}
type ModelServerConfig_CustomModelConfig struct {
	CustomModelConfig *google_protobuf.Any `protobuf:"bytes,2,opt,name=custom_model_config,json=customModelConfig,oneof"`
}

func (*ModelServerConfig_ModelConfigList) isModelServerConfig_Config()   {}
func (*ModelServerConfig_CustomModelConfig) isModelServerConfig_Config() {}

func (m *ModelServerConfig) GetConfig() isModelServerConfig_Config {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *ModelServerConfig) GetModelConfigList() *ModelConfigList {
	if x, ok := m.GetConfig().(*ModelServerConfig_ModelConfigList); ok {
		return x.ModelConfigList
	}
	return nil
}

func (m *ModelServerConfig) GetCustomModelConfig() *google_protobuf.Any {
	if x, ok := m.GetConfig().(*ModelServerConfig_CustomModelConfig); ok {
		return x.CustomModelConfig
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ModelServerConfig) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ModelServerConfig_OneofMarshaler, _ModelServerConfig_OneofUnmarshaler, _ModelServerConfig_OneofSizer, []interface{}{
		(*ModelServerConfig_ModelConfigList)(nil),
		(*ModelServerConfig_CustomModelConfig)(nil),
	}
}

func _ModelServerConfig_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ModelServerConfig)
	// config
	switch x := m.Config.(type) {
	case *ModelServerConfig_ModelConfigList:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ModelConfigList); err != nil {
			return err
		}
	case *ModelServerConfig_CustomModelConfig:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CustomModelConfig); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ModelServerConfig.Config has unexpected type %T", x)
	}
	return nil
}

func _ModelServerConfig_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ModelServerConfig)
	switch tag {
	case 1: // config.model_config_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ModelConfigList)
		err := b.DecodeMessage(msg)
		m.Config = &ModelServerConfig_ModelConfigList{msg}
		return true, err
	case 2: // config.custom_model_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf.Any)
		err := b.DecodeMessage(msg)
		m.Config = &ModelServerConfig_CustomModelConfig{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ModelServerConfig_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ModelServerConfig)
	// config
	switch x := m.Config.(type) {
	case *ModelServerConfig_ModelConfigList:
		s := proto.Size(x.ModelConfigList)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ModelServerConfig_CustomModelConfig:
		s := proto.Size(x.CustomModelConfig)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*ModelConfig)(nil), "tensorflow.serving.ModelConfig")
	proto.RegisterType((*ModelConfigList)(nil), "tensorflow.serving.ModelConfigList")
	proto.RegisterType((*ModelServerConfig)(nil), "tensorflow.serving.ModelServerConfig")
	proto.RegisterEnum("tensorflow.serving.ModelType", ModelType_name, ModelType_value)
}
func (m *ModelConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModelServerConfig(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.BasePath) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModelServerConfig(dAtA, i, uint64(len(m.BasePath)))
		i += copy(dAtA[i:], m.BasePath)
	}
	if m.ModelType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintModelServerConfig(dAtA, i, uint64(m.ModelType))
	}
	if len(m.ModelPlatform) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintModelServerConfig(dAtA, i, uint64(len(m.ModelPlatform)))
		i += copy(dAtA[i:], m.ModelPlatform)
	}
	if m.LoggingConfig != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintModelServerConfig(dAtA, i, uint64(m.LoggingConfig.Size()))
		n1, err := m.LoggingConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.ModelVersionPolicy != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintModelServerConfig(dAtA, i, uint64(m.ModelVersionPolicy.Size()))
		n2, err := m.ModelVersionPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.VersionLabels) > 0 {
		for k, _ := range m.VersionLabels {
			dAtA[i] = 0x42
			i++
			v := m.VersionLabels[k]
			mapSize := 1 + len(k) + sovModelServerConfig(uint64(len(k))) + 1 + sovModelServerConfig(uint64(v))
			i = encodeVarintModelServerConfig(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintModelServerConfig(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintModelServerConfig(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *ModelConfigList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelConfigList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Config) > 0 {
		for _, msg := range m.Config {
			dAtA[i] = 0xa
			i++
			i = encodeVarintModelServerConfig(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ModelServerConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelServerConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Config != nil {
		nn3, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn3
	}
	return i, nil
}

func (m *ModelServerConfig_ModelConfigList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ModelConfigList != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModelServerConfig(dAtA, i, uint64(m.ModelConfigList.Size()))
		n4, err := m.ModelConfigList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *ModelServerConfig_CustomModelConfig) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CustomModelConfig != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModelServerConfig(dAtA, i, uint64(m.CustomModelConfig.Size()))
		n5, err := m.CustomModelConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func encodeVarintModelServerConfig(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ModelConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModelServerConfig(uint64(l))
	}
	l = len(m.BasePath)
	if l > 0 {
		n += 1 + l + sovModelServerConfig(uint64(l))
	}
	if m.ModelType != 0 {
		n += 1 + sovModelServerConfig(uint64(m.ModelType))
	}
	l = len(m.ModelPlatform)
	if l > 0 {
		n += 1 + l + sovModelServerConfig(uint64(l))
	}
	if m.LoggingConfig != nil {
		l = m.LoggingConfig.Size()
		n += 1 + l + sovModelServerConfig(uint64(l))
	}
	if m.ModelVersionPolicy != nil {
		l = m.ModelVersionPolicy.Size()
		n += 1 + l + sovModelServerConfig(uint64(l))
	}
	if len(m.VersionLabels) > 0 {
		for k, v := range m.VersionLabels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovModelServerConfig(uint64(len(k))) + 1 + sovModelServerConfig(uint64(v))
			n += mapEntrySize + 1 + sovModelServerConfig(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ModelConfigList) Size() (n int) {
	var l int
	_ = l
	if len(m.Config) > 0 {
		for _, e := range m.Config {
			l = e.Size()
			n += 1 + l + sovModelServerConfig(uint64(l))
		}
	}
	return n
}

func (m *ModelServerConfig) Size() (n int) {
	var l int
	_ = l
	if m.Config != nil {
		n += m.Config.Size()
	}
	return n
}

func (m *ModelServerConfig_ModelConfigList) Size() (n int) {
	var l int
	_ = l
	if m.ModelConfigList != nil {
		l = m.ModelConfigList.Size()
		n += 1 + l + sovModelServerConfig(uint64(l))
	}
	return n
}
func (m *ModelServerConfig_CustomModelConfig) Size() (n int) {
	var l int
	_ = l
	if m.CustomModelConfig != nil {
		l = m.CustomModelConfig.Size()
		n += 1 + l + sovModelServerConfig(uint64(l))
	}
	return n
}

func sovModelServerConfig(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozModelServerConfig(x uint64) (n int) {
	return sovModelServerConfig(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ModelConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelServerConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelServerConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelServerConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelType", wireType)
			}
			m.ModelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelServerConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModelType |= (ModelType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelPlatform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelServerConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelPlatform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoggingConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelServerConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LoggingConfig == nil {
				m.LoggingConfig = &LoggingConfig{}
			}
			if err := m.LoggingConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelVersionPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelServerConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModelVersionPolicy == nil {
				m.ModelVersionPolicy = &FileSystemStoragePathSourceConfig_ServableVersionPolicy{}
			}
			if err := m.ModelVersionPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelServerConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VersionLabels == nil {
				m.VersionLabels = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModelServerConfig
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModelServerConfig
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthModelServerConfig
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModelServerConfig
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipModelServerConfig(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthModelServerConfig
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.VersionLabels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelServerConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelConfigList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelServerConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelConfigList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelConfigList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelServerConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = append(m.Config, &ModelConfig{})
			if err := m.Config[len(m.Config)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelServerConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelServerConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelServerConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelServerConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelServerConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelConfigList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelServerConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ModelConfigList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Config = &ModelServerConfig_ModelConfigList{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomModelConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelServerConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &google_protobuf.Any{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Config = &ModelServerConfig_CustomModelConfig{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelServerConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipModelServerConfig(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowModelServerConfig
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModelServerConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModelServerConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthModelServerConfig
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowModelServerConfig
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipModelServerConfig(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthModelServerConfig = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowModelServerConfig   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("tensorflow_serving/model_server_config.proto", fileDescriptorModelServerConfig)
}

var fileDescriptorModelServerConfig = []byte{
	// 594 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x53, 0xdd, 0x8e, 0xd2, 0x40,
	0x14, 0x66, 0xf8, 0x13, 0x86, 0xc0, 0xc2, 0x2c, 0x31, 0x15, 0x23, 0x22, 0xc6, 0x48, 0x8c, 0x29,
	0x49, 0xbd, 0x70, 0xe3, 0xd5, 0xca, 0x6e, 0x09, 0xbb, 0xb2, 0x80, 0x2d, 0x6a, 0xf6, 0xaa, 0x29,
	0x38, 0x74, 0x1b, 0xa7, 0x9d, 0xa6, 0x33, 0x60, 0x7a, 0xe1, 0x3b, 0x98, 0xf8, 0x32, 0x3e, 0x82,
	0x97, 0x3e, 0x82, 0xc1, 0x97, 0xf0, 0xd2, 0x74, 0xa6, 0x28, 0xb8, 0x98, 0xbd, 0xeb, 0x39, 0x7c,
	0xe7, 0xfb, 0x39, 0x87, 0x81, 0x4f, 0x39, 0xf6, 0x19, 0x0d, 0x17, 0x84, 0x7e, 0xb4, 0x18, 0x0e,
	0x57, 0xae, 0xef, 0x74, 0x3d, 0xfa, 0x1e, 0x13, 0x51, 0xe1, 0xd0, 0x9a, 0x53, 0x7f, 0xe1, 0x3a,
	0x6a, 0x10, 0x52, 0x4e, 0x11, 0xfa, 0x8b, 0x56, 0x13, 0x74, 0xe3, 0x8e, 0x43, 0xa9, 0x43, 0x70,
	0x57, 0x20, 0x66, 0xcb, 0x45, 0xd7, 0xf6, 0x23, 0x09, 0x6f, 0x3c, 0xde, 0x43, 0x4e, 0xa8, 0xe3,
	0xb8, 0xbe, 0xb3, 0xc3, 0xdb, 0x38, 0xda, 0x03, 0x5c, 0xb8, 0x04, 0x5b, 0x2c, 0x62, 0x1c, 0x7b,
	0x16, 0xe3, 0x34, 0xb4, 0x1d, 0x6c, 0x05, 0x36, 0xbf, 0xb2, 0x18, 0x5d, 0x86, 0x73, 0x2c, 0x27,
	0xdb, 0x5f, 0xb2, 0xb0, 0x74, 0x11, 0xfb, 0x3d, 0x11, 0x7c, 0x08, 0xc1, 0xac, 0x6f, 0x7b, 0x58,
	0x01, 0x2d, 0xd0, 0x29, 0x1a, 0xe2, 0x1b, 0xdd, 0x85, 0xc5, 0x99, 0xcd, 0xe4, 0xb4, 0x92, 0x16,
	0x3f, 0x14, 0xe2, 0xc6, 0xc4, 0xe6, 0x57, 0xe8, 0x18, 0x42, 0x99, 0x97, 0x47, 0x01, 0x56, 0x32,
	0x2d, 0xd0, 0xa9, 0x68, 0xf7, 0xd4, 0xeb, 0x39, 0x55, 0xa1, 0x32, 0x8d, 0x02, 0xdc, 0x4b, 0x2b,
	0xc0, 0x28, 0x7a, 0x9b, 0x12, 0x3d, 0x82, 0x15, 0xc9, 0x10, 0x10, 0x9b, 0x2f, 0x68, 0xe8, 0x29,
	0x59, 0xa1, 0x51, 0x16, 0xdd, 0x49, 0xd2, 0x44, 0x03, 0x58, 0xd9, 0xcd, 0xae, 0xe4, 0x5b, 0xa0,
	0x53, 0xd2, 0x1e, 0xec, 0x13, 0x1b, 0x4a, 0xa4, 0x0c, 0x65, 0x94, 0xc9, 0x76, 0x89, 0x3e, 0xc1,
	0xba, 0x14, 0x5c, 0xe1, 0x90, 0xb9, 0xd4, 0xb7, 0x02, 0x4a, 0xdc, 0x79, 0xa4, 0xdc, 0x12, 0x7c,
	0xaf, 0xf6, 0xf1, 0xf5, 0x5d, 0x82, 0x4d, 0xb1, 0x4b, 0x53, 0xae, 0x32, 0xce, 0x6e, 0x8a, 0x45,
	0x4a, 0x52, 0xd5, 0xc4, 0xe1, 0xca, 0x9e, 0x11, 0xfc, 0x56, 0x72, 0x4e, 0x04, 0xa5, 0x81, 0x84,
	0xd0, 0x4e, 0x0f, 0x5d, 0xc2, 0xca, 0x46, 0x98, 0xd8, 0x33, 0x4c, 0x98, 0x52, 0x68, 0x65, 0x3a,
	0x25, 0x4d, 0xfb, 0xef, 0xd6, 0x12, 0x89, 0x84, 0x66, 0x28, 0x86, 0x74, 0x9f, 0x87, 0x91, 0x51,
	0x5e, 0x6d, 0xf7, 0x1a, 0xc7, 0x10, 0x5d, 0x07, 0xa1, 0x2a, 0xcc, 0x7c, 0xc0, 0x51, 0x72, 0xd2,
	0xf8, 0x13, 0xd5, 0x61, 0x6e, 0x65, 0x93, 0x25, 0x16, 0xd7, 0xcc, 0x18, 0xb2, 0x78, 0x91, 0x3e,
	0x02, 0xe7, 0xd9, 0x42, 0xae, 0x9a, 0x6f, 0x9f, 0xc3, 0x83, 0x2d, 0xe1, 0xa1, 0xcb, 0x38, 0x7a,
	0x0e, 0xf3, 0xc9, 0xda, 0x81, 0x70, 0x7b, 0xff, 0x06, 0xb7, 0x46, 0x02, 0x6f, 0x7f, 0x05, 0xb0,
	0x26, 0xfa, 0xa6, 0x78, 0x10, 0xc9, 0x0d, 0x5e, 0xc3, 0x9a, 0xbc, 0x81, 0x44, 0x59, 0xc4, 0x65,
	0x5c, 0x38, 0x2c, 0x69, 0x0f, 0x6f, 0x60, 0x8e, 0xed, 0x0c, 0x52, 0xc6, 0x81, 0xf7, 0x8f, 0xc3,
	0x3e, 0x3c, 0x9c, 0x2f, 0x19, 0xa7, 0x9e, 0xb5, 0xcd, 0x2c, 0x22, 0x96, 0xb4, 0xba, 0x2a, 0x9f,
	0x99, 0xba, 0x79, 0x66, 0xea, 0x4b, 0x3f, 0x1a, 0xa4, 0x8c, 0x9a, 0x1c, 0xd9, 0xa2, 0xef, 0x15,
	0x36, 0x49, 0x9f, 0x8c, 0x60, 0xf1, 0xcf, 0xbf, 0x16, 0x35, 0xe1, 0xed, 0x8b, 0xf1, 0xa9, 0x3e,
	0xb4, 0xa6, 0x97, 0x13, 0xdd, 0x7a, 0x33, 0x32, 0x27, 0xfa, 0xc9, 0x59, 0xff, 0x4c, 0x3f, 0xad,
	0xa6, 0x1a, 0xe9, 0x02, 0x40, 0x08, 0xc2, 0xa9, 0x3e, 0x32, 0xc7, 0x46, 0x7f, 0x38, 0x7e, 0x57,
	0x05, 0xa2, 0x57, 0x86, 0xb9, 0xf1, 0x74, 0xa0, 0x1b, 0xd5, 0x74, 0x5c, 0xf6, 0x0e, 0xbf, 0xad,
	0x9b, 0xe0, 0xfb, 0xba, 0x09, 0x7e, 0xac, 0x9b, 0xe0, 0xf3, 0xcf, 0x66, 0xea, 0x17, 0x00, 0xb3,
	0xbc, 0x70, 0xf4, 0xec, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0xa5, 0x4d, 0x49, 0xc9, 0x4a, 0x04,
	0x00, 0x00,
}
