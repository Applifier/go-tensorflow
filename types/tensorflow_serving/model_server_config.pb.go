// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tensorflow_serving/model_server_config.proto

package tensorflow_serving

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// The type of model.
// TODO(b/31336131): DEPRECATED.
type ModelType int32

const (
	ModelType_MODEL_TYPE_UNSPECIFIED ModelType = 0 // Deprecated: Do not use.
	ModelType_TENSORFLOW             ModelType = 1 // Deprecated: Do not use.
	ModelType_OTHER                  ModelType = 2 // Deprecated: Do not use.
)

var ModelType_name = map[int32]string{
	0: "MODEL_TYPE_UNSPECIFIED",
	1: "TENSORFLOW",
	2: "OTHER",
}

var ModelType_value = map[string]int32{
	"MODEL_TYPE_UNSPECIFIED": 0,
	"TENSORFLOW":             1,
	"OTHER":                  2,
}

func (x ModelType) String() string {
	return proto.EnumName(ModelType_name, int32(x))
}

func (ModelType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8317b20b2b826bad, []int{0}
}

// Common configuration for loading a model being served.
type ModelConfig struct {
	// Name of the model.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Base path to the model, excluding the version directory.
	// E.g> for a model at /foo/bar/my_model/123, where 123 is the version, the
	// base path is /foo/bar/my_model.
	//
	// (This can be changed once a model is in serving, *if* the underlying data
	// remains the same. Otherwise there are no guarantees about whether the old
	// or new data will be used for model versions currently loaded.)
	BasePath string `protobuf:"bytes,2,opt,name=base_path,json=basePath,proto3" json:"base_path,omitempty"`
	// Type of model.
	// TODO(b/31336131): DEPRECATED. Please use 'model_platform' instead.
	ModelType ModelType `protobuf:"varint,3,opt,name=model_type,json=modelType,proto3,enum=tensorflow.serving.ModelType" json:"model_type,omitempty"` // Deprecated: Do not use.
	// Type of model (e.g. "tensorflow").
	//
	// (This cannot be changed once a model is in serving.)
	ModelPlatform string `protobuf:"bytes,4,opt,name=model_platform,json=modelPlatform,proto3" json:"model_platform,omitempty"`
	// Version policy for the model indicating which version(s) of the model to
	// load and make available for serving simultaneously.
	// The default option is to serve only the latest version of the model.
	//
	// (This can be changed once a model is in serving.)
	ModelVersionPolicy *FileSystemStoragePathSourceConfig_ServableVersionPolicy `protobuf:"bytes,7,opt,name=model_version_policy,json=modelVersionPolicy,proto3" json:"model_version_policy,omitempty"`
	// String labels to associate with versions of the model, allowing inference
	// queries to refer to versions by label instead of number. Multiple labels
	// can map to the same version, but not vice-versa.
	//
	// An envisioned use-case for these labels is canarying tentative versions.
	// For example, one can assign labels "stable" and "canary" to two specific
	// versions. Perhaps initially "stable" is assigned to version 0 and "canary"
	// to version 1. Once version 1 passes canary, one can shift the "stable"
	// label to refer to version 1 (at that point both labels map to the same
	// version -- version 1 -- which is fine). Later once version 2 is ready to
	// canary one can move the "canary" label to version 2. And so on.
	VersionLabels map[string]int64 `protobuf:"bytes,8,rep,name=version_labels,json=versionLabels,proto3" json:"version_labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// Configures logging requests and responses, to the model.
	//
	// (This can be changed once a model is in serving.)
	LoggingConfig *LoggingConfig `protobuf:"bytes,6,opt,name=logging_config,json=loggingConfig,proto3" json:"logging_config,omitempty"`
}

func (m *ModelConfig) Reset()         { *m = ModelConfig{} }
func (m *ModelConfig) String() string { return proto.CompactTextString(m) }
func (*ModelConfig) ProtoMessage()    {}
func (*ModelConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_8317b20b2b826bad, []int{0}
}
func (m *ModelConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelConfig.Merge(m, src)
}
func (m *ModelConfig) XXX_Size() int {
	return m.Size()
}
func (m *ModelConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ModelConfig proto.InternalMessageInfo

func (m *ModelConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ModelConfig) GetBasePath() string {
	if m != nil {
		return m.BasePath
	}
	return ""
}

// Deprecated: Do not use.
func (m *ModelConfig) GetModelType() ModelType {
	if m != nil {
		return m.ModelType
	}
	return ModelType_MODEL_TYPE_UNSPECIFIED
}

func (m *ModelConfig) GetModelPlatform() string {
	if m != nil {
		return m.ModelPlatform
	}
	return ""
}

func (m *ModelConfig) GetModelVersionPolicy() *FileSystemStoragePathSourceConfig_ServableVersionPolicy {
	if m != nil {
		return m.ModelVersionPolicy
	}
	return nil
}

func (m *ModelConfig) GetVersionLabels() map[string]int64 {
	if m != nil {
		return m.VersionLabels
	}
	return nil
}

func (m *ModelConfig) GetLoggingConfig() *LoggingConfig {
	if m != nil {
		return m.LoggingConfig
	}
	return nil
}

// Static list of models to be loaded for serving.
type ModelConfigList struct {
	Config []*ModelConfig `protobuf:"bytes,1,rep,name=config,proto3" json:"config,omitempty"`
}

func (m *ModelConfigList) Reset()         { *m = ModelConfigList{} }
func (m *ModelConfigList) String() string { return proto.CompactTextString(m) }
func (*ModelConfigList) ProtoMessage()    {}
func (*ModelConfigList) Descriptor() ([]byte, []int) {
	return fileDescriptor_8317b20b2b826bad, []int{1}
}
func (m *ModelConfigList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelConfigList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelConfigList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelConfigList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelConfigList.Merge(m, src)
}
func (m *ModelConfigList) XXX_Size() int {
	return m.Size()
}
func (m *ModelConfigList) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelConfigList.DiscardUnknown(m)
}

var xxx_messageInfo_ModelConfigList proto.InternalMessageInfo

func (m *ModelConfigList) GetConfig() []*ModelConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

// ModelServer config.
type ModelServerConfig struct {
	// ModelServer takes either a static file-based model config list or an Any
	// proto representing custom model config that is fetched dynamically at
	// runtime (through network RPC, custom service, etc.).
	//
	// Types that are valid to be assigned to Config:
	//	*ModelServerConfig_ModelConfigList
	//	*ModelServerConfig_CustomModelConfig
	Config isModelServerConfig_Config `protobuf_oneof:"config"`
}

func (m *ModelServerConfig) Reset()         { *m = ModelServerConfig{} }
func (m *ModelServerConfig) String() string { return proto.CompactTextString(m) }
func (*ModelServerConfig) ProtoMessage()    {}
func (*ModelServerConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_8317b20b2b826bad, []int{2}
}
func (m *ModelServerConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelServerConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelServerConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelServerConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelServerConfig.Merge(m, src)
}
func (m *ModelServerConfig) XXX_Size() int {
	return m.Size()
}
func (m *ModelServerConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelServerConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ModelServerConfig proto.InternalMessageInfo

type isModelServerConfig_Config interface {
	isModelServerConfig_Config()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ModelServerConfig_ModelConfigList struct {
	ModelConfigList *ModelConfigList `protobuf:"bytes,1,opt,name=model_config_list,json=modelConfigList,proto3,oneof" json:"model_config_list,omitempty"`
}
type ModelServerConfig_CustomModelConfig struct {
	CustomModelConfig *types.Any `protobuf:"bytes,2,opt,name=custom_model_config,json=customModelConfig,proto3,oneof" json:"custom_model_config,omitempty"`
}

func (*ModelServerConfig_ModelConfigList) isModelServerConfig_Config()   {}
func (*ModelServerConfig_CustomModelConfig) isModelServerConfig_Config() {}

func (m *ModelServerConfig) GetConfig() isModelServerConfig_Config {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *ModelServerConfig) GetModelConfigList() *ModelConfigList {
	if x, ok := m.GetConfig().(*ModelServerConfig_ModelConfigList); ok {
		return x.ModelConfigList
	}
	return nil
}

func (m *ModelServerConfig) GetCustomModelConfig() *types.Any {
	if x, ok := m.GetConfig().(*ModelServerConfig_CustomModelConfig); ok {
		return x.CustomModelConfig
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ModelServerConfig) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ModelServerConfig_ModelConfigList)(nil),
		(*ModelServerConfig_CustomModelConfig)(nil),
	}
}

func init() {
	proto.RegisterEnum("tensorflow.serving.ModelType", ModelType_name, ModelType_value)
	proto.RegisterType((*ModelConfig)(nil), "tensorflow.serving.ModelConfig")
	proto.RegisterMapType((map[string]int64)(nil), "tensorflow.serving.ModelConfig.VersionLabelsEntry")
	proto.RegisterType((*ModelConfigList)(nil), "tensorflow.serving.ModelConfigList")
	proto.RegisterType((*ModelServerConfig)(nil), "tensorflow.serving.ModelServerConfig")
}

func init() {
	proto.RegisterFile("tensorflow_serving/model_server_config.proto", fileDescriptor_8317b20b2b826bad)
}

var fileDescriptor_8317b20b2b826bad = []byte{
	// 610 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x53, 0xcb, 0x6e, 0xd3, 0x4c,
	0x18, 0xcd, 0x24, 0x69, 0xfe, 0xe4, 0x8b, 0x92, 0xa6, 0xf3, 0x57, 0xc8, 0xa4, 0xc2, 0x84, 0x22,
	0x44, 0x84, 0x90, 0x2b, 0x85, 0x05, 0x15, 0xab, 0xd2, 0xd6, 0x51, 0x5a, 0xd2, 0x26, 0xd8, 0x01,
	0xd4, 0x95, 0xe5, 0x84, 0x89, 0x6b, 0x31, 0xf6, 0x58, 0x9e, 0x49, 0x90, 0x17, 0xbc, 0x03, 0x5b,
	0xde, 0x84, 0x47, 0x60, 0xd9, 0x25, 0x4b, 0xd4, 0xbe, 0x04, 0x4b, 0xe4, 0x19, 0x07, 0x52, 0x1a,
	0xd4, 0x9d, 0xbf, 0xe3, 0x33, 0xe7, 0x32, 0x17, 0x78, 0x2a, 0x48, 0xc8, 0x59, 0x3c, 0xa5, 0xec,
	0xa3, 0xc3, 0x49, 0x3c, 0xf7, 0x43, 0x6f, 0x27, 0x60, 0xef, 0x09, 0x95, 0x13, 0x89, 0x9d, 0x09,
	0x0b, 0xa7, 0xbe, 0x67, 0x44, 0x31, 0x13, 0x0c, 0xe3, 0x3f, 0x6c, 0x23, 0x63, 0x37, 0xef, 0x7a,
	0x8c, 0x79, 0x94, 0xec, 0x48, 0xc6, 0x78, 0x36, 0xdd, 0x71, 0xc3, 0x44, 0xd1, 0x9b, 0xbb, 0x2b,
	0xc4, 0xa7, 0x3e, 0x25, 0x0e, 0x4f, 0xb8, 0x20, 0x81, 0xc3, 0x05, 0x8b, 0x5d, 0x8f, 0x38, 0x91,
	0x2b, 0xce, 0x1d, 0xce, 0x66, 0xf1, 0x84, 0x64, 0x2b, 0x1f, 0xaf, 0x58, 0x49, 0x99, 0xe7, 0xf9,
	0xa1, 0x77, 0x2d, 0xd1, 0xf6, 0x97, 0x22, 0x54, 0x4f, 0xd2, 0xbc, 0x07, 0x12, 0xc5, 0x18, 0x8a,
	0xa1, 0x1b, 0x10, 0x0d, 0xb5, 0x50, 0xbb, 0x62, 0xc9, 0x6f, 0xbc, 0x05, 0x95, 0xb1, 0xcb, 0x95,
	0x8d, 0x96, 0x97, 0x3f, 0xca, 0x29, 0x30, 0x74, 0xc5, 0x39, 0xde, 0x03, 0x50, 0x7d, 0x45, 0x12,
	0x11, 0xad, 0xd0, 0x42, 0xed, 0x7a, 0xe7, 0x9e, 0x71, 0xb3, 0xa7, 0x21, 0x5d, 0x46, 0x49, 0x44,
	0xf6, 0xf3, 0x1a, 0xb2, 0x2a, 0xc1, 0x62, 0xc4, 0x8f, 0xa0, 0xae, 0x14, 0x22, 0xea, 0x8a, 0x29,
	0x8b, 0x03, 0xad, 0x28, 0x3d, 0x6a, 0x12, 0x1d, 0x66, 0x20, 0xfe, 0x04, 0x9b, 0x8a, 0x36, 0x27,
	0x31, 0xf7, 0x59, 0xe8, 0x44, 0x8c, 0xfa, 0x93, 0x44, 0xfb, 0xaf, 0x85, 0xda, 0xd5, 0xce, 0xab,
	0x55, 0x96, 0x5d, 0x9f, 0x12, 0x5b, 0x6e, 0x95, 0xad, 0x76, 0x2a, 0x4d, 0x6c, 0xcb, 0x7d, 0x52,
	0x75, 0x0d, 0x9b, 0xc4, 0x73, 0x77, 0x4c, 0xc9, 0x5b, 0xa5, 0x39, 0x94, 0x92, 0x16, 0x96, 0x46,
	0xd7, 0x30, 0x7c, 0x06, 0xf5, 0x85, 0x31, 0x75, 0xc7, 0x84, 0x72, 0xad, 0xdc, 0x2a, 0xb4, 0xab,
	0x9d, 0xce, 0x3f, 0xbb, 0x66, 0x16, 0x99, 0x4c, 0x5f, 0x2e, 0x32, 0x43, 0x11, 0x27, 0x56, 0x6d,
	0xbe, 0x8c, 0xe1, 0x1e, 0xd4, 0xaf, 0x9f, 0x8d, 0x56, 0x92, 0x9d, 0x1e, 0xac, 0x92, 0xee, 0x2b,
	0xa6, 0x12, 0xb7, 0x6a, 0x74, 0x79, 0x6c, 0xee, 0x01, 0xbe, 0x69, 0x87, 0x1b, 0x50, 0xf8, 0x40,
	0x92, 0xec, 0x48, 0xd3, 0x4f, 0xbc, 0x09, 0x6b, 0x73, 0x97, 0xce, 0x88, 0x3c, 0xcd, 0x82, 0xa5,
	0x86, 0x17, 0xf9, 0x5d, 0x74, 0x5c, 0x2c, 0xaf, 0x35, 0x4a, 0xc7, 0xc5, 0x72, 0xa5, 0x01, 0xdb,
	0xc7, 0xb0, 0xbe, 0x54, 0xa4, 0xef, 0x73, 0x81, 0x9f, 0x43, 0x29, 0x8b, 0x88, 0x64, 0xfb, 0xfb,
	0xb7, 0xb4, 0xb7, 0x32, 0xfa, 0xf6, 0x57, 0x04, 0x1b, 0x12, 0xb7, 0xe5, 0xb3, 0xc8, 0x6e, 0xdb,
	0x6b, 0xd8, 0x50, 0x67, 0xaa, 0x58, 0x0e, 0xf5, 0xb9, 0x90, 0x39, 0xab, 0x9d, 0x87, 0xb7, 0x28,
	0xa7, 0x71, 0x7a, 0x39, 0x6b, 0x3d, 0xf8, 0x2b, 0x61, 0x17, 0xfe, 0x9f, 0xcc, 0xb8, 0x60, 0x81,
	0xb3, 0xac, 0x2c, 0x8b, 0x56, 0x3b, 0x9b, 0x86, 0x7a, 0x6c, 0xc6, 0xe2, 0xb1, 0x19, 0x2f, 0xc3,
	0xa4, 0x97, 0xb3, 0x36, 0xd4, 0x92, 0x25, 0xf9, 0xfd, 0xf2, 0xa2, 0xe9, 0x93, 0x53, 0xa8, 0xfc,
	0xbe, 0xbb, 0x58, 0x87, 0x3b, 0x27, 0x83, 0x43, 0xb3, 0xef, 0x8c, 0xce, 0x86, 0xa6, 0xf3, 0xe6,
	0xd4, 0x1e, 0x9a, 0x07, 0x47, 0xdd, 0x23, 0xf3, 0xb0, 0x91, 0x6b, 0xe6, 0xcb, 0x08, 0x63, 0x80,
	0x91, 0x79, 0x6a, 0x0f, 0xac, 0x6e, 0x7f, 0xf0, 0xae, 0x81, 0x24, 0x56, 0x83, 0xb5, 0xc1, 0xa8,
	0x67, 0x5a, 0x8d, 0x7c, 0x3a, 0xee, 0x6f, 0x7d, 0xbb, 0xd4, 0xd1, 0xc5, 0xa5, 0x8e, 0x7e, 0x5c,
	0xea, 0xe8, 0xf3, 0x95, 0x9e, 0xbb, 0xb8, 0xd2, 0x73, 0xdf, 0xaf, 0xf4, 0xdc, 0x4f, 0x84, 0xc6,
	0x25, 0x99, 0xec, 0xd9, 0xaf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x1e, 0x07, 0x9f, 0xb4, 0x58, 0x04,
	0x00, 0x00,
}

func (m *ModelConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VersionLabels) > 0 {
		for k := range m.VersionLabels {
			v := m.VersionLabels[k]
			baseI := i
			i = encodeVarintModelServerConfig(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintModelServerConfig(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintModelServerConfig(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.ModelVersionPolicy != nil {
		{
			size, err := m.ModelVersionPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelServerConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.LoggingConfig != nil {
		{
			size, err := m.LoggingConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelServerConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.ModelPlatform) > 0 {
		i -= len(m.ModelPlatform)
		copy(dAtA[i:], m.ModelPlatform)
		i = encodeVarintModelServerConfig(dAtA, i, uint64(len(m.ModelPlatform)))
		i--
		dAtA[i] = 0x22
	}
	if m.ModelType != 0 {
		i = encodeVarintModelServerConfig(dAtA, i, uint64(m.ModelType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.BasePath) > 0 {
		i -= len(m.BasePath)
		copy(dAtA[i:], m.BasePath)
		i = encodeVarintModelServerConfig(dAtA, i, uint64(len(m.BasePath)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModelServerConfig(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelConfigList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelConfigList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelConfigList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Config) > 0 {
		for iNdEx := len(m.Config) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Config[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModelServerConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ModelServerConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelServerConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelServerConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Config != nil {
		{
			size := m.Config.Size()
			i -= size
			if _, err := m.Config.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ModelServerConfig_ModelConfigList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelServerConfig_ModelConfigList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ModelConfigList != nil {
		{
			size, err := m.ModelConfigList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelServerConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ModelServerConfig_CustomModelConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelServerConfig_CustomModelConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CustomModelConfig != nil {
		{
			size, err := m.CustomModelConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelServerConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func encodeVarintModelServerConfig(dAtA []byte, offset int, v uint64) int {
	offset -= sovModelServerConfig(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ModelConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModelServerConfig(uint64(l))
	}
	l = len(m.BasePath)
	if l > 0 {
		n += 1 + l + sovModelServerConfig(uint64(l))
	}
	if m.ModelType != 0 {
		n += 1 + sovModelServerConfig(uint64(m.ModelType))
	}
	l = len(m.ModelPlatform)
	if l > 0 {
		n += 1 + l + sovModelServerConfig(uint64(l))
	}
	if m.LoggingConfig != nil {
		l = m.LoggingConfig.Size()
		n += 1 + l + sovModelServerConfig(uint64(l))
	}
	if m.ModelVersionPolicy != nil {
		l = m.ModelVersionPolicy.Size()
		n += 1 + l + sovModelServerConfig(uint64(l))
	}
	if len(m.VersionLabels) > 0 {
		for k, v := range m.VersionLabels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovModelServerConfig(uint64(len(k))) + 1 + sovModelServerConfig(uint64(v))
			n += mapEntrySize + 1 + sovModelServerConfig(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ModelConfigList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Config) > 0 {
		for _, e := range m.Config {
			l = e.Size()
			n += 1 + l + sovModelServerConfig(uint64(l))
		}
	}
	return n
}

func (m *ModelServerConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Config != nil {
		n += m.Config.Size()
	}
	return n
}

func (m *ModelServerConfig_ModelConfigList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ModelConfigList != nil {
		l = m.ModelConfigList.Size()
		n += 1 + l + sovModelServerConfig(uint64(l))
	}
	return n
}
func (m *ModelServerConfig_CustomModelConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CustomModelConfig != nil {
		l = m.CustomModelConfig.Size()
		n += 1 + l + sovModelServerConfig(uint64(l))
	}
	return n
}

func sovModelServerConfig(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozModelServerConfig(x uint64) (n int) {
	return sovModelServerConfig(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ModelConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelServerConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelServerConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelServerConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelType", wireType)
			}
			m.ModelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelServerConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModelType |= ModelType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelPlatform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelServerConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelPlatform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoggingConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelServerConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LoggingConfig == nil {
				m.LoggingConfig = &LoggingConfig{}
			}
			if err := m.LoggingConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelVersionPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelServerConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModelVersionPolicy == nil {
				m.ModelVersionPolicy = &FileSystemStoragePathSourceConfig_ServableVersionPolicy{}
			}
			if err := m.ModelVersionPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelServerConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VersionLabels == nil {
				m.VersionLabels = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModelServerConfig
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModelServerConfig
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthModelServerConfig
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthModelServerConfig
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModelServerConfig
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipModelServerConfig(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthModelServerConfig
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.VersionLabels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelServerConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelConfigList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelServerConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelConfigList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelConfigList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelServerConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = append(m.Config, &ModelConfig{})
			if err := m.Config[len(m.Config)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelServerConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelServerConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelServerConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelServerConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelServerConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelConfigList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelServerConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ModelConfigList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Config = &ModelServerConfig_ModelConfigList{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomModelConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelServerConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.Any{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Config = &ModelServerConfig_CustomModelConfig{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelServerConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModelServerConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipModelServerConfig(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowModelServerConfig
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModelServerConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModelServerConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthModelServerConfig
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupModelServerConfig
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthModelServerConfig
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthModelServerConfig        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowModelServerConfig          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupModelServerConfig = fmt.Errorf("proto: unexpected end of group")
)
