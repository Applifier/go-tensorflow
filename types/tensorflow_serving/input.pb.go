// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tensorflow_serving/input.proto

package tensorflow_serving

import (
	fmt "fmt"
	example "github.com/Applifier/go-tensorflow/types/tensorflow/core/example"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Specifies one or more fully independent input Examples.
// See examples at:
//     https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/example/example.proto
type ExampleList struct {
	Examples []*example.Example `protobuf:"bytes,1,rep,name=examples,proto3" json:"examples,omitempty"`
}

func (m *ExampleList) Reset()         { *m = ExampleList{} }
func (m *ExampleList) String() string { return proto.CompactTextString(m) }
func (*ExampleList) ProtoMessage()    {}
func (*ExampleList) Descriptor() ([]byte, []int) {
	return fileDescriptor_4595aa0586506d9d, []int{0}
}
func (m *ExampleList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExampleList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExampleList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExampleList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExampleList.Merge(m, src)
}
func (m *ExampleList) XXX_Size() int {
	return m.Size()
}
func (m *ExampleList) XXX_DiscardUnknown() {
	xxx_messageInfo_ExampleList.DiscardUnknown(m)
}

var xxx_messageInfo_ExampleList proto.InternalMessageInfo

func (m *ExampleList) GetExamples() []*example.Example {
	if m != nil {
		return m.Examples
	}
	return nil
}

// Specifies one or more independent input Examples, with a common context
// Example.
//
// The common use case for context is to cleanly and optimally specify some
// features that are common across multiple examples.
//
// See example below with a search query as the context and multiple restaurants
// to perform some inference on.
//
// context: {
//   features: {
//     feature: {
//       key  : "query"
//       value: {
//         bytes_list: {
//           value: [ "pizza" ]
//         }
//       }
//     }
//   }
// }
// examples: {
//   features: {
//     feature: {
//       key  : "cuisine"
//       value: {
//         bytes_list: {
//           value: [ "Pizzeria" ]
//         }
//       }
//     }
//   }
// }
// examples: {
//   features: {
//     feature: {
//       key  : "cuisine"
//       value: {
//         bytes_list: {
//           value: [ "Taqueria" ]
//         }
//       }
//     }
//   }
// }
//
// Implementations of ExampleListWithContext merge the context Example into each
// of the Examples. Note that feature keys must not be duplicated between the
// Examples and context Example, or the behavior is undefined.
//
// See also:
//     tensorflow/core/example/example.proto
//     https://developers.google.com/protocol-buffers/docs/proto3#maps
type ExampleListWithContext struct {
	Examples []*example.Example `protobuf:"bytes,1,rep,name=examples,proto3" json:"examples,omitempty"`
	Context  *example.Example   `protobuf:"bytes,2,opt,name=context,proto3" json:"context,omitempty"`
}

func (m *ExampleListWithContext) Reset()         { *m = ExampleListWithContext{} }
func (m *ExampleListWithContext) String() string { return proto.CompactTextString(m) }
func (*ExampleListWithContext) ProtoMessage()    {}
func (*ExampleListWithContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_4595aa0586506d9d, []int{1}
}
func (m *ExampleListWithContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExampleListWithContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExampleListWithContext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExampleListWithContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExampleListWithContext.Merge(m, src)
}
func (m *ExampleListWithContext) XXX_Size() int {
	return m.Size()
}
func (m *ExampleListWithContext) XXX_DiscardUnknown() {
	xxx_messageInfo_ExampleListWithContext.DiscardUnknown(m)
}

var xxx_messageInfo_ExampleListWithContext proto.InternalMessageInfo

func (m *ExampleListWithContext) GetExamples() []*example.Example {
	if m != nil {
		return m.Examples
	}
	return nil
}

func (m *ExampleListWithContext) GetContext() *example.Example {
	if m != nil {
		return m.Context
	}
	return nil
}

type Input struct {
	// Types that are valid to be assigned to Kind:
	//	*Input_ExampleList
	//	*Input_ExampleListWithContext
	Kind isInput_Kind `protobuf_oneof:"kind"`
}

func (m *Input) Reset()         { *m = Input{} }
func (m *Input) String() string { return proto.CompactTextString(m) }
func (*Input) ProtoMessage()    {}
func (*Input) Descriptor() ([]byte, []int) {
	return fileDescriptor_4595aa0586506d9d, []int{2}
}
func (m *Input) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Input) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Input.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Input) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Input.Merge(m, src)
}
func (m *Input) XXX_Size() int {
	return m.Size()
}
func (m *Input) XXX_DiscardUnknown() {
	xxx_messageInfo_Input.DiscardUnknown(m)
}

var xxx_messageInfo_Input proto.InternalMessageInfo

type isInput_Kind interface {
	isInput_Kind()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Input_ExampleList struct {
	ExampleList *ExampleList `protobuf:"bytes,1,opt,name=example_list,json=exampleList,proto3,oneof"`
}
type Input_ExampleListWithContext struct {
	ExampleListWithContext *ExampleListWithContext `protobuf:"bytes,2,opt,name=example_list_with_context,json=exampleListWithContext,proto3,oneof"`
}

func (*Input_ExampleList) isInput_Kind()            {}
func (*Input_ExampleListWithContext) isInput_Kind() {}

func (m *Input) GetKind() isInput_Kind {
	if m != nil {
		return m.Kind
	}
	return nil
}

func (m *Input) GetExampleList() *ExampleList {
	if x, ok := m.GetKind().(*Input_ExampleList); ok {
		return x.ExampleList
	}
	return nil
}

func (m *Input) GetExampleListWithContext() *ExampleListWithContext {
	if x, ok := m.GetKind().(*Input_ExampleListWithContext); ok {
		return x.ExampleListWithContext
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Input) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Input_OneofMarshaler, _Input_OneofUnmarshaler, _Input_OneofSizer, []interface{}{
		(*Input_ExampleList)(nil),
		(*Input_ExampleListWithContext)(nil),
	}
}

func _Input_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Input)
	// kind
	switch x := m.Kind.(type) {
	case *Input_ExampleList:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ExampleList); err != nil {
			return err
		}
	case *Input_ExampleListWithContext:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ExampleListWithContext); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Input.Kind has unexpected type %T", x)
	}
	return nil
}

func _Input_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Input)
	switch tag {
	case 1: // kind.example_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ExampleList)
		err := b.DecodeMessage(msg)
		m.Kind = &Input_ExampleList{msg}
		return true, err
	case 2: // kind.example_list_with_context
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ExampleListWithContext)
		err := b.DecodeMessage(msg)
		m.Kind = &Input_ExampleListWithContext{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Input_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Input)
	// kind
	switch x := m.Kind.(type) {
	case *Input_ExampleList:
		s := proto.Size(x.ExampleList)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Input_ExampleListWithContext:
		s := proto.Size(x.ExampleListWithContext)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*ExampleList)(nil), "tensorflow.serving.ExampleList")
	proto.RegisterType((*ExampleListWithContext)(nil), "tensorflow.serving.ExampleListWithContext")
	proto.RegisterType((*Input)(nil), "tensorflow.serving.Input")
}

func init() { proto.RegisterFile("tensorflow_serving/input.proto", fileDescriptor_4595aa0586506d9d) }

var fileDescriptor_4595aa0586506d9d = []byte{
	// 262 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x92, 0x2b, 0x49, 0xcd, 0x2b,
	0xce, 0x2f, 0x4a, 0xcb, 0xc9, 0x2f, 0x8f, 0x2f, 0x4e, 0x2d, 0x2a, 0xcb, 0xcc, 0x4b, 0xd7, 0xcf,
	0xcc, 0x2b, 0x28, 0x2d, 0xd1, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x12, 0x42, 0xc8, 0xeb, 0x41,
	0xe5, 0xa5, 0x54, 0x11, 0x62, 0xfa, 0xc9, 0xf9, 0x45, 0xa9, 0xfa, 0xa9, 0x15, 0x89, 0xb9, 0x05,
	0x39, 0x70, 0x1a, 0xa2, 0x55, 0xc9, 0x8e, 0x8b, 0xdb, 0x15, 0x22, 0xe0, 0x93, 0x59, 0x5c, 0x22,
	0xa4, 0xcf, 0xc5, 0x01, 0x95, 0x2f, 0x96, 0x60, 0x54, 0x60, 0xd6, 0xe0, 0x36, 0x12, 0xd6, 0x43,
	0x32, 0x1c, 0xaa, 0x34, 0x08, 0xae, 0x48, 0xa9, 0x82, 0x4b, 0x0c, 0x49, 0x7f, 0x78, 0x66, 0x49,
	0x86, 0x73, 0x7e, 0x5e, 0x49, 0x6a, 0x05, 0xe9, 0x46, 0x09, 0xe9, 0x72, 0xb1, 0x27, 0x43, 0xf4,
	0x4a, 0x30, 0x29, 0x30, 0xe2, 0x52, 0x0f, 0x53, 0xa3, 0x74, 0x8c, 0x91, 0x8b, 0xd5, 0x13, 0x14,
	0x08, 0x42, 0x1e, 0x5c, 0x3c, 0x50, 0x43, 0xe2, 0x73, 0x32, 0x8b, 0x4b, 0x24, 0x18, 0xc1, 0xba,
	0xe5, 0xf5, 0x30, 0x43, 0x45, 0x0f, 0xc9, 0xad, 0x4e, 0x4c, 0x1a, 0x8c, 0x1e, 0x0c, 0x41, 0xdc,
	0xa9, 0x48, 0xde, 0xcf, 0xe6, 0x92, 0x44, 0x36, 0x29, 0xbe, 0x3c, 0xb3, 0x24, 0x23, 0x1e, 0xd5,
	0x51, 0x5a, 0x04, 0x8c, 0x45, 0x0a, 0x02, 0xa8, 0x0d, 0x62, 0xa9, 0xd8, 0x65, 0xd9, 0xb8, 0x58,
	0xb2, 0x33, 0xf3, 0x52, 0x9c, 0xa4, 0x4f, 0x3c, 0x92, 0x63, 0xbc, 0xf0, 0x48, 0x8e, 0xf1, 0xc1,
	0x23, 0x39, 0xc6, 0x09, 0x8f, 0xe5, 0x18, 0x2e, 0x3c, 0x96, 0x63, 0xb8, 0xf1, 0x58, 0x8e, 0xe1,
	0x07, 0x23, 0x63, 0x12, 0x1b, 0x38, 0x9a, 0x8c, 0x01, 0x01, 0x00, 0x00, 0xff, 0xff, 0xc4, 0x53,
	0xa4, 0xa2, 0x03, 0x02, 0x00, 0x00,
}

func (m *ExampleList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExampleList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Examples) > 0 {
		for _, msg := range m.Examples {
			dAtA[i] = 0xa
			i++
			i = encodeVarintInput(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ExampleListWithContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExampleListWithContext) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Examples) > 0 {
		for _, msg := range m.Examples {
			dAtA[i] = 0xa
			i++
			i = encodeVarintInput(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Context != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInput(dAtA, i, uint64(m.Context.Size()))
		n1, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *Input) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Input) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Kind != nil {
		nn2, err := m.Kind.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn2
	}
	return i, nil
}

func (m *Input_ExampleList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ExampleList != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInput(dAtA, i, uint64(m.ExampleList.Size()))
		n3, err := m.ExampleList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *Input_ExampleListWithContext) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ExampleListWithContext != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInput(dAtA, i, uint64(m.ExampleListWithContext.Size()))
		n4, err := m.ExampleListWithContext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func encodeVarintInput(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ExampleList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Examples) > 0 {
		for _, e := range m.Examples {
			l = e.Size()
			n += 1 + l + sovInput(uint64(l))
		}
	}
	return n
}

func (m *ExampleListWithContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Examples) > 0 {
		for _, e := range m.Examples {
			l = e.Size()
			n += 1 + l + sovInput(uint64(l))
		}
	}
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovInput(uint64(l))
	}
	return n
}

func (m *Input) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != nil {
		n += m.Kind.Size()
	}
	return n
}

func (m *Input_ExampleList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExampleList != nil {
		l = m.ExampleList.Size()
		n += 1 + l + sovInput(uint64(l))
	}
	return n
}
func (m *Input_ExampleListWithContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExampleListWithContext != nil {
		l = m.ExampleListWithContext.Size()
		n += 1 + l + sovInput(uint64(l))
	}
	return n
}

func sovInput(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozInput(x uint64) (n int) {
	return sovInput(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ExampleList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInput
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExampleList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExampleList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Examples", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInput
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Examples = append(m.Examples, &example.Example{})
			if err := m.Examples[len(m.Examples)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInput(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInput
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExampleListWithContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInput
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExampleListWithContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExampleListWithContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Examples", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInput
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Examples = append(m.Examples, &example.Example{})
			if err := m.Examples[len(m.Examples)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInput
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &example.Example{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInput(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInput
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Input) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInput
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Input: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Input: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExampleList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInput
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ExampleList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &Input_ExampleList{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExampleListWithContext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInput
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ExampleListWithContext{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &Input_ExampleListWithContext{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInput(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInput
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipInput(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowInput
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInput
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInput
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthInput
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowInput
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipInput(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthInput = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowInput   = fmt.Errorf("proto: integer overflow")
)
