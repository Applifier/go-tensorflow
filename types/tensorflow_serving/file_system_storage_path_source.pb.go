// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tensorflow_serving/file_system_storage_path_source.proto

package tensorflow_serving

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Config proto for FileSystemStoragePathSource.
type FileSystemStoragePathSourceConfig struct {
	// The servables to monitor for new versions, and aspire.
	Servables []*FileSystemStoragePathSourceConfig_ServableToMonitor `protobuf:"bytes,5,rep,name=servables" json:"servables,omitempty"`
	// A single servable name/base_path pair to monitor.
	// DEPRECATED: Use 'servables' instead.
	// TODO(b/30898016): Stop using these fields, and ultimately remove them here.
	ServableName string `protobuf:"bytes,1,opt,name=servable_name,json=servableName,proto3" json:"servable_name,omitempty"`
	BasePath     string `protobuf:"bytes,2,opt,name=base_path,json=basePath,proto3" json:"base_path,omitempty"`
	// How long to wait between file-system polling to look for children of
	// 'base_path', in seconds.
	//
	// For testing use only: a negative value disables the polling thread.
	FileSystemPollWaitSeconds int64 `protobuf:"varint,3,opt,name=file_system_poll_wait_seconds,json=fileSystemPollWaitSeconds,proto3" json:"file_system_poll_wait_seconds,omitempty"`
	// If true, then FileSystemStoragePathSource::Create() and ::UpdateConfig()
	// fail if, for any configured servables, the file system doesn't currently
	// contain at least one version under the base path.
	// (Otherwise, it will emit a warning and keep pinging the file system to
	// check for a version to appear later.)
	FailIfZeroVersionsAtStartup bool `protobuf:"varint,4,opt,name=fail_if_zero_versions_at_startup,json=failIfZeroVersionsAtStartup,proto3" json:"fail_if_zero_versions_at_startup,omitempty"`
}

func (m *FileSystemStoragePathSourceConfig) Reset()         { *m = FileSystemStoragePathSourceConfig{} }
func (m *FileSystemStoragePathSourceConfig) String() string { return proto.CompactTextString(m) }
func (*FileSystemStoragePathSourceConfig) ProtoMessage()    {}
func (*FileSystemStoragePathSourceConfig) Descriptor() ([]byte, []int) {
	return fileDescriptorFileSystemStoragePathSource, []int{0}
}

func (m *FileSystemStoragePathSourceConfig) GetServables() []*FileSystemStoragePathSourceConfig_ServableToMonitor {
	if m != nil {
		return m.Servables
	}
	return nil
}

func (m *FileSystemStoragePathSourceConfig) GetServableName() string {
	if m != nil {
		return m.ServableName
	}
	return ""
}

func (m *FileSystemStoragePathSourceConfig) GetBasePath() string {
	if m != nil {
		return m.BasePath
	}
	return ""
}

func (m *FileSystemStoragePathSourceConfig) GetFileSystemPollWaitSeconds() int64 {
	if m != nil {
		return m.FileSystemPollWaitSeconds
	}
	return 0
}

func (m *FileSystemStoragePathSourceConfig) GetFailIfZeroVersionsAtStartup() bool {
	if m != nil {
		return m.FailIfZeroVersionsAtStartup
	}
	return false
}

// A policy that dictates which version(s) of a servable should be served.
type FileSystemStoragePathSourceConfig_ServableVersionPolicy struct {
	// Types that are valid to be assigned to PolicyChoice:
	//	*FileSystemStoragePathSourceConfig_ServableVersionPolicy_Latest_
	//	*FileSystemStoragePathSourceConfig_ServableVersionPolicy_All_
	//	*FileSystemStoragePathSourceConfig_ServableVersionPolicy_Specific_
	PolicyChoice isFileSystemStoragePathSourceConfig_ServableVersionPolicy_PolicyChoice `protobuf_oneof:"policy_choice"`
}

func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy) Reset() {
	*m = FileSystemStoragePathSourceConfig_ServableVersionPolicy{}
}
func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy) String() string {
	return proto.CompactTextString(m)
}
func (*FileSystemStoragePathSourceConfig_ServableVersionPolicy) ProtoMessage() {}
func (*FileSystemStoragePathSourceConfig_ServableVersionPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptorFileSystemStoragePathSource, []int{0, 0}
}

type isFileSystemStoragePathSourceConfig_ServableVersionPolicy_PolicyChoice interface {
	isFileSystemStoragePathSourceConfig_ServableVersionPolicy_PolicyChoice()
	MarshalTo([]byte) (int, error)
	Size() int
}

type FileSystemStoragePathSourceConfig_ServableVersionPolicy_Latest_ struct {
	Latest *FileSystemStoragePathSourceConfig_ServableVersionPolicy_Latest `protobuf:"bytes,100,opt,name=latest,oneof"`
}
type FileSystemStoragePathSourceConfig_ServableVersionPolicy_All_ struct {
	All *FileSystemStoragePathSourceConfig_ServableVersionPolicy_All `protobuf:"bytes,101,opt,name=all,oneof"`
}
type FileSystemStoragePathSourceConfig_ServableVersionPolicy_Specific_ struct {
	Specific *FileSystemStoragePathSourceConfig_ServableVersionPolicy_Specific `protobuf:"bytes,102,opt,name=specific,oneof"`
}

func (*FileSystemStoragePathSourceConfig_ServableVersionPolicy_Latest_) isFileSystemStoragePathSourceConfig_ServableVersionPolicy_PolicyChoice() {
}
func (*FileSystemStoragePathSourceConfig_ServableVersionPolicy_All_) isFileSystemStoragePathSourceConfig_ServableVersionPolicy_PolicyChoice() {
}
func (*FileSystemStoragePathSourceConfig_ServableVersionPolicy_Specific_) isFileSystemStoragePathSourceConfig_ServableVersionPolicy_PolicyChoice() {
}

func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy) GetPolicyChoice() isFileSystemStoragePathSourceConfig_ServableVersionPolicy_PolicyChoice {
	if m != nil {
		return m.PolicyChoice
	}
	return nil
}

func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy) GetLatest() *FileSystemStoragePathSourceConfig_ServableVersionPolicy_Latest {
	if x, ok := m.GetPolicyChoice().(*FileSystemStoragePathSourceConfig_ServableVersionPolicy_Latest_); ok {
		return x.Latest
	}
	return nil
}

func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy) GetAll() *FileSystemStoragePathSourceConfig_ServableVersionPolicy_All {
	if x, ok := m.GetPolicyChoice().(*FileSystemStoragePathSourceConfig_ServableVersionPolicy_All_); ok {
		return x.All
	}
	return nil
}

func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy) GetSpecific() *FileSystemStoragePathSourceConfig_ServableVersionPolicy_Specific {
	if x, ok := m.GetPolicyChoice().(*FileSystemStoragePathSourceConfig_ServableVersionPolicy_Specific_); ok {
		return x.Specific
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FileSystemStoragePathSourceConfig_ServableVersionPolicy) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FileSystemStoragePathSourceConfig_ServableVersionPolicy_OneofMarshaler, _FileSystemStoragePathSourceConfig_ServableVersionPolicy_OneofUnmarshaler, _FileSystemStoragePathSourceConfig_ServableVersionPolicy_OneofSizer, []interface{}{
		(*FileSystemStoragePathSourceConfig_ServableVersionPolicy_Latest_)(nil),
		(*FileSystemStoragePathSourceConfig_ServableVersionPolicy_All_)(nil),
		(*FileSystemStoragePathSourceConfig_ServableVersionPolicy_Specific_)(nil),
	}
}

func _FileSystemStoragePathSourceConfig_ServableVersionPolicy_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FileSystemStoragePathSourceConfig_ServableVersionPolicy)
	// policy_choice
	switch x := m.PolicyChoice.(type) {
	case *FileSystemStoragePathSourceConfig_ServableVersionPolicy_Latest_:
		_ = b.EncodeVarint(100<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Latest); err != nil {
			return err
		}
	case *FileSystemStoragePathSourceConfig_ServableVersionPolicy_All_:
		_ = b.EncodeVarint(101<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.All); err != nil {
			return err
		}
	case *FileSystemStoragePathSourceConfig_ServableVersionPolicy_Specific_:
		_ = b.EncodeVarint(102<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Specific); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FileSystemStoragePathSourceConfig_ServableVersionPolicy.PolicyChoice has unexpected type %T", x)
	}
	return nil
}

func _FileSystemStoragePathSourceConfig_ServableVersionPolicy_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FileSystemStoragePathSourceConfig_ServableVersionPolicy)
	switch tag {
	case 100: // policy_choice.latest
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FileSystemStoragePathSourceConfig_ServableVersionPolicy_Latest)
		err := b.DecodeMessage(msg)
		m.PolicyChoice = &FileSystemStoragePathSourceConfig_ServableVersionPolicy_Latest_{msg}
		return true, err
	case 101: // policy_choice.all
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FileSystemStoragePathSourceConfig_ServableVersionPolicy_All)
		err := b.DecodeMessage(msg)
		m.PolicyChoice = &FileSystemStoragePathSourceConfig_ServableVersionPolicy_All_{msg}
		return true, err
	case 102: // policy_choice.specific
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FileSystemStoragePathSourceConfig_ServableVersionPolicy_Specific)
		err := b.DecodeMessage(msg)
		m.PolicyChoice = &FileSystemStoragePathSourceConfig_ServableVersionPolicy_Specific_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FileSystemStoragePathSourceConfig_ServableVersionPolicy_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FileSystemStoragePathSourceConfig_ServableVersionPolicy)
	// policy_choice
	switch x := m.PolicyChoice.(type) {
	case *FileSystemStoragePathSourceConfig_ServableVersionPolicy_Latest_:
		s := proto.Size(x.Latest)
		n += proto.SizeVarint(100<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FileSystemStoragePathSourceConfig_ServableVersionPolicy_All_:
		s := proto.Size(x.All)
		n += proto.SizeVarint(101<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FileSystemStoragePathSourceConfig_ServableVersionPolicy_Specific_:
		s := proto.Size(x.Specific)
		n += proto.SizeVarint(102<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Serve the latest versions (i.e. the ones with the highest version
// numbers), among those found on disk.
//
// This is the default policy, with the default number of versions as 1.
type FileSystemStoragePathSourceConfig_ServableVersionPolicy_Latest struct {
	// Number of latest versions to serve. (The default is 1.)
	NumVersions uint32 `protobuf:"varint,1,opt,name=num_versions,json=numVersions,proto3" json:"num_versions,omitempty"`
}

func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy_Latest) Reset() {
	*m = FileSystemStoragePathSourceConfig_ServableVersionPolicy_Latest{}
}
func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy_Latest) String() string {
	return proto.CompactTextString(m)
}
func (*FileSystemStoragePathSourceConfig_ServableVersionPolicy_Latest) ProtoMessage() {}
func (*FileSystemStoragePathSourceConfig_ServableVersionPolicy_Latest) Descriptor() ([]byte, []int) {
	return fileDescriptorFileSystemStoragePathSource, []int{0, 0, 0}
}

func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy_Latest) GetNumVersions() uint32 {
	if m != nil {
		return m.NumVersions
	}
	return 0
}

// Serve all versions found on disk.
type FileSystemStoragePathSourceConfig_ServableVersionPolicy_All struct {
}

func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy_All) Reset() {
	*m = FileSystemStoragePathSourceConfig_ServableVersionPolicy_All{}
}
func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy_All) String() string {
	return proto.CompactTextString(m)
}
func (*FileSystemStoragePathSourceConfig_ServableVersionPolicy_All) ProtoMessage() {}
func (*FileSystemStoragePathSourceConfig_ServableVersionPolicy_All) Descriptor() ([]byte, []int) {
	return fileDescriptorFileSystemStoragePathSource, []int{0, 0, 1}
}

// Serve a specific version (or set of versions).
//
// This policy is useful for rolling back to a specific version, or for
// canarying a specific version while still serving a separate stable
// version.
type FileSystemStoragePathSourceConfig_ServableVersionPolicy_Specific struct {
	// The version numbers to serve.
	Versions []int64 `protobuf:"varint,1,rep,packed,name=versions" json:"versions,omitempty"`
}

func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy_Specific) Reset() {
	*m = FileSystemStoragePathSourceConfig_ServableVersionPolicy_Specific{}
}
func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy_Specific) String() string {
	return proto.CompactTextString(m)
}
func (*FileSystemStoragePathSourceConfig_ServableVersionPolicy_Specific) ProtoMessage() {}
func (*FileSystemStoragePathSourceConfig_ServableVersionPolicy_Specific) Descriptor() ([]byte, []int) {
	return fileDescriptorFileSystemStoragePathSource, []int{0, 0, 2}
}

func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy_Specific) GetVersions() []int64 {
	if m != nil {
		return m.Versions
	}
	return nil
}

// A servable name and base path to look for versions of the servable.
type FileSystemStoragePathSourceConfig_ServableToMonitor struct {
	// The servable name to supply in aspired-versions callback calls. Child
	// paths of 'base_path' are considered to be versions of this servable.
	ServableName string `protobuf:"bytes,1,opt,name=servable_name,json=servableName,proto3" json:"servable_name,omitempty"`
	// The path to monitor, i.e. look for child paths of the form base_path/123.
	BasePath string `protobuf:"bytes,2,opt,name=base_path,json=basePath,proto3" json:"base_path,omitempty"`
	// The policy to determines the number of versions of the servable to be
	// served at the same time.
	ServableVersionPolicy *FileSystemStoragePathSourceConfig_ServableVersionPolicy `protobuf:"bytes,4,opt,name=servable_version_policy,json=servableVersionPolicy" json:"servable_version_policy,omitempty"`
}

func (m *FileSystemStoragePathSourceConfig_ServableToMonitor) Reset() {
	*m = FileSystemStoragePathSourceConfig_ServableToMonitor{}
}
func (m *FileSystemStoragePathSourceConfig_ServableToMonitor) String() string {
	return proto.CompactTextString(m)
}
func (*FileSystemStoragePathSourceConfig_ServableToMonitor) ProtoMessage() {}
func (*FileSystemStoragePathSourceConfig_ServableToMonitor) Descriptor() ([]byte, []int) {
	return fileDescriptorFileSystemStoragePathSource, []int{0, 1}
}

func (m *FileSystemStoragePathSourceConfig_ServableToMonitor) GetServableName() string {
	if m != nil {
		return m.ServableName
	}
	return ""
}

func (m *FileSystemStoragePathSourceConfig_ServableToMonitor) GetBasePath() string {
	if m != nil {
		return m.BasePath
	}
	return ""
}

func (m *FileSystemStoragePathSourceConfig_ServableToMonitor) GetServableVersionPolicy() *FileSystemStoragePathSourceConfig_ServableVersionPolicy {
	if m != nil {
		return m.ServableVersionPolicy
	}
	return nil
}

func init() {
	proto.RegisterType((*FileSystemStoragePathSourceConfig)(nil), "tensorflow.serving.FileSystemStoragePathSourceConfig")
	proto.RegisterType((*FileSystemStoragePathSourceConfig_ServableVersionPolicy)(nil), "tensorflow.serving.FileSystemStoragePathSourceConfig.ServableVersionPolicy")
	proto.RegisterType((*FileSystemStoragePathSourceConfig_ServableVersionPolicy_Latest)(nil), "tensorflow.serving.FileSystemStoragePathSourceConfig.ServableVersionPolicy.Latest")
	proto.RegisterType((*FileSystemStoragePathSourceConfig_ServableVersionPolicy_All)(nil), "tensorflow.serving.FileSystemStoragePathSourceConfig.ServableVersionPolicy.All")
	proto.RegisterType((*FileSystemStoragePathSourceConfig_ServableVersionPolicy_Specific)(nil), "tensorflow.serving.FileSystemStoragePathSourceConfig.ServableVersionPolicy.Specific")
	proto.RegisterType((*FileSystemStoragePathSourceConfig_ServableToMonitor)(nil), "tensorflow.serving.FileSystemStoragePathSourceConfig.ServableToMonitor")
}
func (m *FileSystemStoragePathSourceConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileSystemStoragePathSourceConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ServableName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFileSystemStoragePathSource(dAtA, i, uint64(len(m.ServableName)))
		i += copy(dAtA[i:], m.ServableName)
	}
	if len(m.BasePath) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFileSystemStoragePathSource(dAtA, i, uint64(len(m.BasePath)))
		i += copy(dAtA[i:], m.BasePath)
	}
	if m.FileSystemPollWaitSeconds != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFileSystemStoragePathSource(dAtA, i, uint64(m.FileSystemPollWaitSeconds))
	}
	if m.FailIfZeroVersionsAtStartup {
		dAtA[i] = 0x20
		i++
		if m.FailIfZeroVersionsAtStartup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Servables) > 0 {
		for _, msg := range m.Servables {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintFileSystemStoragePathSource(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PolicyChoice != nil {
		nn1, err := m.PolicyChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy_Latest_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Latest != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintFileSystemStoragePathSource(dAtA, i, uint64(m.Latest.Size()))
		n2, err := m.Latest.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy_All_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.All != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintFileSystemStoragePathSource(dAtA, i, uint64(m.All.Size()))
		n3, err := m.All.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy_Specific_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Specific != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintFileSystemStoragePathSource(dAtA, i, uint64(m.Specific.Size()))
		n4, err := m.Specific.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy_Latest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy_Latest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumVersions != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFileSystemStoragePathSource(dAtA, i, uint64(m.NumVersions))
	}
	return i, nil
}

func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy_All) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy_All) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy_Specific) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy_Specific) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Versions) > 0 {
		dAtA6 := make([]byte, len(m.Versions)*10)
		var j5 int
		for _, num1 := range m.Versions {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintFileSystemStoragePathSource(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	return i, nil
}

func (m *FileSystemStoragePathSourceConfig_ServableToMonitor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileSystemStoragePathSourceConfig_ServableToMonitor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ServableName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFileSystemStoragePathSource(dAtA, i, uint64(len(m.ServableName)))
		i += copy(dAtA[i:], m.ServableName)
	}
	if len(m.BasePath) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFileSystemStoragePathSource(dAtA, i, uint64(len(m.BasePath)))
		i += copy(dAtA[i:], m.BasePath)
	}
	if m.ServableVersionPolicy != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintFileSystemStoragePathSource(dAtA, i, uint64(m.ServableVersionPolicy.Size()))
		n7, err := m.ServableVersionPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func encodeVarintFileSystemStoragePathSource(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *FileSystemStoragePathSourceConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.ServableName)
	if l > 0 {
		n += 1 + l + sovFileSystemStoragePathSource(uint64(l))
	}
	l = len(m.BasePath)
	if l > 0 {
		n += 1 + l + sovFileSystemStoragePathSource(uint64(l))
	}
	if m.FileSystemPollWaitSeconds != 0 {
		n += 1 + sovFileSystemStoragePathSource(uint64(m.FileSystemPollWaitSeconds))
	}
	if m.FailIfZeroVersionsAtStartup {
		n += 2
	}
	if len(m.Servables) > 0 {
		for _, e := range m.Servables {
			l = e.Size()
			n += 1 + l + sovFileSystemStoragePathSource(uint64(l))
		}
	}
	return n
}

func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy) Size() (n int) {
	var l int
	_ = l
	if m.PolicyChoice != nil {
		n += m.PolicyChoice.Size()
	}
	return n
}

func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy_Latest_) Size() (n int) {
	var l int
	_ = l
	if m.Latest != nil {
		l = m.Latest.Size()
		n += 2 + l + sovFileSystemStoragePathSource(uint64(l))
	}
	return n
}
func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy_All_) Size() (n int) {
	var l int
	_ = l
	if m.All != nil {
		l = m.All.Size()
		n += 2 + l + sovFileSystemStoragePathSource(uint64(l))
	}
	return n
}
func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy_Specific_) Size() (n int) {
	var l int
	_ = l
	if m.Specific != nil {
		l = m.Specific.Size()
		n += 2 + l + sovFileSystemStoragePathSource(uint64(l))
	}
	return n
}
func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy_Latest) Size() (n int) {
	var l int
	_ = l
	if m.NumVersions != 0 {
		n += 1 + sovFileSystemStoragePathSource(uint64(m.NumVersions))
	}
	return n
}

func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy_All) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy_Specific) Size() (n int) {
	var l int
	_ = l
	if len(m.Versions) > 0 {
		l = 0
		for _, e := range m.Versions {
			l += sovFileSystemStoragePathSource(uint64(e))
		}
		n += 1 + sovFileSystemStoragePathSource(uint64(l)) + l
	}
	return n
}

func (m *FileSystemStoragePathSourceConfig_ServableToMonitor) Size() (n int) {
	var l int
	_ = l
	l = len(m.ServableName)
	if l > 0 {
		n += 1 + l + sovFileSystemStoragePathSource(uint64(l))
	}
	l = len(m.BasePath)
	if l > 0 {
		n += 1 + l + sovFileSystemStoragePathSource(uint64(l))
	}
	if m.ServableVersionPolicy != nil {
		l = m.ServableVersionPolicy.Size()
		n += 1 + l + sovFileSystemStoragePathSource(uint64(l))
	}
	return n
}

func sovFileSystemStoragePathSource(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozFileSystemStoragePathSource(x uint64) (n int) {
	return sovFileSystemStoragePathSource(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FileSystemStoragePathSourceConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFileSystemStoragePathSource
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileSystemStoragePathSourceConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileSystemStoragePathSourceConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFileSystemStoragePathSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFileSystemStoragePathSource
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFileSystemStoragePathSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFileSystemStoragePathSource
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSystemPollWaitSeconds", wireType)
			}
			m.FileSystemPollWaitSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFileSystemStoragePathSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSystemPollWaitSeconds |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailIfZeroVersionsAtStartup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFileSystemStoragePathSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FailIfZeroVersionsAtStartup = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Servables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFileSystemStoragePathSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFileSystemStoragePathSource
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Servables = append(m.Servables, &FileSystemStoragePathSourceConfig_ServableToMonitor{})
			if err := m.Servables[len(m.Servables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFileSystemStoragePathSource(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFileSystemStoragePathSource
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFileSystemStoragePathSource
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServableVersionPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServableVersionPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFileSystemStoragePathSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFileSystemStoragePathSource
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FileSystemStoragePathSourceConfig_ServableVersionPolicy_Latest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PolicyChoice = &FileSystemStoragePathSourceConfig_ServableVersionPolicy_Latest_{v}
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFileSystemStoragePathSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFileSystemStoragePathSource
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FileSystemStoragePathSourceConfig_ServableVersionPolicy_All{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PolicyChoice = &FileSystemStoragePathSourceConfig_ServableVersionPolicy_All_{v}
			iNdEx = postIndex
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Specific", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFileSystemStoragePathSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFileSystemStoragePathSource
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FileSystemStoragePathSourceConfig_ServableVersionPolicy_Specific{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PolicyChoice = &FileSystemStoragePathSourceConfig_ServableVersionPolicy_Specific_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFileSystemStoragePathSource(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFileSystemStoragePathSource
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy_Latest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFileSystemStoragePathSource
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Latest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Latest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumVersions", wireType)
			}
			m.NumVersions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFileSystemStoragePathSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumVersions |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFileSystemStoragePathSource(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFileSystemStoragePathSource
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy_All) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFileSystemStoragePathSource
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: All: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: All: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFileSystemStoragePathSource(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFileSystemStoragePathSource
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileSystemStoragePathSourceConfig_ServableVersionPolicy_Specific) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFileSystemStoragePathSource
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Specific: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Specific: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFileSystemStoragePathSource
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Versions = append(m.Versions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFileSystemStoragePathSource
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFileSystemStoragePathSource
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFileSystemStoragePathSource
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Versions = append(m.Versions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Versions", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFileSystemStoragePathSource(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFileSystemStoragePathSource
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileSystemStoragePathSourceConfig_ServableToMonitor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFileSystemStoragePathSource
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServableToMonitor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServableToMonitor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFileSystemStoragePathSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFileSystemStoragePathSource
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFileSystemStoragePathSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFileSystemStoragePathSource
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServableVersionPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFileSystemStoragePathSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFileSystemStoragePathSource
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServableVersionPolicy == nil {
				m.ServableVersionPolicy = &FileSystemStoragePathSourceConfig_ServableVersionPolicy{}
			}
			if err := m.ServableVersionPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFileSystemStoragePathSource(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFileSystemStoragePathSource
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFileSystemStoragePathSource(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFileSystemStoragePathSource
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFileSystemStoragePathSource
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFileSystemStoragePathSource
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthFileSystemStoragePathSource
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowFileSystemStoragePathSource
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipFileSystemStoragePathSource(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthFileSystemStoragePathSource = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFileSystemStoragePathSource   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("tensorflow_serving/file_system_storage_path_source.proto", fileDescriptorFileSystemStoragePathSource)
}

var fileDescriptorFileSystemStoragePathSource = []byte{
	// 514 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x94, 0xdf, 0x8a, 0xd3, 0x40,
	0x14, 0xc6, 0x3b, 0x9b, 0x6e, 0x49, 0xa7, 0x5b, 0x5c, 0x07, 0x16, 0x63, 0x16, 0x6b, 0x56, 0x41,
	0x03, 0x42, 0x84, 0x7a, 0xe3, 0xa5, 0xad, 0xa8, 0xf5, 0x7f, 0x99, 0x2c, 0x0a, 0xde, 0x0c, 0xd3,
	0xec, 0xa4, 0x1d, 0x98, 0x64, 0xc2, 0xcc, 0x74, 0x97, 0xf5, 0xd6, 0x07, 0xd0, 0xc7, 0x12, 0xbc,
	0xf1, 0x11, 0xb4, 0xbe, 0x88, 0xe4, 0xef, 0x56, 0xbb, 0xe0, 0x85, 0xbd, 0xcc, 0xe4, 0xfb, 0xbe,
	0xdf, 0xc9, 0x99, 0x73, 0x02, 0x1f, 0x1a, 0x96, 0x6a, 0xa9, 0x62, 0x21, 0xcf, 0x88, 0x66, 0xea,
	0x94, 0xa7, 0xf3, 0xfb, 0x31, 0x17, 0x8c, 0xe8, 0x73, 0x6d, 0x58, 0x42, 0xb4, 0x91, 0x8a, 0xce,
	0x19, 0xc9, 0xa8, 0x59, 0x10, 0x2d, 0x97, 0x2a, 0x62, 0x41, 0xa6, 0xa4, 0x91, 0x08, 0x5d, 0x38,
	0x83, 0xca, 0x79, 0xeb, 0xb3, 0x0d, 0x8f, 0x9e, 0x72, 0xc1, 0xc2, 0xc2, 0x1c, 0x96, 0xde, 0x29,
	0x35, 0x8b, 0xb0, 0x70, 0x3e, 0x96, 0x69, 0xcc, 0xe7, 0xe8, 0x2e, 0xec, 0xe7, 0x06, 0x3a, 0x13,
	0x8c, 0xa4, 0x34, 0x61, 0x0e, 0xf0, 0x80, 0xdf, 0x1d, 0xef, 0x38, 0x00, 0xef, 0xd5, 0x2f, 0xde,
	0xd0, 0x84, 0xa1, 0x9b, 0xb0, 0x3b, 0xa3, 0xba, 0x84, 0x3b, 0x3b, 0x8d, 0xc8, 0xce, 0x0f, 0xf3,
	0x54, 0xf4, 0x08, 0xde, 0x58, 0x2f, 0x36, 0x93, 0x42, 0x90, 0x33, 0xca, 0x0d, 0xd1, 0x2c, 0x92,
	0xe9, 0x89, 0x76, 0x2c, 0x0f, 0xf8, 0x16, 0xbe, 0x1e, 0x37, 0x35, 0x4d, 0xa5, 0x10, 0xef, 0x29,
	0x37, 0x61, 0x29, 0x40, 0x4f, 0xa0, 0x17, 0x53, 0x2e, 0x08, 0x8f, 0xc9, 0x47, 0xa6, 0x24, 0x39,
	0x65, 0x4a, 0x73, 0x99, 0x6a, 0x42, 0x0d, 0xd1, 0x86, 0x2a, 0xb3, 0xcc, 0x9c, 0xb6, 0x07, 0x7c,
	0x1b, 0x1f, 0xe6, 0xba, 0xe7, 0xf1, 0x07, 0xa6, 0xe4, 0xbb, 0x4a, 0x34, 0x32, 0x61, 0x29, 0x41,
	0x0c, 0x76, 0xeb, 0xca, 0xb5, 0xb3, 0xeb, 0x59, 0x7e, 0x6f, 0xf8, 0x2c, 0xd8, 0x6c, 0x50, 0xf0,
	0xcf, 0xe6, 0x04, 0x61, 0x15, 0x73, 0x2c, 0x5f, 0xcb, 0x94, 0x1b, 0xa9, 0xf0, 0x45, 0xb2, 0xfb,
	0xcd, 0x82, 0x07, 0xb5, 0xa0, 0x2a, 0x62, 0x2a, 0x05, 0x8f, 0xce, 0x91, 0x80, 0x1d, 0x41, 0x0d,
	0xd3, 0xc6, 0x39, 0xf1, 0x80, 0xdf, 0x1b, 0xe2, 0xff, 0xa3, 0xff, 0x11, 0x1e, 0xbc, 0x2a, 0x92,
	0x27, 0x2d, 0x5c, 0x31, 0x50, 0x04, 0x2d, 0x2a, 0x84, 0xc3, 0x0a, 0xd4, 0xdb, 0x6d, 0xa2, 0x46,
	0x42, 0x4c, 0x5a, 0x38, 0x4f, 0x47, 0x0a, 0xda, 0x3a, 0x63, 0x11, 0x8f, 0x79, 0xe4, 0xc4, 0x05,
	0xe9, 0x78, 0x9b, 0xa4, 0xb0, 0xca, 0x9e, 0xb4, 0x70, 0xc3, 0x71, 0xef, 0xc1, 0x4e, 0xf9, 0xb1,
	0xe8, 0x08, 0xee, 0xa5, 0xcb, 0xa4, 0x99, 0x87, 0x62, 0x46, 0xfb, 0xb8, 0x97, 0x2e, 0x93, 0xfa,
	0xf6, 0xdd, 0x5d, 0x68, 0x8d, 0x84, 0x70, 0xef, 0x40, 0xbb, 0xce, 0x42, 0x2e, 0xb4, 0xd7, 0x1c,
	0x96, 0x6f, 0xe1, 0xe6, 0x79, 0x7c, 0x05, 0xf6, 0xb3, 0x02, 0x4d, 0xa2, 0x85, 0xe4, 0x11, 0x73,
	0x7f, 0x02, 0x78, 0x75, 0xe3, 0xba, 0xd1, 0xed, 0x4b, 0xb7, 0xe3, 0xaf, 0xcd, 0x38, 0xdc, 0xd8,
	0x8c, 0xb5, 0xad, 0xf8, 0x04, 0xe0, 0xb5, 0x26, 0xa2, 0xc2, 0x93, 0x12, 0x5d, 0xcc, 0x72, 0x6f,
	0xf8, 0x72, 0x8b, 0x8d, 0xc4, 0x07, 0xfa, 0xb2, 0xe3, 0x17, 0x6d, 0xdb, 0xda, 0x6f, 0x8f, 0xf7,
	0xbf, 0xae, 0x06, 0xe0, 0xfb, 0x6a, 0x00, 0x7e, 0xac, 0x06, 0xe0, 0xcb, 0xaf, 0x41, 0x6b, 0xd6,
	0x29, 0x7e, 0x1f, 0x0f, 0x7e, 0x07, 0x00, 0x00, 0xff, 0xff, 0xd2, 0xf4, 0xb2, 0x19, 0x7a, 0x04,
	0x00, 0x00,
}
