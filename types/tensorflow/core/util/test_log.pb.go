// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tensorflow/core/util/test_log.proto

package util

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// The type of benchmark.
type TestResults_BenchmarkType int32

const (
	TestResults_UNKNOWN            TestResults_BenchmarkType = 0
	TestResults_CPP_MICROBENCHMARK TestResults_BenchmarkType = 1
	TestResults_PYTHON_BENCHMARK   TestResults_BenchmarkType = 2
	TestResults_ANDROID_BENCHMARK  TestResults_BenchmarkType = 3
	TestResults_EDGE_BENCHMARK     TestResults_BenchmarkType = 4
)

var TestResults_BenchmarkType_name = map[int32]string{
	0: "UNKNOWN",
	1: "CPP_MICROBENCHMARK",
	2: "PYTHON_BENCHMARK",
	3: "ANDROID_BENCHMARK",
	4: "EDGE_BENCHMARK",
}

var TestResults_BenchmarkType_value = map[string]int32{
	"UNKNOWN":            0,
	"CPP_MICROBENCHMARK": 1,
	"PYTHON_BENCHMARK":   2,
	"ANDROID_BENCHMARK":  3,
	"EDGE_BENCHMARK":     4,
}

func (x TestResults_BenchmarkType) String() string {
	return proto.EnumName(TestResults_BenchmarkType_name, int32(x))
}

func (TestResults_BenchmarkType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_cee84bc6d943a572, []int{13, 0}
}

type EntryValue struct {
	// Types that are valid to be assigned to Kind:
	//	*EntryValue_DoubleValue
	//	*EntryValue_StringValue
	Kind isEntryValue_Kind `protobuf_oneof:"kind"`
}

func (m *EntryValue) Reset()         { *m = EntryValue{} }
func (m *EntryValue) String() string { return proto.CompactTextString(m) }
func (*EntryValue) ProtoMessage()    {}
func (*EntryValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_cee84bc6d943a572, []int{0}
}
func (m *EntryValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EntryValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EntryValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EntryValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntryValue.Merge(m, src)
}
func (m *EntryValue) XXX_Size() int {
	return m.Size()
}
func (m *EntryValue) XXX_DiscardUnknown() {
	xxx_messageInfo_EntryValue.DiscardUnknown(m)
}

var xxx_messageInfo_EntryValue proto.InternalMessageInfo

type isEntryValue_Kind interface {
	isEntryValue_Kind()
	MarshalTo([]byte) (int, error)
	Size() int
}

type EntryValue_DoubleValue struct {
	DoubleValue float64 `protobuf:"fixed64,1,opt,name=double_value,json=doubleValue,proto3,oneof" json:"double_value,omitempty"`
}
type EntryValue_StringValue struct {
	StringValue string `protobuf:"bytes,2,opt,name=string_value,json=stringValue,proto3,oneof" json:"string_value,omitempty"`
}

func (*EntryValue_DoubleValue) isEntryValue_Kind() {}
func (*EntryValue_StringValue) isEntryValue_Kind() {}

func (m *EntryValue) GetKind() isEntryValue_Kind {
	if m != nil {
		return m.Kind
	}
	return nil
}

func (m *EntryValue) GetDoubleValue() float64 {
	if x, ok := m.GetKind().(*EntryValue_DoubleValue); ok {
		return x.DoubleValue
	}
	return 0
}

func (m *EntryValue) GetStringValue() string {
	if x, ok := m.GetKind().(*EntryValue_StringValue); ok {
		return x.StringValue
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*EntryValue) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*EntryValue_DoubleValue)(nil),
		(*EntryValue_StringValue)(nil),
	}
}

type MetricEntry struct {
	// Metric name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Metric value
	Value float64 `protobuf:"fixed64,2,opt,name=value,proto3" json:"value,omitempty"`
	// The minimum acceptable value for the metric if specified
	MinValue *types.DoubleValue `protobuf:"bytes,3,opt,name=min_value,json=minValue,proto3" json:"min_value,omitempty"`
	// The maximum acceptable value for the metric if specified
	MaxValue *types.DoubleValue `protobuf:"bytes,4,opt,name=max_value,json=maxValue,proto3" json:"max_value,omitempty"`
}

func (m *MetricEntry) Reset()         { *m = MetricEntry{} }
func (m *MetricEntry) String() string { return proto.CompactTextString(m) }
func (*MetricEntry) ProtoMessage()    {}
func (*MetricEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_cee84bc6d943a572, []int{1}
}
func (m *MetricEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetricEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetricEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricEntry.Merge(m, src)
}
func (m *MetricEntry) XXX_Size() int {
	return m.Size()
}
func (m *MetricEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricEntry.DiscardUnknown(m)
}

var xxx_messageInfo_MetricEntry proto.InternalMessageInfo

func (m *MetricEntry) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MetricEntry) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *MetricEntry) GetMinValue() *types.DoubleValue {
	if m != nil {
		return m.MinValue
	}
	return nil
}

func (m *MetricEntry) GetMaxValue() *types.DoubleValue {
	if m != nil {
		return m.MaxValue
	}
	return nil
}

// Each unit test or benchmark in a test or benchmark run provides
// some set of information.  Here we provide some reasonable keys
// one would expect to see, with optional key/value pairs for things
// we haven't considered.
//
// This BenchmarkEntry should be emitted by each unit test or benchmark
// reporter.
type BenchmarkEntry struct {
	// The name of the specific benchmark or test
	// (e.g. BM_AdjustContrast_gpu_B_W_H)
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// If a benchmark, how many iterations it was run for
	Iters int64 `protobuf:"varint,2,opt,name=iters,proto3" json:"iters,omitempty"`
	// Total cpu time used for all iterations (in seconds)
	CpuTime float64 `protobuf:"fixed64,3,opt,name=cpu_time,json=cpuTime,proto3" json:"cpu_time,omitempty"`
	// Total wall time used for all iterations (in seconds)
	WallTime float64 `protobuf:"fixed64,4,opt,name=wall_time,json=wallTime,proto3" json:"wall_time,omitempty"`
	// Throughput (in MB/s)
	Throughput float64 `protobuf:"fixed64,5,opt,name=throughput,proto3" json:"throughput,omitempty"`
	// Generic map from result key to value.
	Extras map[string]*EntryValue `protobuf:"bytes,6,rep,name=extras,proto3" json:"extras,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Metric name, value and expected range. This can include accuracy metrics
	// typically used to determine whether the accuracy test has passed
	Metrics []*MetricEntry `protobuf:"bytes,7,rep,name=metrics,proto3" json:"metrics,omitempty"`
}

func (m *BenchmarkEntry) Reset()         { *m = BenchmarkEntry{} }
func (m *BenchmarkEntry) String() string { return proto.CompactTextString(m) }
func (*BenchmarkEntry) ProtoMessage()    {}
func (*BenchmarkEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_cee84bc6d943a572, []int{2}
}
func (m *BenchmarkEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BenchmarkEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BenchmarkEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BenchmarkEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BenchmarkEntry.Merge(m, src)
}
func (m *BenchmarkEntry) XXX_Size() int {
	return m.Size()
}
func (m *BenchmarkEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_BenchmarkEntry.DiscardUnknown(m)
}

var xxx_messageInfo_BenchmarkEntry proto.InternalMessageInfo

func (m *BenchmarkEntry) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BenchmarkEntry) GetIters() int64 {
	if m != nil {
		return m.Iters
	}
	return 0
}

func (m *BenchmarkEntry) GetCpuTime() float64 {
	if m != nil {
		return m.CpuTime
	}
	return 0
}

func (m *BenchmarkEntry) GetWallTime() float64 {
	if m != nil {
		return m.WallTime
	}
	return 0
}

func (m *BenchmarkEntry) GetThroughput() float64 {
	if m != nil {
		return m.Throughput
	}
	return 0
}

func (m *BenchmarkEntry) GetExtras() map[string]*EntryValue {
	if m != nil {
		return m.Extras
	}
	return nil
}

func (m *BenchmarkEntry) GetMetrics() []*MetricEntry {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type BenchmarkEntries struct {
	Entry []*BenchmarkEntry `protobuf:"bytes,1,rep,name=entry,proto3" json:"entry,omitempty"`
}

func (m *BenchmarkEntries) Reset()         { *m = BenchmarkEntries{} }
func (m *BenchmarkEntries) String() string { return proto.CompactTextString(m) }
func (*BenchmarkEntries) ProtoMessage()    {}
func (*BenchmarkEntries) Descriptor() ([]byte, []int) {
	return fileDescriptor_cee84bc6d943a572, []int{3}
}
func (m *BenchmarkEntries) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BenchmarkEntries) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BenchmarkEntries.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BenchmarkEntries) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BenchmarkEntries.Merge(m, src)
}
func (m *BenchmarkEntries) XXX_Size() int {
	return m.Size()
}
func (m *BenchmarkEntries) XXX_DiscardUnknown() {
	xxx_messageInfo_BenchmarkEntries.DiscardUnknown(m)
}

var xxx_messageInfo_BenchmarkEntries proto.InternalMessageInfo

func (m *BenchmarkEntries) GetEntry() []*BenchmarkEntry {
	if m != nil {
		return m.Entry
	}
	return nil
}

type BuildConfiguration struct {
	Mode    string   `protobuf:"bytes,1,opt,name=mode,proto3" json:"mode,omitempty"`
	CcFlags []string `protobuf:"bytes,2,rep,name=cc_flags,json=ccFlags,proto3" json:"cc_flags,omitempty"`
	Opts    []string `protobuf:"bytes,3,rep,name=opts,proto3" json:"opts,omitempty"`
}

func (m *BuildConfiguration) Reset()         { *m = BuildConfiguration{} }
func (m *BuildConfiguration) String() string { return proto.CompactTextString(m) }
func (*BuildConfiguration) ProtoMessage()    {}
func (*BuildConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_cee84bc6d943a572, []int{4}
}
func (m *BuildConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuildConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuildConfiguration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuildConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuildConfiguration.Merge(m, src)
}
func (m *BuildConfiguration) XXX_Size() int {
	return m.Size()
}
func (m *BuildConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_BuildConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_BuildConfiguration proto.InternalMessageInfo

func (m *BuildConfiguration) GetMode() string {
	if m != nil {
		return m.Mode
	}
	return ""
}

func (m *BuildConfiguration) GetCcFlags() []string {
	if m != nil {
		return m.CcFlags
	}
	return nil
}

func (m *BuildConfiguration) GetOpts() []string {
	if m != nil {
		return m.Opts
	}
	return nil
}

type CommitId struct {
	// Types that are valid to be assigned to Kind:
	//	*CommitId_Changelist
	//	*CommitId_Hash
	Kind isCommitId_Kind `protobuf_oneof:"kind"`
	// Hash of intermediate change between hash/changelist and what was tested.
	// Not used if the build is from a commit without modifications.
	Snapshot string `protobuf:"bytes,3,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
	// Changelist tested if the change list is not already submitted.
	PendingChangelist int64 `protobuf:"varint,4,opt,name=pending_changelist,json=pendingChangelist,proto3" json:"pending_changelist,omitempty"`
}

func (m *CommitId) Reset()         { *m = CommitId{} }
func (m *CommitId) String() string { return proto.CompactTextString(m) }
func (*CommitId) ProtoMessage()    {}
func (*CommitId) Descriptor() ([]byte, []int) {
	return fileDescriptor_cee84bc6d943a572, []int{5}
}
func (m *CommitId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommitId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommitId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommitId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommitId.Merge(m, src)
}
func (m *CommitId) XXX_Size() int {
	return m.Size()
}
func (m *CommitId) XXX_DiscardUnknown() {
	xxx_messageInfo_CommitId.DiscardUnknown(m)
}

var xxx_messageInfo_CommitId proto.InternalMessageInfo

type isCommitId_Kind interface {
	isCommitId_Kind()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CommitId_Changelist struct {
	Changelist int64 `protobuf:"varint,1,opt,name=changelist,proto3,oneof" json:"changelist,omitempty"`
}
type CommitId_Hash struct {
	Hash string `protobuf:"bytes,2,opt,name=hash,proto3,oneof" json:"hash,omitempty"`
}

func (*CommitId_Changelist) isCommitId_Kind() {}
func (*CommitId_Hash) isCommitId_Kind()       {}

func (m *CommitId) GetKind() isCommitId_Kind {
	if m != nil {
		return m.Kind
	}
	return nil
}

func (m *CommitId) GetChangelist() int64 {
	if x, ok := m.GetKind().(*CommitId_Changelist); ok {
		return x.Changelist
	}
	return 0
}

func (m *CommitId) GetHash() string {
	if x, ok := m.GetKind().(*CommitId_Hash); ok {
		return x.Hash
	}
	return ""
}

func (m *CommitId) GetSnapshot() string {
	if m != nil {
		return m.Snapshot
	}
	return ""
}

func (m *CommitId) GetPendingChangelist() int64 {
	if m != nil {
		return m.PendingChangelist
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CommitId) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CommitId_Changelist)(nil),
		(*CommitId_Hash)(nil),
	}
}

type CPUInfo struct {
	NumCores        int64 `protobuf:"varint,1,opt,name=num_cores,json=numCores,proto3" json:"num_cores,omitempty"`
	NumCoresAllowed int64 `protobuf:"varint,2,opt,name=num_cores_allowed,json=numCoresAllowed,proto3" json:"num_cores_allowed,omitempty"`
	// How fast are these cpus?
	MhzPerCpu float64 `protobuf:"fixed64,3,opt,name=mhz_per_cpu,json=mhzPerCpu,proto3" json:"mhz_per_cpu,omitempty"`
	// Additional cpu information. For example,
	// Intel Ivybridge with HyperThreading (24 cores) dL1:32KB dL2:256KB dL3:30MB
	CpuInfo string `protobuf:"bytes,4,opt,name=cpu_info,json=cpuInfo,proto3" json:"cpu_info,omitempty"`
	// What kind of cpu scaling is enabled on the host.
	// Examples include "performance", "ondemand", "conservative", "mixed".
	CpuGovernor string `protobuf:"bytes,5,opt,name=cpu_governor,json=cpuGovernor,proto3" json:"cpu_governor,omitempty"`
	// Cache sizes (in bytes), e.g. "L2": 262144 (for 256KB)
	CacheSize map[string]int64 `protobuf:"bytes,6,rep,name=cache_size,json=cacheSize,proto3" json:"cache_size,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *CPUInfo) Reset()         { *m = CPUInfo{} }
func (m *CPUInfo) String() string { return proto.CompactTextString(m) }
func (*CPUInfo) ProtoMessage()    {}
func (*CPUInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_cee84bc6d943a572, []int{6}
}
func (m *CPUInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CPUInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CPUInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CPUInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CPUInfo.Merge(m, src)
}
func (m *CPUInfo) XXX_Size() int {
	return m.Size()
}
func (m *CPUInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CPUInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CPUInfo proto.InternalMessageInfo

func (m *CPUInfo) GetNumCores() int64 {
	if m != nil {
		return m.NumCores
	}
	return 0
}

func (m *CPUInfo) GetNumCoresAllowed() int64 {
	if m != nil {
		return m.NumCoresAllowed
	}
	return 0
}

func (m *CPUInfo) GetMhzPerCpu() float64 {
	if m != nil {
		return m.MhzPerCpu
	}
	return 0
}

func (m *CPUInfo) GetCpuInfo() string {
	if m != nil {
		return m.CpuInfo
	}
	return ""
}

func (m *CPUInfo) GetCpuGovernor() string {
	if m != nil {
		return m.CpuGovernor
	}
	return ""
}

func (m *CPUInfo) GetCacheSize() map[string]int64 {
	if m != nil {
		return m.CacheSize
	}
	return nil
}

type MemoryInfo struct {
	Total     int64 `protobuf:"varint,1,opt,name=total,proto3" json:"total,omitempty"`
	Available int64 `protobuf:"varint,2,opt,name=available,proto3" json:"available,omitempty"`
}

func (m *MemoryInfo) Reset()         { *m = MemoryInfo{} }
func (m *MemoryInfo) String() string { return proto.CompactTextString(m) }
func (*MemoryInfo) ProtoMessage()    {}
func (*MemoryInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_cee84bc6d943a572, []int{7}
}
func (m *MemoryInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoryInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoryInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoryInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoryInfo.Merge(m, src)
}
func (m *MemoryInfo) XXX_Size() int {
	return m.Size()
}
func (m *MemoryInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoryInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MemoryInfo proto.InternalMessageInfo

func (m *MemoryInfo) GetTotal() int64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *MemoryInfo) GetAvailable() int64 {
	if m != nil {
		return m.Available
	}
	return 0
}

type GPUInfo struct {
	Model string `protobuf:"bytes,1,opt,name=model,proto3" json:"model,omitempty"`
	Uuid  string `protobuf:"bytes,2,opt,name=uuid,proto3" json:"uuid,omitempty"`
	BusId string `protobuf:"bytes,3,opt,name=bus_id,json=busId,proto3" json:"bus_id,omitempty"`
}

func (m *GPUInfo) Reset()         { *m = GPUInfo{} }
func (m *GPUInfo) String() string { return proto.CompactTextString(m) }
func (*GPUInfo) ProtoMessage()    {}
func (*GPUInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_cee84bc6d943a572, []int{8}
}
func (m *GPUInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GPUInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GPUInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GPUInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GPUInfo.Merge(m, src)
}
func (m *GPUInfo) XXX_Size() int {
	return m.Size()
}
func (m *GPUInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GPUInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GPUInfo proto.InternalMessageInfo

func (m *GPUInfo) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

func (m *GPUInfo) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *GPUInfo) GetBusId() string {
	if m != nil {
		return m.BusId
	}
	return ""
}

type PlatformInfo struct {
	Bits    string `protobuf:"bytes,1,opt,name=bits,proto3" json:"bits,omitempty"`
	Linkage string `protobuf:"bytes,2,opt,name=linkage,proto3" json:"linkage,omitempty"`
	Machine string `protobuf:"bytes,3,opt,name=machine,proto3" json:"machine,omitempty"`
	Release string `protobuf:"bytes,4,opt,name=release,proto3" json:"release,omitempty"`
	System  string `protobuf:"bytes,5,opt,name=system,proto3" json:"system,omitempty"`
	Version string `protobuf:"bytes,6,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *PlatformInfo) Reset()         { *m = PlatformInfo{} }
func (m *PlatformInfo) String() string { return proto.CompactTextString(m) }
func (*PlatformInfo) ProtoMessage()    {}
func (*PlatformInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_cee84bc6d943a572, []int{9}
}
func (m *PlatformInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlatformInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlatformInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlatformInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlatformInfo.Merge(m, src)
}
func (m *PlatformInfo) XXX_Size() int {
	return m.Size()
}
func (m *PlatformInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PlatformInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PlatformInfo proto.InternalMessageInfo

func (m *PlatformInfo) GetBits() string {
	if m != nil {
		return m.Bits
	}
	return ""
}

func (m *PlatformInfo) GetLinkage() string {
	if m != nil {
		return m.Linkage
	}
	return ""
}

func (m *PlatformInfo) GetMachine() string {
	if m != nil {
		return m.Machine
	}
	return ""
}

func (m *PlatformInfo) GetRelease() string {
	if m != nil {
		return m.Release
	}
	return ""
}

func (m *PlatformInfo) GetSystem() string {
	if m != nil {
		return m.System
	}
	return ""
}

func (m *PlatformInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type AvailableDeviceInfo struct {
	Name                string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Type                string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	MemoryLimit         int64  `protobuf:"varint,3,opt,name=memory_limit,json=memoryLimit,proto3" json:"memory_limit,omitempty"`
	PhysicalDescription string `protobuf:"bytes,4,opt,name=physical_description,json=physicalDescription,proto3" json:"physical_description,omitempty"`
}

func (m *AvailableDeviceInfo) Reset()         { *m = AvailableDeviceInfo{} }
func (m *AvailableDeviceInfo) String() string { return proto.CompactTextString(m) }
func (*AvailableDeviceInfo) ProtoMessage()    {}
func (*AvailableDeviceInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_cee84bc6d943a572, []int{10}
}
func (m *AvailableDeviceInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AvailableDeviceInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AvailableDeviceInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AvailableDeviceInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AvailableDeviceInfo.Merge(m, src)
}
func (m *AvailableDeviceInfo) XXX_Size() int {
	return m.Size()
}
func (m *AvailableDeviceInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AvailableDeviceInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AvailableDeviceInfo proto.InternalMessageInfo

func (m *AvailableDeviceInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AvailableDeviceInfo) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AvailableDeviceInfo) GetMemoryLimit() int64 {
	if m != nil {
		return m.MemoryLimit
	}
	return 0
}

func (m *AvailableDeviceInfo) GetPhysicalDescription() string {
	if m != nil {
		return m.PhysicalDescription
	}
	return ""
}

type MachineConfiguration struct {
	// Host name of machine that ran the benchmark.
	Hostname string `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// Unique serial number of the machine.
	SerialIdentifier string `protobuf:"bytes,7,opt,name=serial_identifier,json=serialIdentifier,proto3" json:"serial_identifier,omitempty"`
	// Additional platform information.
	PlatformInfo *PlatformInfo `protobuf:"bytes,2,opt,name=platform_info,json=platformInfo,proto3" json:"platform_info,omitempty"`
	// CPU Information.
	CpuInfo *CPUInfo `protobuf:"bytes,3,opt,name=cpu_info,json=cpuInfo,proto3" json:"cpu_info,omitempty"`
	// Other devices that are attached and relevant (e.g. GPUInfo).
	DeviceInfo []*types.Any `protobuf:"bytes,4,rep,name=device_info,json=deviceInfo,proto3" json:"device_info,omitempty"`
	// Devices accessible to the test (e.g. as given by list_local_devices).
	AvailableDeviceInfo []*AvailableDeviceInfo `protobuf:"bytes,5,rep,name=available_device_info,json=availableDeviceInfo,proto3" json:"available_device_info,omitempty"`
	MemoryInfo          *MemoryInfo            `protobuf:"bytes,6,opt,name=memory_info,json=memoryInfo,proto3" json:"memory_info,omitempty"`
}

func (m *MachineConfiguration) Reset()         { *m = MachineConfiguration{} }
func (m *MachineConfiguration) String() string { return proto.CompactTextString(m) }
func (*MachineConfiguration) ProtoMessage()    {}
func (*MachineConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_cee84bc6d943a572, []int{11}
}
func (m *MachineConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MachineConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MachineConfiguration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MachineConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MachineConfiguration.Merge(m, src)
}
func (m *MachineConfiguration) XXX_Size() int {
	return m.Size()
}
func (m *MachineConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_MachineConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_MachineConfiguration proto.InternalMessageInfo

func (m *MachineConfiguration) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *MachineConfiguration) GetSerialIdentifier() string {
	if m != nil {
		return m.SerialIdentifier
	}
	return ""
}

func (m *MachineConfiguration) GetPlatformInfo() *PlatformInfo {
	if m != nil {
		return m.PlatformInfo
	}
	return nil
}

func (m *MachineConfiguration) GetCpuInfo() *CPUInfo {
	if m != nil {
		return m.CpuInfo
	}
	return nil
}

func (m *MachineConfiguration) GetDeviceInfo() []*types.Any {
	if m != nil {
		return m.DeviceInfo
	}
	return nil
}

func (m *MachineConfiguration) GetAvailableDeviceInfo() []*AvailableDeviceInfo {
	if m != nil {
		return m.AvailableDeviceInfo
	}
	return nil
}

func (m *MachineConfiguration) GetMemoryInfo() *MemoryInfo {
	if m != nil {
		return m.MemoryInfo
	}
	return nil
}

// Run-specific items such as arguments to the test / benchmark.
type RunConfiguration struct {
	Argument []string `protobuf:"bytes,1,rep,name=argument,proto3" json:"argument,omitempty"`
	// Environment variables used to run the test/benchmark.
	EnvVars map[string]string `protobuf:"bytes,2,rep,name=env_vars,json=envVars,proto3" json:"env_vars,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *RunConfiguration) Reset()         { *m = RunConfiguration{} }
func (m *RunConfiguration) String() string { return proto.CompactTextString(m) }
func (*RunConfiguration) ProtoMessage()    {}
func (*RunConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_cee84bc6d943a572, []int{12}
}
func (m *RunConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RunConfiguration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RunConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunConfiguration.Merge(m, src)
}
func (m *RunConfiguration) XXX_Size() int {
	return m.Size()
}
func (m *RunConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_RunConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_RunConfiguration proto.InternalMessageInfo

func (m *RunConfiguration) GetArgument() []string {
	if m != nil {
		return m.Argument
	}
	return nil
}

func (m *RunConfiguration) GetEnvVars() map[string]string {
	if m != nil {
		return m.EnvVars
	}
	return nil
}

// The output of one benchmark / test run.  Each run contains a list of
// tests or benchmarks, stored as BenchmarkEntry messages.
//
// This message should be emitted by the reporter (which runs the
// test / BM in a subprocess and then reads the emitted BenchmarkEntry messages;
// usually from a serialized json file, finally collecting them along
// with additional information about the test run.
type TestResults struct {
	// The target of the run, e.g.:
	//  //tensorflow/core:kernels_adjust_contrast_op_benchmark_test
	Target string `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	// The list of tests or benchmarks in this run.
	Entries *BenchmarkEntries `protobuf:"bytes,2,opt,name=entries,proto3" json:"entries,omitempty"`
	// The configuration of the build (compiled opt? with cuda? any copts?)
	BuildConfiguration *BuildConfiguration `protobuf:"bytes,3,opt,name=build_configuration,json=buildConfiguration,proto3" json:"build_configuration,omitempty"`
	// The commit id (git hash or changelist)
	CommitId *CommitId `protobuf:"bytes,4,opt,name=commit_id,json=commitId,proto3" json:"commit_id,omitempty"`
	// The time the run started (in seconds of UTC time since Unix epoch)
	StartTime int64 `protobuf:"varint,5,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// The amount of time the total run took (wall time in seconds)
	RunTime float64 `protobuf:"fixed64,6,opt,name=run_time,json=runTime,proto3" json:"run_time,omitempty"`
	// Machine-specific parameters (Platform and CPU info)
	MachineConfiguration *MachineConfiguration `protobuf:"bytes,7,opt,name=machine_configuration,json=machineConfiguration,proto3" json:"machine_configuration,omitempty"`
	// Run-specific parameters (arguments, etc)
	RunConfiguration *RunConfiguration `protobuf:"bytes,8,opt,name=run_configuration,json=runConfiguration,proto3" json:"run_configuration,omitempty"`
	// Benchmark target identifier.
	Name          string                    `protobuf:"bytes,9,opt,name=name,proto3" json:"name,omitempty"`
	BenchmarkType TestResults_BenchmarkType `protobuf:"varint,10,opt,name=benchmark_type,json=benchmarkType,proto3,enum=tensorflow.TestResults_BenchmarkType" json:"benchmark_type,omitempty"`
	// Used for differentiating between continuous and debug builds.
	// Must be one of:
	// * cbuild: results from continuous build.
	// * presubmit: results from oneshot requests.
	// * culprit: results from culprit finder rerun.
	RunMode string `protobuf:"bytes,11,opt,name=run_mode,json=runMode,proto3" json:"run_mode,omitempty"`
	// TensorFlow version this benchmark runs against.
	// This can be either set to full version or just the major version.
	TfVersion string `protobuf:"bytes,12,opt,name=tf_version,json=tfVersion,proto3" json:"tf_version,omitempty"`
}

func (m *TestResults) Reset()         { *m = TestResults{} }
func (m *TestResults) String() string { return proto.CompactTextString(m) }
func (*TestResults) ProtoMessage()    {}
func (*TestResults) Descriptor() ([]byte, []int) {
	return fileDescriptor_cee84bc6d943a572, []int{13}
}
func (m *TestResults) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestResults) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestResults.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestResults) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestResults.Merge(m, src)
}
func (m *TestResults) XXX_Size() int {
	return m.Size()
}
func (m *TestResults) XXX_DiscardUnknown() {
	xxx_messageInfo_TestResults.DiscardUnknown(m)
}

var xxx_messageInfo_TestResults proto.InternalMessageInfo

func (m *TestResults) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *TestResults) GetEntries() *BenchmarkEntries {
	if m != nil {
		return m.Entries
	}
	return nil
}

func (m *TestResults) GetBuildConfiguration() *BuildConfiguration {
	if m != nil {
		return m.BuildConfiguration
	}
	return nil
}

func (m *TestResults) GetCommitId() *CommitId {
	if m != nil {
		return m.CommitId
	}
	return nil
}

func (m *TestResults) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *TestResults) GetRunTime() float64 {
	if m != nil {
		return m.RunTime
	}
	return 0
}

func (m *TestResults) GetMachineConfiguration() *MachineConfiguration {
	if m != nil {
		return m.MachineConfiguration
	}
	return nil
}

func (m *TestResults) GetRunConfiguration() *RunConfiguration {
	if m != nil {
		return m.RunConfiguration
	}
	return nil
}

func (m *TestResults) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TestResults) GetBenchmarkType() TestResults_BenchmarkType {
	if m != nil {
		return m.BenchmarkType
	}
	return TestResults_UNKNOWN
}

func (m *TestResults) GetRunMode() string {
	if m != nil {
		return m.RunMode
	}
	return ""
}

func (m *TestResults) GetTfVersion() string {
	if m != nil {
		return m.TfVersion
	}
	return ""
}

func init() {
	proto.RegisterEnum("tensorflow.TestResults_BenchmarkType", TestResults_BenchmarkType_name, TestResults_BenchmarkType_value)
	proto.RegisterType((*EntryValue)(nil), "tensorflow.EntryValue")
	proto.RegisterType((*MetricEntry)(nil), "tensorflow.MetricEntry")
	proto.RegisterType((*BenchmarkEntry)(nil), "tensorflow.BenchmarkEntry")
	proto.RegisterMapType((map[string]*EntryValue)(nil), "tensorflow.BenchmarkEntry.ExtrasEntry")
	proto.RegisterType((*BenchmarkEntries)(nil), "tensorflow.BenchmarkEntries")
	proto.RegisterType((*BuildConfiguration)(nil), "tensorflow.BuildConfiguration")
	proto.RegisterType((*CommitId)(nil), "tensorflow.CommitId")
	proto.RegisterType((*CPUInfo)(nil), "tensorflow.CPUInfo")
	proto.RegisterMapType((map[string]int64)(nil), "tensorflow.CPUInfo.CacheSizeEntry")
	proto.RegisterType((*MemoryInfo)(nil), "tensorflow.MemoryInfo")
	proto.RegisterType((*GPUInfo)(nil), "tensorflow.GPUInfo")
	proto.RegisterType((*PlatformInfo)(nil), "tensorflow.PlatformInfo")
	proto.RegisterType((*AvailableDeviceInfo)(nil), "tensorflow.AvailableDeviceInfo")
	proto.RegisterType((*MachineConfiguration)(nil), "tensorflow.MachineConfiguration")
	proto.RegisterType((*RunConfiguration)(nil), "tensorflow.RunConfiguration")
	proto.RegisterMapType((map[string]string)(nil), "tensorflow.RunConfiguration.EnvVarsEntry")
	proto.RegisterType((*TestResults)(nil), "tensorflow.TestResults")
}

func init() {
	proto.RegisterFile("tensorflow/core/util/test_log.proto", fileDescriptor_cee84bc6d943a572)
}

var fileDescriptor_cee84bc6d943a572 = []byte{
	// 1499 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x57, 0x5b, 0x73, 0x1b, 0x49,
	0x15, 0xf6, 0x58, 0xd7, 0x39, 0x72, 0x8c, 0xdc, 0x56, 0x82, 0xa2, 0xcd, 0x0a, 0xa3, 0x2d, 0x28,
	0x73, 0x59, 0x89, 0x98, 0xe2, 0xb6, 0xc5, 0x52, 0xd8, 0x92, 0x49, 0xcc, 0xc6, 0xb6, 0xe8, 0x4d,
	0xb2, 0x05, 0x0f, 0x4c, 0xb5, 0x46, 0xad, 0x51, 0x97, 0xe7, 0x56, 0xdd, 0x3d, 0x72, 0xe4, 0x5f,
	0xc0, 0x23, 0x55, 0x5b, 0xfc, 0x01, 0xde, 0xa9, 0x82, 0x7f, 0xc1, 0x63, 0x1e, 0xf7, 0x91, 0x4a,
	0xfe, 0x04, 0x8f, 0x54, 0x5f, 0x46, 0x1a, 0xd9, 0x5e, 0xe0, 0xad, 0xcf, 0xa5, 0x4f, 0x9f, 0xee,
	0xef, 0x3b, 0xe7, 0xcc, 0xc0, 0x47, 0x92, 0xc6, 0x22, 0xe1, 0xb3, 0x30, 0xb9, 0x1e, 0xf8, 0x09,
	0xa7, 0x83, 0x4c, 0xb2, 0x70, 0x20, 0xa9, 0x90, 0x5e, 0x98, 0x04, 0xfd, 0x94, 0x27, 0x32, 0x41,
	0xb0, 0x76, 0xea, 0x3c, 0x0e, 0x92, 0x24, 0x08, 0xe9, 0x40, 0x5b, 0x26, 0xd9, 0x6c, 0x40, 0xe2,
	0xa5, 0x71, 0xeb, 0x74, 0x6f, 0x9b, 0xae, 0x39, 0x49, 0x53, 0xca, 0x85, 0xb1, 0xf7, 0xfe, 0x08,
	0x70, 0x1a, 0x4b, 0xbe, 0x7c, 0x4d, 0xc2, 0x8c, 0xa2, 0x8f, 0x60, 0x67, 0x9a, 0x64, 0x93, 0x90,
	0x7a, 0x0b, 0x25, 0xb7, 0x9d, 0x03, 0xe7, 0xd0, 0x79, 0xbe, 0x85, 0x1b, 0x46, 0xbb, 0x72, 0x12,
	0x92, 0xb3, 0x38, 0xb0, 0x4e, 0xdb, 0x07, 0xce, 0xa1, 0xab, 0x9c, 0x8c, 0x56, 0x3b, 0x9d, 0x54,
	0xa1, 0x7c, 0xc5, 0xe2, 0x69, 0xef, 0x6f, 0x0e, 0x34, 0xce, 0xa9, 0xe4, 0xcc, 0xd7, 0xc7, 0x20,
	0x04, 0xe5, 0x98, 0x44, 0x26, 0xb2, 0x8b, 0xf5, 0x1a, 0xb5, 0xa0, 0xb2, 0x8e, 0xe4, 0x60, 0x23,
	0xa0, 0x5f, 0x80, 0x1b, 0xb1, 0xd8, 0x9e, 0x51, 0x3a, 0x70, 0x0e, 0x1b, 0x47, 0x4f, 0xfa, 0xe6,
	0x36, 0xfd, 0xfc, 0x36, 0xfd, 0xd1, 0x3a, 0x2f, 0x5c, 0x8f, 0x58, 0xfc, 0x7a, 0xb5, 0x95, 0xbc,
	0xb1, 0x5b, 0xcb, 0xff, 0xd7, 0x56, 0xf2, 0x46, 0xaf, 0x7a, 0x5f, 0x6d, 0xc3, 0xee, 0x09, 0x8d,
	0xfd, 0x79, 0x44, 0xf8, 0xd5, 0x7f, 0x4d, 0x99, 0x49, 0xca, 0x85, 0x4e, 0xb9, 0x84, 0x8d, 0x80,
	0x1e, 0x43, 0xdd, 0x4f, 0x33, 0x4f, 0xb2, 0xc8, 0x64, 0xec, 0xe0, 0x9a, 0x9f, 0x66, 0x2f, 0x59,
	0x44, 0xd1, 0x07, 0xe0, 0x5e, 0x93, 0x30, 0x34, 0xb6, 0xb2, 0xb6, 0xd5, 0x95, 0x42, 0x1b, 0xbb,
	0x00, 0x72, 0xce, 0x93, 0x2c, 0x98, 0xa7, 0x99, 0x6c, 0x57, 0xb4, 0xb5, 0xa0, 0x41, 0xbf, 0x82,
	0x2a, 0x7d, 0x23, 0x39, 0x11, 0xed, 0xea, 0x41, 0xe9, 0xb0, 0x71, 0xf4, 0xdd, 0xfe, 0x1a, 0xfc,
	0xfe, 0x66, 0xb6, 0xfd, 0x53, 0xed, 0xa8, 0xd7, 0xd8, 0xee, 0x42, 0x4f, 0xa1, 0x16, 0x69, 0x0c,
	0x44, 0xbb, 0xa6, 0x03, 0x7c, 0xb3, 0x18, 0xa0, 0x00, 0x0f, 0xce, 0xfd, 0x3a, 0xbf, 0x83, 0x46,
	0x21, 0x12, 0x6a, 0x42, 0xe9, 0x8a, 0x2e, 0xed, 0x13, 0xa8, 0x25, 0xfa, 0x61, 0x11, 0xb4, 0xc6,
	0xd1, 0xa3, 0x62, 0xc4, 0x35, 0xa3, 0x2c, 0x98, 0x9f, 0x6c, 0xff, 0xdc, 0xe9, 0x8d, 0xa0, 0xb9,
	0x91, 0x2b, 0xa3, 0x02, 0xfd, 0x08, 0x2a, 0x54, 0x39, 0xb7, 0x1d, 0x9d, 0x57, 0xe7, 0xeb, 0x2f,
	0x86, 0x8d, 0x63, 0xef, 0x0b, 0x40, 0x27, 0x19, 0x0b, 0xa7, 0xc3, 0x24, 0x9e, 0xb1, 0x20, 0xe3,
	0x44, 0xb2, 0x24, 0x56, 0x18, 0x45, 0xc9, 0x74, 0x85, 0x91, 0x5a, 0x6b, 0x34, 0x7c, 0x6f, 0x16,
	0x92, 0x40, 0xc1, 0x54, 0x3a, 0x74, 0x71, 0xcd, 0xf7, 0x7f, 0xa3, 0x44, 0xe5, 0x9e, 0xa4, 0x52,
	0xb4, 0x4b, 0x5a, 0xad, 0xd7, 0xbd, 0xbf, 0x38, 0x50, 0x1f, 0x26, 0x51, 0xc4, 0xe4, 0xd9, 0x14,
	0x1d, 0x00, 0xf8, 0x73, 0x12, 0x07, 0x34, 0x64, 0x42, 0xea, 0xa8, 0xa5, 0xe7, 0x5b, 0xb8, 0xa0,
	0x43, 0x2d, 0x28, 0xcf, 0x89, 0x98, 0xaf, 0xd8, 0xaf, 0x25, 0xd4, 0x81, 0xba, 0x88, 0x49, 0x2a,
	0xe6, 0x89, 0xd4, 0x0c, 0x70, 0xf1, 0x4a, 0x46, 0x1f, 0x03, 0x4a, 0x69, 0x3c, 0x55, 0x85, 0x53,
	0x88, 0x5d, 0xd6, 0x04, 0xda, 0xb3, 0x96, 0xe1, 0xca, 0xb0, 0xaa, 0xa0, 0x7f, 0x6c, 0x43, 0x6d,
	0x38, 0x7e, 0x75, 0x16, 0xcf, 0x12, 0xc5, 0xa2, 0x38, 0x8b, 0x3c, 0xd5, 0x14, 0x84, 0xc9, 0x0a,
	0xd7, 0xe3, 0x2c, 0x1a, 0x2a, 0x19, 0x7d, 0x1f, 0xf6, 0x56, 0x46, 0x8f, 0x84, 0x61, 0x72, 0x4d,
	0xa7, 0x96, 0x9f, 0xdf, 0xc8, 0x9d, 0x8e, 0x8d, 0x1a, 0x75, 0xa1, 0x11, 0xcd, 0x6f, 0xbc, 0x94,
	0x72, 0xcf, 0x4f, 0x33, 0x4b, 0x56, 0x37, 0x9a, 0xdf, 0x8c, 0x29, 0x1f, 0xa6, 0x59, 0xce, 0x64,
	0x16, 0xcf, 0x12, 0x9d, 0xa1, 0xab, 0x99, 0xac, 0x73, 0xf8, 0x36, 0xec, 0x28, 0x53, 0x90, 0x2c,
	0x28, 0x8f, 0x13, 0xae, 0xe9, 0xea, 0xe2, 0x86, 0x9f, 0x66, 0xcf, 0xac, 0x0a, 0x1d, 0x03, 0xf8,
	0xc4, 0x9f, 0x53, 0x4f, 0xb0, 0x1b, 0x6a, 0x39, 0xdb, 0x2b, 0x42, 0x6b, 0xef, 0xd3, 0x1f, 0x2a,
	0xaf, 0xcf, 0xd9, 0x0d, 0x35, 0x10, 0xbb, 0x7e, 0x2e, 0x77, 0x7e, 0x09, 0xbb, 0x9b, 0xc6, 0x7b,
	0x28, 0xb8, 0xd1, 0x37, 0x4a, 0x45, 0xaa, 0xfd, 0x1a, 0xe0, 0x9c, 0x46, 0x09, 0x5f, 0xea, 0x8c,
	0x5b, 0x50, 0x91, 0x89, 0x24, 0xa1, 0x7d, 0x31, 0x23, 0xa0, 0x27, 0xe0, 0x92, 0x05, 0x61, 0x21,
	0x99, 0x84, 0x79, 0x84, 0xb5, 0xa2, 0xf7, 0x5b, 0xa8, 0x3d, 0xb3, 0x8f, 0xde, 0x82, 0x8a, 0xe2,
	0x53, 0x68, 0x8f, 0x36, 0x82, 0xa2, 0x50, 0x96, 0x31, 0xf3, 0xc0, 0x2e, 0xd6, 0x6b, 0xf4, 0x10,
	0xaa, 0x93, 0x4c, 0x78, 0x6c, 0x6a, 0xb1, 0xaf, 0x4c, 0x32, 0x71, 0x36, 0xed, 0xfd, 0xd5, 0x81,
	0x9d, 0x71, 0x48, 0xe4, 0x2c, 0xe1, 0x91, 0x8e, 0x88, 0xa0, 0x3c, 0x61, 0x52, 0xe4, 0x6c, 0x55,
	0x6b, 0xd4, 0x86, 0x5a, 0xc8, 0xe2, 0x2b, 0x12, 0xd8, 0x86, 0x8a, 0x73, 0x51, 0x59, 0x22, 0xe2,
	0xcf, 0x59, 0x4c, 0x6d, 0xd8, 0x5c, 0x54, 0x16, 0x4e, 0x43, 0x4a, 0x04, 0xcd, 0x41, 0xb2, 0x22,
	0x7a, 0x04, 0x55, 0xb1, 0x14, 0x92, 0x46, 0x16, 0x1e, 0x2b, 0xa9, 0x1d, 0x0b, 0xca, 0x05, 0x4b,
	0xe2, 0x76, 0xd5, 0xec, 0xb0, 0x62, 0xef, 0x4b, 0x07, 0xf6, 0x8f, 0xf3, 0xeb, 0x8f, 0xe8, 0x82,
	0xf9, 0x34, 0xcf, 0xf5, 0x4e, 0xf7, 0x43, 0x50, 0x96, 0xcb, 0x34, 0x4f, 0x54, 0xaf, 0x15, 0x2d,
	0x22, 0xfd, 0xe4, 0x5e, 0xc8, 0x22, 0x66, 0xd8, 0x5f, 0xc2, 0x0d, 0xa3, 0x7b, 0xa1, 0x54, 0xe8,
	0x29, 0xb4, 0xd2, 0xf9, 0x52, 0x30, 0x9f, 0x84, 0xde, 0x94, 0x0a, 0x9f, 0xb3, 0x54, 0x15, 0xaf,
	0xcd, 0x7d, 0x3f, 0xb7, 0x8d, 0xd6, 0xa6, 0xde, 0x97, 0x25, 0x68, 0x9d, 0x9b, 0xdb, 0x6e, 0x16,
	0x7c, 0x07, 0xea, 0xf3, 0x44, 0xc8, 0x42, 0x6a, 0x2b, 0x19, 0xfd, 0x00, 0xf6, 0x04, 0xe5, 0x8c,
	0x84, 0x1e, 0x9b, 0xd2, 0x58, 0xb2, 0x19, 0xa3, 0xbc, 0x5d, 0xd3, 0x4e, 0x4d, 0x63, 0x38, 0x5b,
	0xe9, 0xd1, 0xa7, 0xf0, 0x20, 0xb5, 0xd8, 0x18, 0xba, 0x9b, 0x7e, 0xd6, 0x2e, 0xd2, 0xb5, 0x08,
	0x1e, 0xde, 0x49, 0x8b, 0x50, 0xf6, 0x0b, 0x85, 0x62, 0x86, 0xd4, 0xfe, 0x3d, 0x44, 0x5f, 0x57,
	0xcf, 0x4f, 0xa0, 0x31, 0xd5, 0x8f, 0x9b, 0xd7, 0x96, 0xaa, 0x8d, 0xd6, 0x9d, 0xe1, 0x74, 0x1c,
	0x2f, 0x31, 0x4c, 0xd7, 0x28, 0x7c, 0x0e, 0x0f, 0x57, 0xdc, 0xf4, 0x8a, 0x01, 0x2a, 0x3a, 0xc0,
	0xb7, 0x8a, 0x67, 0xde, 0x83, 0x22, 0xde, 0x27, 0xf7, 0x40, 0xfb, 0x33, 0xb0, 0xf0, 0x98, 0x50,
	0xd5, 0xbb, 0x8d, 0x7c, 0x5d, 0x44, 0x18, 0xa2, 0xd5, 0xba, 0xf7, 0x77, 0x07, 0x9a, 0x38, 0x8b,
	0xef, 0x20, 0x42, 0x78, 0x90, 0x45, 0x34, 0x96, 0xba, 0x9b, 0xbb, 0x78, 0x25, 0xa3, 0x11, 0xd4,
	0x69, 0xbc, 0xf0, 0x16, 0x84, 0x9b, 0x56, 0xdc, 0x38, 0xfa, 0x5e, 0xf1, 0x98, 0xdb, 0xb1, 0xfa,
	0xa7, 0xf1, 0xe2, 0x35, 0xe1, 0x76, 0x8a, 0xd5, 0xa8, 0x91, 0x3a, 0x9f, 0xc0, 0x4e, 0xd1, 0xf0,
	0xbf, 0x3a, 0x82, 0x5b, 0xec, 0x08, 0x6f, 0x2b, 0xd0, 0x78, 0x49, 0x85, 0xc4, 0x54, 0x64, 0xa1,
	0x14, 0xaa, 0x40, 0x24, 0xe1, 0x01, 0x95, 0x76, 0xbb, 0x95, 0xd0, 0x4f, 0xa1, 0x46, 0xcd, 0x6c,
	0xb2, 0x44, 0x78, 0xf2, 0xb5, 0x23, 0x89, 0x51, 0x81, 0x73, 0x67, 0x74, 0x09, 0xfb, 0x13, 0x35,
	0x96, 0x3c, 0xbf, 0x78, 0x11, 0x4b, 0x89, 0xee, 0x46, 0x8c, 0x3b, 0xd3, 0x0b, 0xa3, 0xc9, 0xdd,
	0x89, 0xf6, 0x14, 0x5c, 0x5f, 0x4f, 0x23, 0xd5, 0x4e, 0xcc, 0x37, 0x4c, 0x6b, 0x83, 0x59, 0x76,
	0x54, 0xe1, 0xba, 0x9f, 0x0f, 0xad, 0x0f, 0x01, 0x84, 0x24, 0x5c, 0x9a, 0x8f, 0x8c, 0x8a, 0x69,
	0x69, 0x5a, 0xa3, 0xbf, 0x32, 0x1e, 0x43, 0x9d, 0x67, 0xb1, 0x31, 0x56, 0xcd, 0xd7, 0x09, 0xcf,
	0x62, 0x6d, 0x7a, 0x05, 0x0f, 0x6d, 0x4f, 0xb9, 0x95, 0x7f, 0x4d, 0x1f, 0x7c, 0xb0, 0xc1, 0x89,
	0x7b, 0xca, 0x11, 0xb7, 0xa2, 0xfb, 0x8a, 0xf4, 0x0c, 0xf6, 0xd4, 0x89, 0x9b, 0x21, 0xeb, 0x77,
	0x9f, 0xf5, 0x36, 0xfe, 0xb8, 0xc9, 0x6f, 0xb3, 0x2b, 0x6f, 0x43, 0x6e, 0xa1, 0x0d, 0xbd, 0x80,
	0xdd, 0x49, 0x0e, 0x88, 0xa7, 0x1b, 0x12, 0x1c, 0x38, 0x87, 0xbb, 0x47, 0xdf, 0x29, 0xc6, 0x2e,
	0x80, 0xbe, 0x86, 0xef, 0xe5, 0x32, 0xa5, 0xf8, 0xc1, 0xa4, 0x28, 0xe6, 0xcf, 0xa3, 0x3f, 0x23,
	0x1a, 0xb6, 0x9b, 0x66, 0xf1, 0xb9, 0xfa, 0x92, 0xf8, 0x10, 0x40, 0xce, 0xbc, 0xbc, 0x71, 0xee,
	0x68, 0xa3, 0x2b, 0x67, 0xaf, 0x6d, 0xeb, 0xcc, 0xe0, 0xc1, 0x46, 0x64, 0xd4, 0x80, 0xda, 0xab,
	0x8b, 0xcf, 0x2e, 0x2e, 0xbf, 0xb8, 0x68, 0x6e, 0xa1, 0x47, 0x80, 0x86, 0xe3, 0xb1, 0x77, 0x7e,
	0x36, 0xc4, 0x97, 0x27, 0xa7, 0x17, 0xc3, 0xe7, 0xe7, 0xc7, 0xf8, 0xb3, 0xa6, 0x83, 0x5a, 0xd0,
	0x1c, 0xff, 0xfe, 0xe5, 0xf3, 0xcb, 0x0b, 0x6f, 0xad, 0xdd, 0x46, 0x0f, 0x61, 0xef, 0xf8, 0x62,
	0x84, 0x2f, 0xcf, 0x46, 0x05, 0x75, 0x09, 0x21, 0xd8, 0x3d, 0x1d, 0x3d, 0x3b, 0x2d, 0xe8, 0xca,
	0x27, 0x7f, 0x72, 0xfe, 0xf9, 0xae, 0xeb, 0xbc, 0x7d, 0xd7, 0x75, 0xfe, 0xf5, 0xae, 0xeb, 0xfc,
	0xf9, 0x7d, 0x77, 0xeb, 0xed, 0xfb, 0xee, 0xd6, 0x57, 0xef, 0xbb, 0x5b, 0xf0, 0x41, 0xc2, 0x83,
	0xe2, 0x23, 0xa8, 0x1f, 0x88, 0xbe, 0xfa, 0x81, 0x08, 0x93, 0xe0, 0xe4, 0x81, 0x7a, 0x92, 0x17,
	0x49, 0x30, 0x56, 0xcd, 0x46, 0x8c, 0x9d, 0x3f, 0x7c, 0x1a, 0x30, 0x39, 0xcf, 0x26, 0x7d, 0x3f,
	0x89, 0x06, 0xc7, 0x69, 0x1a, 0xea, 0xc6, 0x38, 0x08, 0x92, 0x8f, 0x0b, 0xff, 0x21, 0xea, 0x79,
	0xc5, 0xe0, 0xbe, 0x1f, 0x93, 0x7f, 0x3b, 0xce, 0xa4, 0xaa, 0x1b, 0xd7, 0x8f, 0xff, 0x13, 0x00,
	0x00, 0xff, 0xff, 0x1b, 0x97, 0x2c, 0xfe, 0xba, 0x0c, 0x00, 0x00,
}

func (m *EntryValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntryValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EntryValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Kind != nil {
		{
			size := m.Kind.Size()
			i -= size
			if _, err := m.Kind.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *EntryValue_DoubleValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EntryValue_DoubleValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DoubleValue))))
	i--
	dAtA[i] = 0x9
	return len(dAtA) - i, nil
}
func (m *EntryValue_StringValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EntryValue_StringValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.StringValue)
	copy(dAtA[i:], m.StringValue)
	i = encodeVarintTestLog(dAtA, i, uint64(len(m.StringValue)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *MetricEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxValue != nil {
		{
			size, err := m.MaxValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.MinValue != nil {
		{
			size, err := m.MinValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Value != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Value))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BenchmarkEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BenchmarkEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BenchmarkEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metrics) > 0 {
		for iNdEx := len(m.Metrics) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Metrics[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTestLog(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Extras) > 0 {
		for k := range m.Extras {
			v := m.Extras[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTestLog(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTestLog(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTestLog(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Throughput != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Throughput))))
		i--
		dAtA[i] = 0x29
	}
	if m.WallTime != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.WallTime))))
		i--
		dAtA[i] = 0x21
	}
	if m.CpuTime != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuTime))))
		i--
		dAtA[i] = 0x19
	}
	if m.Iters != 0 {
		i = encodeVarintTestLog(dAtA, i, uint64(m.Iters))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BenchmarkEntries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BenchmarkEntries) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BenchmarkEntries) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entry) > 0 {
		for iNdEx := len(m.Entry) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entry[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTestLog(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BuildConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildConfiguration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuildConfiguration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Opts) > 0 {
		for iNdEx := len(m.Opts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Opts[iNdEx])
			copy(dAtA[i:], m.Opts[iNdEx])
			i = encodeVarintTestLog(dAtA, i, uint64(len(m.Opts[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.CcFlags) > 0 {
		for iNdEx := len(m.CcFlags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CcFlags[iNdEx])
			copy(dAtA[i:], m.CcFlags[iNdEx])
			i = encodeVarintTestLog(dAtA, i, uint64(len(m.CcFlags[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Mode) > 0 {
		i -= len(m.Mode)
		copy(dAtA[i:], m.Mode)
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.Mode)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommitId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommitId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PendingChangelist != 0 {
		i = encodeVarintTestLog(dAtA, i, uint64(m.PendingChangelist))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Snapshot) > 0 {
		i -= len(m.Snapshot)
		copy(dAtA[i:], m.Snapshot)
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.Snapshot)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Kind != nil {
		{
			size := m.Kind.Size()
			i -= size
			if _, err := m.Kind.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CommitId_Changelist) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommitId_Changelist) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTestLog(dAtA, i, uint64(m.Changelist))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *CommitId_Hash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommitId_Hash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Hash)
	copy(dAtA[i:], m.Hash)
	i = encodeVarintTestLog(dAtA, i, uint64(len(m.Hash)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *CPUInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CPUInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CPUInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CacheSize) > 0 {
		for k := range m.CacheSize {
			v := m.CacheSize[k]
			baseI := i
			i = encodeVarintTestLog(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTestLog(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTestLog(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.CpuGovernor) > 0 {
		i -= len(m.CpuGovernor)
		copy(dAtA[i:], m.CpuGovernor)
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.CpuGovernor)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.CpuInfo) > 0 {
		i -= len(m.CpuInfo)
		copy(dAtA[i:], m.CpuInfo)
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.CpuInfo)))
		i--
		dAtA[i] = 0x22
	}
	if m.MhzPerCpu != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MhzPerCpu))))
		i--
		dAtA[i] = 0x19
	}
	if m.NumCoresAllowed != 0 {
		i = encodeVarintTestLog(dAtA, i, uint64(m.NumCoresAllowed))
		i--
		dAtA[i] = 0x10
	}
	if m.NumCores != 0 {
		i = encodeVarintTestLog(dAtA, i, uint64(m.NumCores))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MemoryInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoryInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoryInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Available != 0 {
		i = encodeVarintTestLog(dAtA, i, uint64(m.Available))
		i--
		dAtA[i] = 0x10
	}
	if m.Total != 0 {
		i = encodeVarintTestLog(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GPUInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GPUInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GPUInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BusId) > 0 {
		i -= len(m.BusId)
		copy(dAtA[i:], m.BusId)
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.BusId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Model) > 0 {
		i -= len(m.Model)
		copy(dAtA[i:], m.Model)
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.Model)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PlatformInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlatformInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlatformInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.System) > 0 {
		i -= len(m.System)
		copy(dAtA[i:], m.System)
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.System)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Release) > 0 {
		i -= len(m.Release)
		copy(dAtA[i:], m.Release)
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.Release)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Machine) > 0 {
		i -= len(m.Machine)
		copy(dAtA[i:], m.Machine)
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.Machine)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Linkage) > 0 {
		i -= len(m.Linkage)
		copy(dAtA[i:], m.Linkage)
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.Linkage)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Bits) > 0 {
		i -= len(m.Bits)
		copy(dAtA[i:], m.Bits)
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.Bits)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AvailableDeviceInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AvailableDeviceInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AvailableDeviceInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PhysicalDescription) > 0 {
		i -= len(m.PhysicalDescription)
		copy(dAtA[i:], m.PhysicalDescription)
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.PhysicalDescription)))
		i--
		dAtA[i] = 0x22
	}
	if m.MemoryLimit != 0 {
		i = encodeVarintTestLog(dAtA, i, uint64(m.MemoryLimit))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MachineConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MachineConfiguration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MachineConfiguration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SerialIdentifier) > 0 {
		i -= len(m.SerialIdentifier)
		copy(dAtA[i:], m.SerialIdentifier)
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.SerialIdentifier)))
		i--
		dAtA[i] = 0x3a
	}
	if m.MemoryInfo != nil {
		{
			size, err := m.MemoryInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.AvailableDeviceInfo) > 0 {
		for iNdEx := len(m.AvailableDeviceInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AvailableDeviceInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTestLog(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.DeviceInfo) > 0 {
		for iNdEx := len(m.DeviceInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DeviceInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTestLog(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.CpuInfo != nil {
		{
			size, err := m.CpuInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PlatformInfo != nil {
		{
			size, err := m.PlatformInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RunConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunConfiguration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RunConfiguration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EnvVars) > 0 {
		for k := range m.EnvVars {
			v := m.EnvVars[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTestLog(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTestLog(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTestLog(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Argument) > 0 {
		for iNdEx := len(m.Argument) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Argument[iNdEx])
			copy(dAtA[i:], m.Argument[iNdEx])
			i = encodeVarintTestLog(dAtA, i, uint64(len(m.Argument[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TestResults) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestResults) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestResults) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TfVersion) > 0 {
		i -= len(m.TfVersion)
		copy(dAtA[i:], m.TfVersion)
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.TfVersion)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.RunMode) > 0 {
		i -= len(m.RunMode)
		copy(dAtA[i:], m.RunMode)
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.RunMode)))
		i--
		dAtA[i] = 0x5a
	}
	if m.BenchmarkType != 0 {
		i = encodeVarintTestLog(dAtA, i, uint64(m.BenchmarkType))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x4a
	}
	if m.RunConfiguration != nil {
		{
			size, err := m.RunConfiguration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.MachineConfiguration != nil {
		{
			size, err := m.MachineConfiguration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.RunTime != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.RunTime))))
		i--
		dAtA[i] = 0x31
	}
	if m.StartTime != 0 {
		i = encodeVarintTestLog(dAtA, i, uint64(m.StartTime))
		i--
		dAtA[i] = 0x28
	}
	if m.CommitId != nil {
		{
			size, err := m.CommitId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.BuildConfiguration != nil {
		{
			size, err := m.BuildConfiguration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Entries != nil {
		{
			size, err := m.Entries.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Target) > 0 {
		i -= len(m.Target)
		copy(dAtA[i:], m.Target)
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.Target)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTestLog(dAtA []byte, offset int, v uint64) int {
	offset -= sovTestLog(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EntryValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != nil {
		n += m.Kind.Size()
	}
	return n
}

func (m *EntryValue_DoubleValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}
func (m *EntryValue_StringValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StringValue)
	n += 1 + l + sovTestLog(uint64(l))
	return n
}
func (m *MetricEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	if m.Value != 0 {
		n += 9
	}
	if m.MinValue != nil {
		l = m.MinValue.Size()
		n += 1 + l + sovTestLog(uint64(l))
	}
	if m.MaxValue != nil {
		l = m.MaxValue.Size()
		n += 1 + l + sovTestLog(uint64(l))
	}
	return n
}

func (m *BenchmarkEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	if m.Iters != 0 {
		n += 1 + sovTestLog(uint64(m.Iters))
	}
	if m.CpuTime != 0 {
		n += 9
	}
	if m.WallTime != 0 {
		n += 9
	}
	if m.Throughput != 0 {
		n += 9
	}
	if len(m.Extras) > 0 {
		for k, v := range m.Extras {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTestLog(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTestLog(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTestLog(uint64(mapEntrySize))
		}
	}
	if len(m.Metrics) > 0 {
		for _, e := range m.Metrics {
			l = e.Size()
			n += 1 + l + sovTestLog(uint64(l))
		}
	}
	return n
}

func (m *BenchmarkEntries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entry) > 0 {
		for _, e := range m.Entry {
			l = e.Size()
			n += 1 + l + sovTestLog(uint64(l))
		}
	}
	return n
}

func (m *BuildConfiguration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Mode)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	if len(m.CcFlags) > 0 {
		for _, s := range m.CcFlags {
			l = len(s)
			n += 1 + l + sovTestLog(uint64(l))
		}
	}
	if len(m.Opts) > 0 {
		for _, s := range m.Opts {
			l = len(s)
			n += 1 + l + sovTestLog(uint64(l))
		}
	}
	return n
}

func (m *CommitId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != nil {
		n += m.Kind.Size()
	}
	l = len(m.Snapshot)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	if m.PendingChangelist != 0 {
		n += 1 + sovTestLog(uint64(m.PendingChangelist))
	}
	return n
}

func (m *CommitId_Changelist) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTestLog(uint64(m.Changelist))
	return n
}
func (m *CommitId_Hash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	n += 1 + l + sovTestLog(uint64(l))
	return n
}
func (m *CPUInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumCores != 0 {
		n += 1 + sovTestLog(uint64(m.NumCores))
	}
	if m.NumCoresAllowed != 0 {
		n += 1 + sovTestLog(uint64(m.NumCoresAllowed))
	}
	if m.MhzPerCpu != 0 {
		n += 9
	}
	l = len(m.CpuInfo)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	l = len(m.CpuGovernor)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	if len(m.CacheSize) > 0 {
		for k, v := range m.CacheSize {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTestLog(uint64(len(k))) + 1 + sovTestLog(uint64(v))
			n += mapEntrySize + 1 + sovTestLog(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *MemoryInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovTestLog(uint64(m.Total))
	}
	if m.Available != 0 {
		n += 1 + sovTestLog(uint64(m.Available))
	}
	return n
}

func (m *GPUInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	l = len(m.BusId)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	return n
}

func (m *PlatformInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Bits)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	l = len(m.Linkage)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	l = len(m.Machine)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	l = len(m.Release)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	l = len(m.System)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	return n
}

func (m *AvailableDeviceInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	if m.MemoryLimit != 0 {
		n += 1 + sovTestLog(uint64(m.MemoryLimit))
	}
	l = len(m.PhysicalDescription)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	return n
}

func (m *MachineConfiguration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	if m.PlatformInfo != nil {
		l = m.PlatformInfo.Size()
		n += 1 + l + sovTestLog(uint64(l))
	}
	if m.CpuInfo != nil {
		l = m.CpuInfo.Size()
		n += 1 + l + sovTestLog(uint64(l))
	}
	if len(m.DeviceInfo) > 0 {
		for _, e := range m.DeviceInfo {
			l = e.Size()
			n += 1 + l + sovTestLog(uint64(l))
		}
	}
	if len(m.AvailableDeviceInfo) > 0 {
		for _, e := range m.AvailableDeviceInfo {
			l = e.Size()
			n += 1 + l + sovTestLog(uint64(l))
		}
	}
	if m.MemoryInfo != nil {
		l = m.MemoryInfo.Size()
		n += 1 + l + sovTestLog(uint64(l))
	}
	l = len(m.SerialIdentifier)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	return n
}

func (m *RunConfiguration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Argument) > 0 {
		for _, s := range m.Argument {
			l = len(s)
			n += 1 + l + sovTestLog(uint64(l))
		}
	}
	if len(m.EnvVars) > 0 {
		for k, v := range m.EnvVars {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTestLog(uint64(len(k))) + 1 + len(v) + sovTestLog(uint64(len(v)))
			n += mapEntrySize + 1 + sovTestLog(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *TestResults) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	if m.Entries != nil {
		l = m.Entries.Size()
		n += 1 + l + sovTestLog(uint64(l))
	}
	if m.BuildConfiguration != nil {
		l = m.BuildConfiguration.Size()
		n += 1 + l + sovTestLog(uint64(l))
	}
	if m.CommitId != nil {
		l = m.CommitId.Size()
		n += 1 + l + sovTestLog(uint64(l))
	}
	if m.StartTime != 0 {
		n += 1 + sovTestLog(uint64(m.StartTime))
	}
	if m.RunTime != 0 {
		n += 9
	}
	if m.MachineConfiguration != nil {
		l = m.MachineConfiguration.Size()
		n += 1 + l + sovTestLog(uint64(l))
	}
	if m.RunConfiguration != nil {
		l = m.RunConfiguration.Size()
		n += 1 + l + sovTestLog(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	if m.BenchmarkType != 0 {
		n += 1 + sovTestLog(uint64(m.BenchmarkType))
	}
	l = len(m.RunMode)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	l = len(m.TfVersion)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	return n
}

func sovTestLog(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTestLog(x uint64) (n int) {
	return sovTestLog(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EntryValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntryValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntryValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Kind = &EntryValue_DoubleValue{float64(math.Float64frombits(v))}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = &EntryValue_StringValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MinValue == nil {
				m.MinValue = &types.DoubleValue{}
			}
			if err := m.MinValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxValue == nil {
				m.MaxValue = &types.DoubleValue{}
			}
			if err := m.MaxValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BenchmarkEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BenchmarkEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BenchmarkEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iters", wireType)
			}
			m.Iters = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Iters |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuTime", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuTime = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field WallTime", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.WallTime = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Throughput", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Throughput = float64(math.Float64frombits(v))
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extras", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Extras == nil {
				m.Extras = make(map[string]*EntryValue)
			}
			var mapkey string
			var mapvalue *EntryValue
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTestLog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTestLog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTestLog
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTestLog
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTestLog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTestLog
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTestLog
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &EntryValue{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTestLog(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTestLog
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Extras[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metrics = append(m.Metrics, &MetricEntry{})
			if err := m.Metrics[len(m.Metrics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BenchmarkEntries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BenchmarkEntries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BenchmarkEntries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entry = append(m.Entry, &BenchmarkEntry{})
			if err := m.Entry[len(m.Entry)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CcFlags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CcFlags = append(m.CcFlags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Opts = append(m.Opts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changelist", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Kind = &CommitId_Changelist{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = &CommitId_Hash{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Snapshot = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingChangelist", wireType)
			}
			m.PendingChangelist = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PendingChangelist |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTestLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CPUInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPUInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPUInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumCores", wireType)
			}
			m.NumCores = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumCores |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumCoresAllowed", wireType)
			}
			m.NumCoresAllowed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumCoresAllowed |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MhzPerCpu", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MhzPerCpu = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuGovernor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuGovernor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheSize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CacheSize == nil {
				m.CacheSize = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTestLog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTestLog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTestLog
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTestLog
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTestLog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTestLog(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTestLog
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CacheSize[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoryInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoryInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoryInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Available", wireType)
			}
			m.Available = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Available |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTestLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GPUInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GPUInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GPUInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BusId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BusId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlatformInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlatformInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlatformInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bits = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Linkage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Linkage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Machine", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Machine = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Release", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Release = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field System", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.System = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AvailableDeviceInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AvailableDeviceInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AvailableDeviceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryLimit", wireType)
			}
			m.MemoryLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryLimit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhysicalDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MachineConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MachineConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MachineConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlatformInfo == nil {
				m.PlatformInfo = &PlatformInfo{}
			}
			if err := m.PlatformInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CpuInfo == nil {
				m.CpuInfo = &CPUInfo{}
			}
			if err := m.CpuInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceInfo = append(m.DeviceInfo, &types.Any{})
			if err := m.DeviceInfo[len(m.DeviceInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableDeviceInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailableDeviceInfo = append(m.AvailableDeviceInfo, &AvailableDeviceInfo{})
			if err := m.AvailableDeviceInfo[len(m.AvailableDeviceInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MemoryInfo == nil {
				m.MemoryInfo = &MemoryInfo{}
			}
			if err := m.MemoryInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialIdentifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerialIdentifier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Argument", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Argument = append(m.Argument, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvVars", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnvVars == nil {
				m.EnvVars = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTestLog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTestLog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTestLog
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTestLog
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTestLog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTestLog
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTestLog
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTestLog(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTestLog
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EnvVars[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestResults) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestResults: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestResults: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entries == nil {
				m.Entries = &BenchmarkEntries{}
			}
			if err := m.Entries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildConfiguration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BuildConfiguration == nil {
				m.BuildConfiguration = &BuildConfiguration{}
			}
			if err := m.BuildConfiguration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommitId == nil {
				m.CommitId = &CommitId{}
			}
			if err := m.CommitId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunTime", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.RunTime = float64(math.Float64frombits(v))
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MachineConfiguration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MachineConfiguration == nil {
				m.MachineConfiguration = &MachineConfiguration{}
			}
			if err := m.MachineConfiguration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunConfiguration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RunConfiguration == nil {
				m.RunConfiguration = &RunConfiguration{}
			}
			if err := m.RunConfiguration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BenchmarkType", wireType)
			}
			m.BenchmarkType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BenchmarkType |= TestResults_BenchmarkType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RunMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TfVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TfVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTestLog(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTestLog
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTestLog
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTestLog
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTestLog
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTestLog        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTestLog          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTestLog = fmt.Errorf("proto: unexpected end of group")
)
