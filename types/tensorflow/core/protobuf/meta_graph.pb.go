// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tensorflow/core/protobuf/meta_graph.proto

package protobuf

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/gogo/protobuf/types"
import tensorflow10 "github.com/Applifier/go-tensorflow/types/tensorflow/core/framework"
import tensorflow7 "github.com/Applifier/go-tensorflow/types/tensorflow/core/framework"
import tensorflow "github.com/Applifier/go-tensorflow/types/tensorflow/core/framework"
import tensorflow1 "github.com/Applifier/go-tensorflow/types/tensorflow/core/framework"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// NOTE: This protocol buffer is evolving, and will go through revisions in the
// coming months.
//
// Protocol buffer containing the following which are necessary to restart
// training, run inference. It can be used to serialize/de-serialize memory
// objects necessary for running computation in a graph when crossing the
// process boundary. It can be used for long term storage of graphs,
// cross-language execution of graphs, etc.
//   MetaInfoDef
//   GraphDef
//   SaverDef
//   CollectionDef
//   TensorInfo
//   SignatureDef
type MetaGraphDef struct {
	MetaInfoDef *MetaGraphDef_MetaInfoDef `protobuf:"bytes,1,opt,name=meta_info_def,json=metaInfoDef" json:"meta_info_def,omitempty"`
	// GraphDef.
	GraphDef *tensorflow10.GraphDef `protobuf:"bytes,2,opt,name=graph_def,json=graphDef" json:"graph_def,omitempty"`
	// SaverDef.
	SaverDef *SaverDef `protobuf:"bytes,3,opt,name=saver_def,json=saverDef" json:"saver_def,omitempty"`
	// collection_def: Map from collection name to collections.
	// See CollectionDef section for details.
	CollectionDef map[string]*CollectionDef `protobuf:"bytes,4,rep,name=collection_def,json=collectionDef" json:"collection_def,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// signature_def: Map from user supplied key for a signature to a single
	// SignatureDef.
	SignatureDef map[string]*SignatureDef `protobuf:"bytes,5,rep,name=signature_def,json=signatureDef" json:"signature_def,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// Asset file def to be used with the defined graph.
	AssetFileDef []*AssetFileDef `protobuf:"bytes,6,rep,name=asset_file_def,json=assetFileDef" json:"asset_file_def,omitempty"`
}

func (m *MetaGraphDef) Reset()                    { *m = MetaGraphDef{} }
func (m *MetaGraphDef) String() string            { return proto.CompactTextString(m) }
func (*MetaGraphDef) ProtoMessage()               {}
func (*MetaGraphDef) Descriptor() ([]byte, []int) { return fileDescriptorMetaGraph, []int{0} }

func (m *MetaGraphDef) GetMetaInfoDef() *MetaGraphDef_MetaInfoDef {
	if m != nil {
		return m.MetaInfoDef
	}
	return nil
}

func (m *MetaGraphDef) GetGraphDef() *tensorflow10.GraphDef {
	if m != nil {
		return m.GraphDef
	}
	return nil
}

func (m *MetaGraphDef) GetSaverDef() *SaverDef {
	if m != nil {
		return m.SaverDef
	}
	return nil
}

func (m *MetaGraphDef) GetCollectionDef() map[string]*CollectionDef {
	if m != nil {
		return m.CollectionDef
	}
	return nil
}

func (m *MetaGraphDef) GetSignatureDef() map[string]*SignatureDef {
	if m != nil {
		return m.SignatureDef
	}
	return nil
}

func (m *MetaGraphDef) GetAssetFileDef() []*AssetFileDef {
	if m != nil {
		return m.AssetFileDef
	}
	return nil
}

// Meta information regarding the graph to be exported.  To be used by users
// of this protocol buffer to encode information regarding their meta graph.
type MetaGraphDef_MetaInfoDef struct {
	// User specified Version string. Can be the name of the model and revision,
	// steps this model has been trained to, etc.
	MetaGraphVersion string `protobuf:"bytes,1,opt,name=meta_graph_version,json=metaGraphVersion,proto3" json:"meta_graph_version,omitempty"`
	// A copy of the OpDefs used by the producer of this graph_def.
	// Descriptions and Ops not used in graph_def are stripped out.
	StrippedOpList *tensorflow7.OpList `protobuf:"bytes,2,opt,name=stripped_op_list,json=strippedOpList" json:"stripped_op_list,omitempty"`
	// A serialized protobuf. Can be the time this meta graph is created, or
	// modified, or name of the model.
	AnyInfo *google_protobuf.Any `protobuf:"bytes,3,opt,name=any_info,json=anyInfo" json:"any_info,omitempty"`
	// User supplied tag(s) on the meta_graph and included graph_def.
	//
	// MetaGraphDefs should be tagged with their capabilities or use-cases.
	// Examples: "train", "serve", "gpu", "tpu", etc.
	// These tags enable loaders to access the MetaGraph(s) appropriate for a
	// specific use-case or runtime environment.
	Tags []string `protobuf:"bytes,4,rep,name=tags" json:"tags,omitempty"`
	// The __version__ string of the tensorflow build used to write this graph.
	// This will be populated by the framework, which will overwrite any user
	// supplied value.
	TensorflowVersion string `protobuf:"bytes,5,opt,name=tensorflow_version,json=tensorflowVersion,proto3" json:"tensorflow_version,omitempty"`
	// The __git_version__ string of the tensorflow build used to write this
	// graph. This will be populated by the framework, which will overwrite any
	// user supplied value.
	TensorflowGitVersion string `protobuf:"bytes,6,opt,name=tensorflow_git_version,json=tensorflowGitVersion,proto3" json:"tensorflow_git_version,omitempty"`
	// A flag to denote whether default-valued attrs have been stripped from
	// the nodes in this graph_def.
	StrippedDefaultAttrs bool `protobuf:"varint,7,opt,name=stripped_default_attrs,json=strippedDefaultAttrs,proto3" json:"stripped_default_attrs,omitempty"`
}

func (m *MetaGraphDef_MetaInfoDef) Reset()         { *m = MetaGraphDef_MetaInfoDef{} }
func (m *MetaGraphDef_MetaInfoDef) String() string { return proto.CompactTextString(m) }
func (*MetaGraphDef_MetaInfoDef) ProtoMessage()    {}
func (*MetaGraphDef_MetaInfoDef) Descriptor() ([]byte, []int) {
	return fileDescriptorMetaGraph, []int{0, 0}
}

func (m *MetaGraphDef_MetaInfoDef) GetMetaGraphVersion() string {
	if m != nil {
		return m.MetaGraphVersion
	}
	return ""
}

func (m *MetaGraphDef_MetaInfoDef) GetStrippedOpList() *tensorflow7.OpList {
	if m != nil {
		return m.StrippedOpList
	}
	return nil
}

func (m *MetaGraphDef_MetaInfoDef) GetAnyInfo() *google_protobuf.Any {
	if m != nil {
		return m.AnyInfo
	}
	return nil
}

func (m *MetaGraphDef_MetaInfoDef) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *MetaGraphDef_MetaInfoDef) GetTensorflowVersion() string {
	if m != nil {
		return m.TensorflowVersion
	}
	return ""
}

func (m *MetaGraphDef_MetaInfoDef) GetTensorflowGitVersion() string {
	if m != nil {
		return m.TensorflowGitVersion
	}
	return ""
}

func (m *MetaGraphDef_MetaInfoDef) GetStrippedDefaultAttrs() bool {
	if m != nil {
		return m.StrippedDefaultAttrs
	}
	return false
}

// CollectionDef should cover most collections.
// To add a user-defined collection, do one of the following:
// 1. For simple data types, such as string, int, float:
//      tf.add_to_collection("your_collection_name", your_simple_value)
//    strings will be stored as bytes_list.
//
// 2. For Protobuf types, there are three ways to add them:
//    1) tf.add_to_collection("your_collection_name",
//         your_proto.SerializeToString())
//
//       collection_def {
//         key: "user_defined_bytes_collection"
//         value {
//           bytes_list {
//             value: "queue_name: \"test_queue\"\n"
//           }
//         }
//       }
//
//  or
//
//    2) tf.add_to_collection("your_collection_name", str(your_proto))
//
//       collection_def {
//         key: "user_defined_string_collection"
//         value {
//          bytes_list {
//             value: "\n\ntest_queue"
//           }
//         }
//       }
//
//  or
//
//    3) any_buf = any_pb2.Any()
//       tf.add_to_collection("your_collection_name",
//         any_buf.Pack(your_proto))
//
//       collection_def {
//         key: "user_defined_any_collection"
//         value {
//           any_list {
//             value {
//               type_url: "type.googleapis.com/tensorflow.QueueRunnerDef"
//               value: "\n\ntest_queue"
//             }
//           }
//         }
//       }
//
// 3. For Python objects, implement to_proto() and from_proto(), and register
//    them in the following manner:
//    ops.register_proto_function("your_collection_name",
//                                proto_type,
//                                to_proto=YourPythonObject.to_proto,
//                                from_proto=YourPythonObject.from_proto)
//    These functions will be invoked to serialize and de-serialize the
//    collection. For example,
//    ops.register_proto_function(ops.GraphKeys.GLOBAL_VARIABLES,
//                                proto_type=variable_pb2.VariableDef,
//                                to_proto=Variable.to_proto,
//                                from_proto=Variable.from_proto)
type CollectionDef struct {
	// Types that are valid to be assigned to Kind:
	//	*CollectionDef_NodeList_
	//	*CollectionDef_BytesList_
	//	*CollectionDef_Int64List_
	//	*CollectionDef_FloatList_
	//	*CollectionDef_AnyList_
	Kind isCollectionDef_Kind `protobuf_oneof:"kind"`
}

func (m *CollectionDef) Reset()                    { *m = CollectionDef{} }
func (m *CollectionDef) String() string            { return proto.CompactTextString(m) }
func (*CollectionDef) ProtoMessage()               {}
func (*CollectionDef) Descriptor() ([]byte, []int) { return fileDescriptorMetaGraph, []int{1} }

type isCollectionDef_Kind interface {
	isCollectionDef_Kind()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CollectionDef_NodeList_ struct {
	NodeList *CollectionDef_NodeList `protobuf:"bytes,1,opt,name=node_list,json=nodeList,oneof"`
}
type CollectionDef_BytesList_ struct {
	BytesList *CollectionDef_BytesList `protobuf:"bytes,2,opt,name=bytes_list,json=bytesList,oneof"`
}
type CollectionDef_Int64List_ struct {
	Int64List *CollectionDef_Int64List `protobuf:"bytes,3,opt,name=int64_list,json=int64List,oneof"`
}
type CollectionDef_FloatList_ struct {
	FloatList *CollectionDef_FloatList `protobuf:"bytes,4,opt,name=float_list,json=floatList,oneof"`
}
type CollectionDef_AnyList_ struct {
	AnyList *CollectionDef_AnyList `protobuf:"bytes,5,opt,name=any_list,json=anyList,oneof"`
}

func (*CollectionDef_NodeList_) isCollectionDef_Kind()  {}
func (*CollectionDef_BytesList_) isCollectionDef_Kind() {}
func (*CollectionDef_Int64List_) isCollectionDef_Kind() {}
func (*CollectionDef_FloatList_) isCollectionDef_Kind() {}
func (*CollectionDef_AnyList_) isCollectionDef_Kind()   {}

func (m *CollectionDef) GetKind() isCollectionDef_Kind {
	if m != nil {
		return m.Kind
	}
	return nil
}

func (m *CollectionDef) GetNodeList() *CollectionDef_NodeList {
	if x, ok := m.GetKind().(*CollectionDef_NodeList_); ok {
		return x.NodeList
	}
	return nil
}

func (m *CollectionDef) GetBytesList() *CollectionDef_BytesList {
	if x, ok := m.GetKind().(*CollectionDef_BytesList_); ok {
		return x.BytesList
	}
	return nil
}

func (m *CollectionDef) GetInt64List() *CollectionDef_Int64List {
	if x, ok := m.GetKind().(*CollectionDef_Int64List_); ok {
		return x.Int64List
	}
	return nil
}

func (m *CollectionDef) GetFloatList() *CollectionDef_FloatList {
	if x, ok := m.GetKind().(*CollectionDef_FloatList_); ok {
		return x.FloatList
	}
	return nil
}

func (m *CollectionDef) GetAnyList() *CollectionDef_AnyList {
	if x, ok := m.GetKind().(*CollectionDef_AnyList_); ok {
		return x.AnyList
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CollectionDef) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CollectionDef_OneofMarshaler, _CollectionDef_OneofUnmarshaler, _CollectionDef_OneofSizer, []interface{}{
		(*CollectionDef_NodeList_)(nil),
		(*CollectionDef_BytesList_)(nil),
		(*CollectionDef_Int64List_)(nil),
		(*CollectionDef_FloatList_)(nil),
		(*CollectionDef_AnyList_)(nil),
	}
}

func _CollectionDef_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CollectionDef)
	// kind
	switch x := m.Kind.(type) {
	case *CollectionDef_NodeList_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NodeList); err != nil {
			return err
		}
	case *CollectionDef_BytesList_:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BytesList); err != nil {
			return err
		}
	case *CollectionDef_Int64List_:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Int64List); err != nil {
			return err
		}
	case *CollectionDef_FloatList_:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FloatList); err != nil {
			return err
		}
	case *CollectionDef_AnyList_:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AnyList); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CollectionDef.Kind has unexpected type %T", x)
	}
	return nil
}

func _CollectionDef_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CollectionDef)
	switch tag {
	case 1: // kind.node_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CollectionDef_NodeList)
		err := b.DecodeMessage(msg)
		m.Kind = &CollectionDef_NodeList_{msg}
		return true, err
	case 2: // kind.bytes_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CollectionDef_BytesList)
		err := b.DecodeMessage(msg)
		m.Kind = &CollectionDef_BytesList_{msg}
		return true, err
	case 3: // kind.int64_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CollectionDef_Int64List)
		err := b.DecodeMessage(msg)
		m.Kind = &CollectionDef_Int64List_{msg}
		return true, err
	case 4: // kind.float_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CollectionDef_FloatList)
		err := b.DecodeMessage(msg)
		m.Kind = &CollectionDef_FloatList_{msg}
		return true, err
	case 5: // kind.any_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CollectionDef_AnyList)
		err := b.DecodeMessage(msg)
		m.Kind = &CollectionDef_AnyList_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CollectionDef_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CollectionDef)
	// kind
	switch x := m.Kind.(type) {
	case *CollectionDef_NodeList_:
		s := proto.Size(x.NodeList)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CollectionDef_BytesList_:
		s := proto.Size(x.BytesList)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CollectionDef_Int64List_:
		s := proto.Size(x.Int64List)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CollectionDef_FloatList_:
		s := proto.Size(x.FloatList)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CollectionDef_AnyList_:
		s := proto.Size(x.AnyList)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// NodeList is used for collecting nodes in graph. For example
// collection_def {
//   key: "summaries"
//   value {
//     node_list {
//       value: "input_producer/ScalarSummary:0"
//       value: "shuffle_batch/ScalarSummary:0"
//       value: "ImageSummary:0"
//     }
//   }
type CollectionDef_NodeList struct {
	Value []string `protobuf:"bytes,1,rep,name=value" json:"value,omitempty"`
}

func (m *CollectionDef_NodeList) Reset()         { *m = CollectionDef_NodeList{} }
func (m *CollectionDef_NodeList) String() string { return proto.CompactTextString(m) }
func (*CollectionDef_NodeList) ProtoMessage()    {}
func (*CollectionDef_NodeList) Descriptor() ([]byte, []int) {
	return fileDescriptorMetaGraph, []int{1, 0}
}

func (m *CollectionDef_NodeList) GetValue() []string {
	if m != nil {
		return m.Value
	}
	return nil
}

// BytesList is used for collecting strings and serialized protobufs. For
// example:
// collection_def {
//   key: "trainable_variables"
//   value {
//     bytes_list {
//       value: "\n\017conv1/weights:0\022\024conv1/weights/Assign
//              \032\024conv1/weights/read:0"
//       value: "\n\016conv1/biases:0\022\023conv1/biases/Assign\032
//              \023conv1/biases/read:0"
//     }
//   }
// }
type CollectionDef_BytesList struct {
	Value [][]byte `protobuf:"bytes,1,rep,name=value" json:"value,omitempty"`
}

func (m *CollectionDef_BytesList) Reset()         { *m = CollectionDef_BytesList{} }
func (m *CollectionDef_BytesList) String() string { return proto.CompactTextString(m) }
func (*CollectionDef_BytesList) ProtoMessage()    {}
func (*CollectionDef_BytesList) Descriptor() ([]byte, []int) {
	return fileDescriptorMetaGraph, []int{1, 1}
}

func (m *CollectionDef_BytesList) GetValue() [][]byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// Int64List is used for collecting int, int64 and long values.
type CollectionDef_Int64List struct {
	Value []int64 `protobuf:"varint,1,rep,packed,name=value" json:"value,omitempty"`
}

func (m *CollectionDef_Int64List) Reset()         { *m = CollectionDef_Int64List{} }
func (m *CollectionDef_Int64List) String() string { return proto.CompactTextString(m) }
func (*CollectionDef_Int64List) ProtoMessage()    {}
func (*CollectionDef_Int64List) Descriptor() ([]byte, []int) {
	return fileDescriptorMetaGraph, []int{1, 2}
}

func (m *CollectionDef_Int64List) GetValue() []int64 {
	if m != nil {
		return m.Value
	}
	return nil
}

// FloatList is used for collecting float values.
type CollectionDef_FloatList struct {
	Value []float32 `protobuf:"fixed32,1,rep,packed,name=value" json:"value,omitempty"`
}

func (m *CollectionDef_FloatList) Reset()         { *m = CollectionDef_FloatList{} }
func (m *CollectionDef_FloatList) String() string { return proto.CompactTextString(m) }
func (*CollectionDef_FloatList) ProtoMessage()    {}
func (*CollectionDef_FloatList) Descriptor() ([]byte, []int) {
	return fileDescriptorMetaGraph, []int{1, 3}
}

func (m *CollectionDef_FloatList) GetValue() []float32 {
	if m != nil {
		return m.Value
	}
	return nil
}

// AnyList is used for collecting Any protos.
type CollectionDef_AnyList struct {
	Value []*google_protobuf.Any `protobuf:"bytes,1,rep,name=value" json:"value,omitempty"`
}

func (m *CollectionDef_AnyList) Reset()         { *m = CollectionDef_AnyList{} }
func (m *CollectionDef_AnyList) String() string { return proto.CompactTextString(m) }
func (*CollectionDef_AnyList) ProtoMessage()    {}
func (*CollectionDef_AnyList) Descriptor() ([]byte, []int) {
	return fileDescriptorMetaGraph, []int{1, 4}
}

func (m *CollectionDef_AnyList) GetValue() []*google_protobuf.Any {
	if m != nil {
		return m.Value
	}
	return nil
}

// Information about a Tensor necessary for feeding or retrieval.
type TensorInfo struct {
	// Types that are valid to be assigned to Encoding:
	//	*TensorInfo_Name
	//	*TensorInfo_CooSparse_
	Encoding isTensorInfo_Encoding `protobuf_oneof:"encoding"`
	Dtype    tensorflow1.DataType  `protobuf:"varint,2,opt,name=dtype,proto3,enum=tensorflow.DataType" json:"dtype,omitempty"`
	// The static shape should be recorded here, to the extent that it can
	// be known in advance.  In the case of a SparseTensor, this field describes
	// the logical shape of the represented tensor (aka dense_shape).
	TensorShape *tensorflow.TensorShapeProto `protobuf:"bytes,3,opt,name=tensor_shape,json=tensorShape" json:"tensor_shape,omitempty"`
}

func (m *TensorInfo) Reset()                    { *m = TensorInfo{} }
func (m *TensorInfo) String() string            { return proto.CompactTextString(m) }
func (*TensorInfo) ProtoMessage()               {}
func (*TensorInfo) Descriptor() ([]byte, []int) { return fileDescriptorMetaGraph, []int{2} }

type isTensorInfo_Encoding interface {
	isTensorInfo_Encoding()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TensorInfo_Name struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3,oneof"`
}
type TensorInfo_CooSparse_ struct {
	CooSparse *TensorInfo_CooSparse `protobuf:"bytes,4,opt,name=coo_sparse,json=cooSparse,oneof"`
}

func (*TensorInfo_Name) isTensorInfo_Encoding()       {}
func (*TensorInfo_CooSparse_) isTensorInfo_Encoding() {}

func (m *TensorInfo) GetEncoding() isTensorInfo_Encoding {
	if m != nil {
		return m.Encoding
	}
	return nil
}

func (m *TensorInfo) GetName() string {
	if x, ok := m.GetEncoding().(*TensorInfo_Name); ok {
		return x.Name
	}
	return ""
}

func (m *TensorInfo) GetCooSparse() *TensorInfo_CooSparse {
	if x, ok := m.GetEncoding().(*TensorInfo_CooSparse_); ok {
		return x.CooSparse
	}
	return nil
}

func (m *TensorInfo) GetDtype() tensorflow1.DataType {
	if m != nil {
		return m.Dtype
	}
	return tensorflow1.DataType_DT_INVALID
}

func (m *TensorInfo) GetTensorShape() *tensorflow.TensorShapeProto {
	if m != nil {
		return m.TensorShape
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TensorInfo) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TensorInfo_OneofMarshaler, _TensorInfo_OneofUnmarshaler, _TensorInfo_OneofSizer, []interface{}{
		(*TensorInfo_Name)(nil),
		(*TensorInfo_CooSparse_)(nil),
	}
}

func _TensorInfo_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TensorInfo)
	// encoding
	switch x := m.Encoding.(type) {
	case *TensorInfo_Name:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Name)
	case *TensorInfo_CooSparse_:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CooSparse); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TensorInfo.Encoding has unexpected type %T", x)
	}
	return nil
}

func _TensorInfo_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TensorInfo)
	switch tag {
	case 1: // encoding.name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Encoding = &TensorInfo_Name{x}
		return true, err
	case 4: // encoding.coo_sparse
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TensorInfo_CooSparse)
		err := b.DecodeMessage(msg)
		m.Encoding = &TensorInfo_CooSparse_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TensorInfo_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TensorInfo)
	// encoding
	switch x := m.Encoding.(type) {
	case *TensorInfo_Name:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Name)))
		n += len(x.Name)
	case *TensorInfo_CooSparse_:
		s := proto.Size(x.CooSparse)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// For sparse tensors, The COO encoding stores a triple of values, indices,
// and shape.
type TensorInfo_CooSparse struct {
	// The shape of the values Tensor is [?].  Its dtype must be the dtype of
	// the SparseTensor as a whole, given in the enclosing TensorInfo.
	ValuesTensorName string `protobuf:"bytes,1,opt,name=values_tensor_name,json=valuesTensorName,proto3" json:"values_tensor_name,omitempty"`
	// The indices Tensor must have dtype int64 and shape [?, ?].
	IndicesTensorName string `protobuf:"bytes,2,opt,name=indices_tensor_name,json=indicesTensorName,proto3" json:"indices_tensor_name,omitempty"`
	// The dynamic logical shape represented by the SparseTensor is recorded in
	// the Tensor referenced here.  It must have dtype int64 and shape [?].
	DenseShapeTensorName string `protobuf:"bytes,3,opt,name=dense_shape_tensor_name,json=denseShapeTensorName,proto3" json:"dense_shape_tensor_name,omitempty"`
}

func (m *TensorInfo_CooSparse) Reset()                    { *m = TensorInfo_CooSparse{} }
func (m *TensorInfo_CooSparse) String() string            { return proto.CompactTextString(m) }
func (*TensorInfo_CooSparse) ProtoMessage()               {}
func (*TensorInfo_CooSparse) Descriptor() ([]byte, []int) { return fileDescriptorMetaGraph, []int{2, 0} }

func (m *TensorInfo_CooSparse) GetValuesTensorName() string {
	if m != nil {
		return m.ValuesTensorName
	}
	return ""
}

func (m *TensorInfo_CooSparse) GetIndicesTensorName() string {
	if m != nil {
		return m.IndicesTensorName
	}
	return ""
}

func (m *TensorInfo_CooSparse) GetDenseShapeTensorName() string {
	if m != nil {
		return m.DenseShapeTensorName
	}
	return ""
}

// SignatureDef defines the signature of a computation supported by a TensorFlow
// graph.
//
// For example, a model with two loss computations, sharing a single input,
// might have the following signature_def map.
//
// Note that across the two SignatureDefs "loss_A" and "loss_B", the input key,
// output key, and method_name are identical, and will be used by system(s) that
// implement or rely upon this particular loss method. The output tensor names
// differ, demonstrating how different outputs can exist for the same method.
//
// signature_def {
//   key: "loss_A"
//   value {
//     inputs {
//       key: "input"
//       value {
//         name: "input:0"
//         dtype: DT_STRING
//         tensor_shape: ...
//       }
//     }
//     outputs {
//       key: "loss_output"
//       value {
//         name: "loss_output_A:0"
//         dtype: DT_FLOAT
//         tensor_shape: ...
//       }
//     }
//   }
//   ...
//   method_name: "some/package/compute_loss"
// }
// signature_def {
//   key: "loss_B"
//   value {
//     inputs {
//       key: "input"
//       value {
//         name: "input:0"
//         dtype: DT_STRING
//         tensor_shape: ...
//       }
//     }
//     outputs {
//       key: "loss_output"
//       value {
//         name: "loss_output_B:0"
//         dtype: DT_FLOAT
//         tensor_shape: ...
//       }
//     }
//   }
//   ...
//   method_name: "some/package/compute_loss"
// }
type SignatureDef struct {
	// Named input parameters.
	Inputs map[string]*TensorInfo `protobuf:"bytes,1,rep,name=inputs" json:"inputs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// Named output parameters.
	Outputs map[string]*TensorInfo `protobuf:"bytes,2,rep,name=outputs" json:"outputs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// Extensible method_name information enabling third-party users to mark a
	// SignatureDef as supporting a particular method. This enables producers and
	// consumers of SignatureDefs, e.g. a model definition library and a serving
	// library to have a clear hand-off regarding the semantics of a computation.
	//
	// Note that multiple SignatureDefs in a single MetaGraphDef may have the same
	// method_name. This is commonly used to support multi-headed computation,
	// where a single graph computation may return multiple results.
	MethodName string `protobuf:"bytes,3,opt,name=method_name,json=methodName,proto3" json:"method_name,omitempty"`
}

func (m *SignatureDef) Reset()                    { *m = SignatureDef{} }
func (m *SignatureDef) String() string            { return proto.CompactTextString(m) }
func (*SignatureDef) ProtoMessage()               {}
func (*SignatureDef) Descriptor() ([]byte, []int) { return fileDescriptorMetaGraph, []int{3} }

func (m *SignatureDef) GetInputs() map[string]*TensorInfo {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *SignatureDef) GetOutputs() map[string]*TensorInfo {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *SignatureDef) GetMethodName() string {
	if m != nil {
		return m.MethodName
	}
	return ""
}

// An asset file def for a single file or a set of sharded files with the same
// name.
type AssetFileDef struct {
	// The tensor to bind the asset filename to.
	TensorInfo *TensorInfo `protobuf:"bytes,1,opt,name=tensor_info,json=tensorInfo" json:"tensor_info,omitempty"`
	// The filename within an assets directory. Note: does not include the path
	// prefix, i.e. directories. For an asset at /tmp/path/vocab.txt, the filename
	// would be "vocab.txt".
	Filename string `protobuf:"bytes,2,opt,name=filename,proto3" json:"filename,omitempty"`
}

func (m *AssetFileDef) Reset()                    { *m = AssetFileDef{} }
func (m *AssetFileDef) String() string            { return proto.CompactTextString(m) }
func (*AssetFileDef) ProtoMessage()               {}
func (*AssetFileDef) Descriptor() ([]byte, []int) { return fileDescriptorMetaGraph, []int{4} }

func (m *AssetFileDef) GetTensorInfo() *TensorInfo {
	if m != nil {
		return m.TensorInfo
	}
	return nil
}

func (m *AssetFileDef) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func init() {
	proto.RegisterType((*MetaGraphDef)(nil), "tensorflow.MetaGraphDef")
	proto.RegisterType((*MetaGraphDef_MetaInfoDef)(nil), "tensorflow.MetaGraphDef.MetaInfoDef")
	proto.RegisterType((*CollectionDef)(nil), "tensorflow.CollectionDef")
	proto.RegisterType((*CollectionDef_NodeList)(nil), "tensorflow.CollectionDef.NodeList")
	proto.RegisterType((*CollectionDef_BytesList)(nil), "tensorflow.CollectionDef.BytesList")
	proto.RegisterType((*CollectionDef_Int64List)(nil), "tensorflow.CollectionDef.Int64List")
	proto.RegisterType((*CollectionDef_FloatList)(nil), "tensorflow.CollectionDef.FloatList")
	proto.RegisterType((*CollectionDef_AnyList)(nil), "tensorflow.CollectionDef.AnyList")
	proto.RegisterType((*TensorInfo)(nil), "tensorflow.TensorInfo")
	proto.RegisterType((*TensorInfo_CooSparse)(nil), "tensorflow.TensorInfo.CooSparse")
	proto.RegisterType((*SignatureDef)(nil), "tensorflow.SignatureDef")
	proto.RegisterType((*AssetFileDef)(nil), "tensorflow.AssetFileDef")
}
func (m *MetaGraphDef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetaGraphDef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MetaInfoDef != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetaGraph(dAtA, i, uint64(m.MetaInfoDef.Size()))
		n1, err := m.MetaInfoDef.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.GraphDef != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetaGraph(dAtA, i, uint64(m.GraphDef.Size()))
		n2, err := m.GraphDef.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.SaverDef != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetaGraph(dAtA, i, uint64(m.SaverDef.Size()))
		n3, err := m.SaverDef.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.CollectionDef) > 0 {
		for k, _ := range m.CollectionDef {
			dAtA[i] = 0x22
			i++
			v := m.CollectionDef[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovMetaGraph(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovMetaGraph(uint64(len(k))) + msgSize
			i = encodeVarintMetaGraph(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintMetaGraph(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintMetaGraph(dAtA, i, uint64(v.Size()))
				n4, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n4
			}
		}
	}
	if len(m.SignatureDef) > 0 {
		for k, _ := range m.SignatureDef {
			dAtA[i] = 0x2a
			i++
			v := m.SignatureDef[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovMetaGraph(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovMetaGraph(uint64(len(k))) + msgSize
			i = encodeVarintMetaGraph(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintMetaGraph(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintMetaGraph(dAtA, i, uint64(v.Size()))
				n5, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n5
			}
		}
	}
	if len(m.AssetFileDef) > 0 {
		for _, msg := range m.AssetFileDef {
			dAtA[i] = 0x32
			i++
			i = encodeVarintMetaGraph(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MetaGraphDef_MetaInfoDef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetaGraphDef_MetaInfoDef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MetaGraphVersion) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetaGraph(dAtA, i, uint64(len(m.MetaGraphVersion)))
		i += copy(dAtA[i:], m.MetaGraphVersion)
	}
	if m.StrippedOpList != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetaGraph(dAtA, i, uint64(m.StrippedOpList.Size()))
		n6, err := m.StrippedOpList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.AnyInfo != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetaGraph(dAtA, i, uint64(m.AnyInfo.Size()))
		n7, err := m.AnyInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.TensorflowVersion) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMetaGraph(dAtA, i, uint64(len(m.TensorflowVersion)))
		i += copy(dAtA[i:], m.TensorflowVersion)
	}
	if len(m.TensorflowGitVersion) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMetaGraph(dAtA, i, uint64(len(m.TensorflowGitVersion)))
		i += copy(dAtA[i:], m.TensorflowGitVersion)
	}
	if m.StrippedDefaultAttrs {
		dAtA[i] = 0x38
		i++
		if m.StrippedDefaultAttrs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CollectionDef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionDef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Kind != nil {
		nn8, err := m.Kind.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn8
	}
	return i, nil
}

func (m *CollectionDef_NodeList_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NodeList != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetaGraph(dAtA, i, uint64(m.NodeList.Size()))
		n9, err := m.NodeList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *CollectionDef_BytesList_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.BytesList != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetaGraph(dAtA, i, uint64(m.BytesList.Size()))
		n10, err := m.BytesList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *CollectionDef_Int64List_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Int64List != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetaGraph(dAtA, i, uint64(m.Int64List.Size()))
		n11, err := m.Int64List.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *CollectionDef_FloatList_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.FloatList != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMetaGraph(dAtA, i, uint64(m.FloatList.Size()))
		n12, err := m.FloatList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *CollectionDef_AnyList_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AnyList != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMetaGraph(dAtA, i, uint64(m.AnyList.Size()))
		n13, err := m.AnyList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *CollectionDef_NodeList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionDef_NodeList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		for _, s := range m.Value {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *CollectionDef_BytesList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionDef_BytesList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		for _, b := range m.Value {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMetaGraph(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *CollectionDef_Int64List) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionDef_Int64List) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		dAtA15 := make([]byte, len(m.Value)*10)
		var j14 int
		for _, num1 := range m.Value {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetaGraph(dAtA, i, uint64(j14))
		i += copy(dAtA[i:], dAtA15[:j14])
	}
	return i, nil
}

func (m *CollectionDef_FloatList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionDef_FloatList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetaGraph(dAtA, i, uint64(len(m.Value)*4))
		for _, num := range m.Value {
			f16 := math.Float32bits(float32(num))
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f16))
			i += 4
		}
	}
	return i, nil
}

func (m *CollectionDef_AnyList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionDef_AnyList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		for _, msg := range m.Value {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMetaGraph(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TensorInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Encoding != nil {
		nn17, err := m.Encoding.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn17
	}
	if m.Dtype != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetaGraph(dAtA, i, uint64(m.Dtype))
	}
	if m.TensorShape != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetaGraph(dAtA, i, uint64(m.TensorShape.Size()))
		n18, err := m.TensorShape.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *TensorInfo_Name) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xa
	i++
	i = encodeVarintMetaGraph(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	return i, nil
}
func (m *TensorInfo_CooSparse_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CooSparse != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMetaGraph(dAtA, i, uint64(m.CooSparse.Size()))
		n19, err := m.CooSparse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}
func (m *TensorInfo_CooSparse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorInfo_CooSparse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ValuesTensorName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetaGraph(dAtA, i, uint64(len(m.ValuesTensorName)))
		i += copy(dAtA[i:], m.ValuesTensorName)
	}
	if len(m.IndicesTensorName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetaGraph(dAtA, i, uint64(len(m.IndicesTensorName)))
		i += copy(dAtA[i:], m.IndicesTensorName)
	}
	if len(m.DenseShapeTensorName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetaGraph(dAtA, i, uint64(len(m.DenseShapeTensorName)))
		i += copy(dAtA[i:], m.DenseShapeTensorName)
	}
	return i, nil
}

func (m *SignatureDef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignatureDef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Inputs) > 0 {
		for k, _ := range m.Inputs {
			dAtA[i] = 0xa
			i++
			v := m.Inputs[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovMetaGraph(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovMetaGraph(uint64(len(k))) + msgSize
			i = encodeVarintMetaGraph(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintMetaGraph(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintMetaGraph(dAtA, i, uint64(v.Size()))
				n20, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n20
			}
		}
	}
	if len(m.Outputs) > 0 {
		for k, _ := range m.Outputs {
			dAtA[i] = 0x12
			i++
			v := m.Outputs[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovMetaGraph(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovMetaGraph(uint64(len(k))) + msgSize
			i = encodeVarintMetaGraph(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintMetaGraph(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintMetaGraph(dAtA, i, uint64(v.Size()))
				n21, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n21
			}
		}
	}
	if len(m.MethodName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetaGraph(dAtA, i, uint64(len(m.MethodName)))
		i += copy(dAtA[i:], m.MethodName)
	}
	return i, nil
}

func (m *AssetFileDef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssetFileDef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TensorInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetaGraph(dAtA, i, uint64(m.TensorInfo.Size()))
		n22, err := m.TensorInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if len(m.Filename) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetaGraph(dAtA, i, uint64(len(m.Filename)))
		i += copy(dAtA[i:], m.Filename)
	}
	return i, nil
}

func encodeVarintMetaGraph(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *MetaGraphDef) Size() (n int) {
	var l int
	_ = l
	if m.MetaInfoDef != nil {
		l = m.MetaInfoDef.Size()
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	if m.GraphDef != nil {
		l = m.GraphDef.Size()
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	if m.SaverDef != nil {
		l = m.SaverDef.Size()
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	if len(m.CollectionDef) > 0 {
		for k, v := range m.CollectionDef {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMetaGraph(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovMetaGraph(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovMetaGraph(uint64(mapEntrySize))
		}
	}
	if len(m.SignatureDef) > 0 {
		for k, v := range m.SignatureDef {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMetaGraph(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovMetaGraph(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovMetaGraph(uint64(mapEntrySize))
		}
	}
	if len(m.AssetFileDef) > 0 {
		for _, e := range m.AssetFileDef {
			l = e.Size()
			n += 1 + l + sovMetaGraph(uint64(l))
		}
	}
	return n
}

func (m *MetaGraphDef_MetaInfoDef) Size() (n int) {
	var l int
	_ = l
	l = len(m.MetaGraphVersion)
	if l > 0 {
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	if m.StrippedOpList != nil {
		l = m.StrippedOpList.Size()
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	if m.AnyInfo != nil {
		l = m.AnyInfo.Size()
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovMetaGraph(uint64(l))
		}
	}
	l = len(m.TensorflowVersion)
	if l > 0 {
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	l = len(m.TensorflowGitVersion)
	if l > 0 {
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	if m.StrippedDefaultAttrs {
		n += 2
	}
	return n
}

func (m *CollectionDef) Size() (n int) {
	var l int
	_ = l
	if m.Kind != nil {
		n += m.Kind.Size()
	}
	return n
}

func (m *CollectionDef_NodeList_) Size() (n int) {
	var l int
	_ = l
	if m.NodeList != nil {
		l = m.NodeList.Size()
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	return n
}
func (m *CollectionDef_BytesList_) Size() (n int) {
	var l int
	_ = l
	if m.BytesList != nil {
		l = m.BytesList.Size()
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	return n
}
func (m *CollectionDef_Int64List_) Size() (n int) {
	var l int
	_ = l
	if m.Int64List != nil {
		l = m.Int64List.Size()
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	return n
}
func (m *CollectionDef_FloatList_) Size() (n int) {
	var l int
	_ = l
	if m.FloatList != nil {
		l = m.FloatList.Size()
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	return n
}
func (m *CollectionDef_AnyList_) Size() (n int) {
	var l int
	_ = l
	if m.AnyList != nil {
		l = m.AnyList.Size()
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	return n
}
func (m *CollectionDef_NodeList) Size() (n int) {
	var l int
	_ = l
	if len(m.Value) > 0 {
		for _, s := range m.Value {
			l = len(s)
			n += 1 + l + sovMetaGraph(uint64(l))
		}
	}
	return n
}

func (m *CollectionDef_BytesList) Size() (n int) {
	var l int
	_ = l
	if len(m.Value) > 0 {
		for _, b := range m.Value {
			l = len(b)
			n += 1 + l + sovMetaGraph(uint64(l))
		}
	}
	return n
}

func (m *CollectionDef_Int64List) Size() (n int) {
	var l int
	_ = l
	if len(m.Value) > 0 {
		l = 0
		for _, e := range m.Value {
			l += sovMetaGraph(uint64(e))
		}
		n += 1 + sovMetaGraph(uint64(l)) + l
	}
	return n
}

func (m *CollectionDef_FloatList) Size() (n int) {
	var l int
	_ = l
	if len(m.Value) > 0 {
		n += 1 + sovMetaGraph(uint64(len(m.Value)*4)) + len(m.Value)*4
	}
	return n
}

func (m *CollectionDef_AnyList) Size() (n int) {
	var l int
	_ = l
	if len(m.Value) > 0 {
		for _, e := range m.Value {
			l = e.Size()
			n += 1 + l + sovMetaGraph(uint64(l))
		}
	}
	return n
}

func (m *TensorInfo) Size() (n int) {
	var l int
	_ = l
	if m.Encoding != nil {
		n += m.Encoding.Size()
	}
	if m.Dtype != 0 {
		n += 1 + sovMetaGraph(uint64(m.Dtype))
	}
	if m.TensorShape != nil {
		l = m.TensorShape.Size()
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	return n
}

func (m *TensorInfo_Name) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovMetaGraph(uint64(l))
	return n
}
func (m *TensorInfo_CooSparse_) Size() (n int) {
	var l int
	_ = l
	if m.CooSparse != nil {
		l = m.CooSparse.Size()
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	return n
}
func (m *TensorInfo_CooSparse) Size() (n int) {
	var l int
	_ = l
	l = len(m.ValuesTensorName)
	if l > 0 {
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	l = len(m.IndicesTensorName)
	if l > 0 {
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	l = len(m.DenseShapeTensorName)
	if l > 0 {
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	return n
}

func (m *SignatureDef) Size() (n int) {
	var l int
	_ = l
	if len(m.Inputs) > 0 {
		for k, v := range m.Inputs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMetaGraph(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovMetaGraph(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovMetaGraph(uint64(mapEntrySize))
		}
	}
	if len(m.Outputs) > 0 {
		for k, v := range m.Outputs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMetaGraph(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovMetaGraph(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovMetaGraph(uint64(mapEntrySize))
		}
	}
	l = len(m.MethodName)
	if l > 0 {
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	return n
}

func (m *AssetFileDef) Size() (n int) {
	var l int
	_ = l
	if m.TensorInfo != nil {
		l = m.TensorInfo.Size()
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	l = len(m.Filename)
	if l > 0 {
		n += 1 + l + sovMetaGraph(uint64(l))
	}
	return n
}

func sovMetaGraph(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMetaGraph(x uint64) (n int) {
	return sovMetaGraph(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MetaGraphDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetaGraphDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetaGraphDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaInfoDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MetaInfoDef == nil {
				m.MetaInfoDef = &MetaGraphDef_MetaInfoDef{}
			}
			if err := m.MetaInfoDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GraphDef == nil {
				m.GraphDef = &tensorflow10.GraphDef{}
			}
			if err := m.GraphDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaverDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SaverDef == nil {
				m.SaverDef = &SaverDef{}
			}
			if err := m.SaverDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CollectionDef == nil {
				m.CollectionDef = make(map[string]*CollectionDef)
			}
			var mapkey string
			var mapvalue *CollectionDef
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetaGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetaGraph
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMetaGraph
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetaGraph
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMetaGraph
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthMetaGraph
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &CollectionDef{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMetaGraph(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMetaGraph
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CollectionDef[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignatureDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignatureDef == nil {
				m.SignatureDef = make(map[string]*SignatureDef)
			}
			var mapkey string
			var mapvalue *SignatureDef
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetaGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetaGraph
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMetaGraph
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetaGraph
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMetaGraph
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthMetaGraph
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SignatureDef{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMetaGraph(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMetaGraph
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SignatureDef[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetFileDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetFileDef = append(m.AssetFileDef, &AssetFileDef{})
			if err := m.AssetFileDef[len(m.AssetFileDef)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetaGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetaGraphDef_MetaInfoDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetaInfoDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetaInfoDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaGraphVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetaGraphVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrippedOpList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StrippedOpList == nil {
				m.StrippedOpList = &tensorflow7.OpList{}
			}
			if err := m.StrippedOpList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AnyInfo == nil {
				m.AnyInfo = &google_protobuf.Any{}
			}
			if err := m.AnyInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TensorflowVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TensorflowVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TensorflowGitVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TensorflowGitVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrippedDefaultAttrs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StrippedDefaultAttrs = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMetaGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CollectionDef_NodeList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &CollectionDef_NodeList_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CollectionDef_BytesList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &CollectionDef_BytesList_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CollectionDef_Int64List{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &CollectionDef_Int64List_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CollectionDef_FloatList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &CollectionDef_FloatList_{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CollectionDef_AnyList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &CollectionDef_AnyList_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetaGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionDef_NodeList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetaGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionDef_BytesList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BytesList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BytesList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, make([]byte, postIndex-iNdEx))
			copy(m.Value[len(m.Value)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetaGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionDef_Int64List) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Int64List: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Int64List: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetaGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Value = append(m.Value, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetaGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMetaGraph
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetaGraph
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Value = append(m.Value, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetaGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionDef_FloatList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FloatList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FloatList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Value = append(m.Value, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetaGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMetaGraph
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Value = append(m.Value, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetaGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionDef_AnyList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnyList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnyList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, &google_protobuf.Any{})
			if err := m.Value[len(m.Value)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetaGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TensorInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TensorInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TensorInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encoding = &TensorInfo_Name{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dtype", wireType)
			}
			m.Dtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dtype |= (tensorflow1.DataType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TensorShape", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TensorShape == nil {
				m.TensorShape = &tensorflow.TensorShapeProto{}
			}
			if err := m.TensorShape.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CooSparse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TensorInfo_CooSparse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Encoding = &TensorInfo_CooSparse_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetaGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TensorInfo_CooSparse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CooSparse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CooSparse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValuesTensorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValuesTensorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndicesTensorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndicesTensorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenseShapeTensorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DenseShapeTensorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetaGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignatureDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignatureDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignatureDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Inputs == nil {
				m.Inputs = make(map[string]*TensorInfo)
			}
			var mapkey string
			var mapvalue *TensorInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetaGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetaGraph
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMetaGraph
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetaGraph
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMetaGraph
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthMetaGraph
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TensorInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMetaGraph(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMetaGraph
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Inputs[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Outputs == nil {
				m.Outputs = make(map[string]*TensorInfo)
			}
			var mapkey string
			var mapvalue *TensorInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetaGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetaGraph
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMetaGraph
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetaGraph
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMetaGraph
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthMetaGraph
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TensorInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMetaGraph(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMetaGraph
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Outputs[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MethodName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MethodName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetaGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssetFileDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetaGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssetFileDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssetFileDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TensorInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TensorInfo == nil {
				m.TensorInfo = &TensorInfo{}
			}
			if err := m.TensorInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetaGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetaGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetaGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMetaGraph(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMetaGraph
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetaGraph
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMetaGraph
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMetaGraph
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMetaGraph(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMetaGraph = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMetaGraph   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("tensorflow/core/protobuf/meta_graph.proto", fileDescriptorMetaGraph) }

var fileDescriptorMetaGraph = []byte{
	// 1072 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xdd, 0x6e, 0x1b, 0x45,
	0x14, 0xce, 0xda, 0x4e, 0x62, 0x1f, 0x3b, 0x21, 0x1d, 0xa2, 0x92, 0xae, 0x50, 0x48, 0x4d, 0x82,
	0x42, 0x49, 0xd7, 0x6a, 0x69, 0x01, 0xa1, 0xaa, 0x95, 0x5d, 0xd3, 0x26, 0x12, 0x34, 0x65, 0x53,
	0x21, 0x01, 0x17, 0xd6, 0xd8, 0x3b, 0xbb, 0x19, 0x65, 0x3d, 0xb3, 0xda, 0x19, 0xa7, 0xf2, 0x25,
	0xe2, 0x05, 0x78, 0x04, 0x9e, 0x02, 0x5e, 0x81, 0x4b, 0x6e, 0xb8, 0xe0, 0x0e, 0x85, 0x97, 0xe0,
	0x12, 0xcd, 0xcc, 0xfe, 0x8c, 0x9b, 0x2c, 0xb9, 0xe1, 0x6e, 0xce, 0x9c, 0xef, 0xfb, 0xe6, 0x9c,
	0x39, 0x67, 0x7e, 0xe0, 0x43, 0x49, 0x98, 0xe0, 0x69, 0x18, 0xf3, 0xd7, 0xbd, 0x09, 0x4f, 0x49,
	0x2f, 0x49, 0xb9, 0xe4, 0xe3, 0x59, 0xd8, 0x9b, 0x12, 0x89, 0x47, 0x51, 0x8a, 0x93, 0x53, 0x4f,
	0xcf, 0x21, 0x28, 0xa1, 0xee, 0xad, 0x88, 0xf3, 0x28, 0xb6, 0xd0, 0x98, 0xcd, 0x0d, 0xcc, 0xdd,
	0x7b, 0x53, 0x31, 0x4c, 0xf1, 0x94, 0xbc, 0xe6, 0xe9, 0x59, 0xcf, 0x52, 0x73, 0x3f, 0xa8, 0x86,
	0xf1, 0x64, 0x14, 0x90, 0x30, 0xc3, 0x1d, 0x54, 0xe3, 0x8c, 0x67, 0x24, 0x4e, 0x71, 0x42, 0xae,
	0x5f, 0x5c, 0xce, 0x13, 0x22, 0x32, 0xd8, 0x6e, 0x65, 0xd6, 0x02, 0x9f, 0x93, 0xd4, 0xa0, 0xba,
	0xbf, 0xae, 0x42, 0xe7, 0x2b, 0x22, 0xf1, 0x73, 0x15, 0xf6, 0x90, 0x84, 0xe8, 0x10, 0xd6, 0xf4,
	0xae, 0x50, 0x16, 0x72, 0x15, 0xe2, 0x96, 0xb3, 0xe3, 0xec, 0xb7, 0xef, 0xef, 0x7a, 0xa5, 0x9c,
	0x67, 0x13, 0xb4, 0x71, 0xc4, 0x42, 0x3e, 0x24, 0xa1, 0xdf, 0x9e, 0x96, 0x06, 0xba, 0x07, 0x2d,
	0xbd, 0x19, 0x5a, 0xa5, 0xa6, 0x55, 0x36, 0x6d, 0x95, 0x5c, 0xc1, 0x6f, 0x46, 0xf9, 0xe2, 0xf7,
	0xa0, 0xa5, 0x83, 0xd3, 0x94, 0xfa, 0x65, 0xca, 0x89, 0x72, 0x6a, 0x8a, 0xc8, 0x46, 0xc8, 0x87,
	0xf5, 0x09, 0x8f, 0x63, 0x32, 0x91, 0x94, 0x33, 0xcd, 0x6b, 0xec, 0xd4, 0xf7, 0xdb, 0xf7, 0x3f,
	0xaa, 0x0c, 0xf8, 0x69, 0x01, 0x1f, 0x92, 0xf0, 0x0b, 0x26, 0xd3, 0xb9, 0xbf, 0x36, 0xb1, 0xe7,
	0xd0, 0x31, 0xac, 0x09, 0x1a, 0x31, 0x2c, 0x67, 0x29, 0xd1, 0x92, 0xcb, 0x5a, 0xf2, 0x4e, 0xa5,
	0xe4, 0x49, 0x8e, 0x2e, 0x14, 0x3b, 0xc2, 0x9a, 0x42, 0x8f, 0x61, 0x1d, 0x0b, 0x41, 0xe4, 0x28,
	0xa4, 0xb1, 0x51, 0x5c, 0xd1, 0x8a, 0x5b, 0xb6, 0x62, 0x5f, 0x21, 0x9e, 0xd1, 0x58, 0x31, 0xfc,
	0x0e, 0xb6, 0x2c, 0xf7, 0xcf, 0x1a, 0xb4, 0xad, 0x7d, 0x46, 0x07, 0x80, 0xca, 0xd6, 0x1d, 0x9d,
	0x93, 0x54, 0x50, 0xce, 0x74, 0xa5, 0x5a, 0xfe, 0xc6, 0x34, 0x8f, 0xec, 0x1b, 0x33, 0x8f, 0x1e,
	0xc1, 0x86, 0x90, 0x29, 0x4d, 0x12, 0x12, 0x8c, 0x78, 0x32, 0x8a, 0xa9, 0x90, 0x59, 0x3d, 0x90,
	0xbd, 0xfe, 0x71, 0xf2, 0x25, 0x15, 0xd2, 0x5f, 0xcf, 0xb1, 0xc6, 0x46, 0x3d, 0x68, 0x62, 0x36,
	0xd7, 0xfd, 0x50, 0x94, 0xc4, 0x9c, 0x0c, 0x2f, 0xef, 0x28, 0xaf, 0xcf, 0xe6, 0xfe, 0x2a, 0x66,
	0x73, 0x15, 0x1f, 0x42, 0xd0, 0x90, 0x38, 0x12, 0xba, 0x0e, 0x2d, 0x5f, 0x8f, 0xd1, 0x5d, 0x40,
	0xe5, 0x4a, 0x45, 0xc0, 0xcb, 0x3a, 0xe0, 0x1b, 0xa5, 0x27, 0x8f, 0xf8, 0x01, 0xdc, 0xb4, 0xe0,
	0x11, 0x95, 0x05, 0x65, 0x45, 0x53, 0x36, 0x4b, 0xef, 0x73, 0x2a, 0x2d, 0x56, 0x91, 0x67, 0x40,
	0x42, 0x3c, 0x8b, 0xe5, 0x08, 0x4b, 0x99, 0x8a, 0xad, 0xd5, 0x1d, 0x67, 0xbf, 0xe9, 0x6f, 0xe6,
	0xde, 0xa1, 0x71, 0xf6, 0x95, 0xcf, 0xfd, 0x1e, 0xd0, 0xe5, 0x8e, 0x40, 0x1b, 0x50, 0x3f, 0x23,
	0xf3, 0x6c, 0x4b, 0xd5, 0x10, 0xf5, 0x60, 0xf9, 0x1c, 0xc7, 0x33, 0x92, 0x6d, 0xdd, 0x2d, 0x7b,
	0xeb, 0x16, 0x04, 0x7c, 0x83, 0xfb, 0xbc, 0xf6, 0x99, 0xe3, 0x7e, 0x0b, 0x37, 0x2e, 0xf5, 0xc6,
	0x15, 0xda, 0xde, 0xa2, 0xf6, 0x42, 0x5b, 0xd8, 0x7c, 0x4b, 0xba, 0xfb, 0x4b, 0x03, 0xd6, 0x16,
	0xd6, 0x45, 0x7d, 0x68, 0x31, 0x1e, 0x10, 0x53, 0x60, 0x73, 0x6c, 0xbb, 0x95, 0x51, 0x7a, 0x2f,
	0x78, 0x40, 0x54, 0x81, 0x0f, 0x97, 0xfc, 0x26, 0xcb, 0xc6, 0x68, 0x08, 0x30, 0x9e, 0x4b, 0x22,
	0xec, 0x26, 0x79, 0xbf, 0x5a, 0x63, 0xa0, 0xb0, 0x99, 0x48, 0x6b, 0x9c, 0x1b, 0x4a, 0x85, 0x32,
	0xf9, 0xc9, 0x03, 0xa3, 0x52, 0xbf, 0x4e, 0xe5, 0x48, 0x61, 0x73, 0x15, 0x9a, 0x1b, 0x4a, 0x25,
	0x8c, 0x39, 0x96, 0x46, 0xa5, 0x71, 0x9d, 0xca, 0x33, 0x85, 0xcd, 0x55, 0xc2, 0xdc, 0x40, 0x8f,
	0x4d, 0xfb, 0x6a, 0x8d, 0x65, 0xad, 0x71, 0xbb, 0x5a, 0xa3, 0xcf, 0xe6, 0x99, 0x82, 0xea, 0x66,
	0x35, 0x74, 0x77, 0xa0, 0x99, 0xef, 0x14, 0xda, 0xcc, 0xcb, 0xe4, 0xe8, 0xd6, 0x36, 0x86, 0x7b,
	0x1b, 0x5a, 0xc5, 0x3e, 0x2c, 0x42, 0x3a, 0x39, 0x64, 0x0f, 0x5a, 0x45, 0x92, 0x68, 0xcb, 0x86,
	0xd4, 0x07, 0xb5, 0x0d, 0xc7, 0x82, 0x15, 0x59, 0x2c, 0xc2, 0x6a, 0x36, 0xec, 0x21, 0xac, 0x66,
	0x81, 0xa2, 0x3b, 0x36, 0xa8, 0xea, 0x64, 0x1a, 0xc8, 0x60, 0x05, 0x1a, 0x67, 0x94, 0x05, 0xdd,
	0x1f, 0xea, 0x00, 0xaf, 0xf4, 0x0e, 0xe8, 0xe3, 0xba, 0x09, 0x0d, 0x86, 0xa7, 0xc4, 0xb4, 0xe3,
	0xe1, 0x92, 0xaf, 0x2d, 0x25, 0x1c, 0xa8, 0xd7, 0x44, 0xf7, 0xc0, 0xfa, 0xe2, 0x2d, 0x3c, 0xc4,
	0x12, 0xbf, 0x9a, 0x27, 0xc4, 0x37, 0x10, 0xf4, 0x04, 0x3a, 0xf6, 0x33, 0x95, 0x15, 0xfc, 0x5d,
	0x9b, 0x62, 0xd6, 0x3b, 0x51, 0xee, 0x97, 0x2a, 0x34, 0xbf, 0x2d, 0xcb, 0x19, 0xd4, 0x07, 0x98,
	0x70, 0x3e, 0x12, 0x09, 0x4e, 0x05, 0xc9, 0x2a, 0xbd, 0x73, 0x99, 0xae, 0xc2, 0xf5, 0x9e, 0x72,
	0x7e, 0xa2, 0x71, 0xaa, 0xcc, 0x93, 0xdc, 0x70, 0x7f, 0x76, 0xa0, 0x55, 0xb8, 0xd4, 0xfd, 0xa8,
	0x73, 0x16, 0xa3, 0x2c, 0xb0, 0x32, 0x43, 0x7f, 0xc3, 0x78, 0x8c, 0xe4, 0x0b, 0x95, 0xab, 0x07,
	0x6f, 0x53, 0x16, 0xd0, 0xc9, 0x1b, 0xf0, 0x9a, 0xb9, 0x9d, 0x32, 0x97, 0x85, 0x7f, 0x08, 0xef,
	0x04, 0x84, 0x09, 0x62, 0xd2, 0x5d, 0xe0, 0xd4, 0xcd, 0xf5, 0xa4, 0xdd, 0x3a, 0xb7, 0x92, 0x36,
	0x00, 0x68, 0x12, 0x36, 0xe1, 0x01, 0x65, 0x51, 0xf7, 0x8f, 0x1a, 0x74, 0xec, 0x83, 0x8d, 0x1e,
	0xc1, 0x0a, 0x65, 0xc9, 0x4c, 0x8a, 0xac, 0x92, 0xbb, 0x55, 0x57, 0x80, 0x77, 0xa4, 0x61, 0xe6,
	0x95, 0xc9, 0x38, 0xe8, 0x09, 0xac, 0xf2, 0x99, 0xd4, 0xf4, 0x9a, 0xa6, 0xef, 0x55, 0xd2, 0x8f,
	0x0d, 0xce, 0xf0, 0x73, 0x16, 0x7a, 0x0f, 0xd4, 0xd3, 0x7d, 0xca, 0x03, 0x3b, 0x0d, 0x30, 0x53,
	0x2a, 0x78, 0xf7, 0x6b, 0x68, 0x5b, 0x0b, 0x5f, 0x71, 0x85, 0x1d, 0x2c, 0x5e, 0x61, 0x37, 0xaf,
	0x2e, 0x9f, 0x7d, 0x37, 0xfa, 0xd0, 0xb1, 0x83, 0xf9, 0x3f, 0x34, 0xbb, 0x13, 0xe8, 0xd8, 0xcf,
	0x28, 0xfa, 0x14, 0xb2, 0x46, 0x33, 0xef, 0x97, 0xf3, 0x9f, 0x3a, 0xd9, 0xe7, 0x4f, 0x9f, 0x0a,
	0x17, 0x9a, 0xea, 0xad, 0xb6, 0x1a, 0xa1, 0xb0, 0x07, 0x3f, 0x3a, 0xbf, 0x5d, 0x6c, 0x3b, 0xbf,
	0x5f, 0x6c, 0x3b, 0x7f, 0x5d, 0x6c, 0x3b, 0x3f, 0xfd, 0xbd, 0xbd, 0x04, 0x5b, 0x3c, 0x8d, 0x6c,
	0xd5, 0xe2, 0x4b, 0x36, 0x78, 0xab, 0xf8, 0x28, 0xe8, 0xc6, 0x17, 0x2f, 0x9d, 0xef, 0xfa, 0x11,
	0x95, 0xa7, 0xb3, 0xb1, 0x37, 0xe1, 0xd3, 0x5e, 0x3f, 0x49, 0x62, 0x1a, 0x52, 0x92, 0xf6, 0x22,
	0x7e, 0xd7, 0xfa, 0xb1, 0xe9, 0x9f, 0x5c, 0xaf, 0xea, 0x0b, 0xf7, 0x8f, 0xe3, 0x8c, 0x57, 0xb4,
	0xf1, 0xf1, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x38, 0x3a, 0x34, 0xde, 0xde, 0x0a, 0x00, 0x00,
}
