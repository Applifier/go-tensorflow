// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tensorflow/core/protobuf/config.proto

package protobuf

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	framework "github.com/Applifier/go-tensorflow/types/tensorflow/core/framework"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Optimization level
type OptimizerOptions_Level int32

const (
	// L1 is the default level.
	// Optimization performed at L1 :
	// 1. Common subexpression elimination
	// 2. Constant folding
	OptimizerOptions_L1 OptimizerOptions_Level = 0
	// No optimizations
	OptimizerOptions_L0 OptimizerOptions_Level = -1
)

var OptimizerOptions_Level_name = map[int32]string{
	0:  "L1",
	-1: "L0",
}

var OptimizerOptions_Level_value = map[string]int32{
	"L1": 0,
	"L0": -1,
}

func (x OptimizerOptions_Level) String() string {
	return proto.EnumName(OptimizerOptions_Level_name, int32(x))
}

func (OptimizerOptions_Level) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e2349c44c118036b, []int{1, 0}
}

// Control the use of the compiler/jit.  Experimental.
type OptimizerOptions_GlobalJitLevel int32

const (
	OptimizerOptions_DEFAULT OptimizerOptions_GlobalJitLevel = 0
	OptimizerOptions_OFF     OptimizerOptions_GlobalJitLevel = -1
	// The following settings turn on compilation, with higher values being
	// more aggressive.  Higher values may reduce opportunities for parallelism
	// and may use more memory.  (At present, there is no distinction, but this
	// is expected to change.)
	OptimizerOptions_ON_1 OptimizerOptions_GlobalJitLevel = 1
	OptimizerOptions_ON_2 OptimizerOptions_GlobalJitLevel = 2
)

var OptimizerOptions_GlobalJitLevel_name = map[int32]string{
	0:  "DEFAULT",
	-1: "OFF",
	1:  "ON_1",
	2:  "ON_2",
}

var OptimizerOptions_GlobalJitLevel_value = map[string]int32{
	"DEFAULT": 0,
	"OFF":     -1,
	"ON_1":    1,
	"ON_2":    2,
}

func (x OptimizerOptions_GlobalJitLevel) String() string {
	return proto.EnumName(OptimizerOptions_GlobalJitLevel_name, int32(x))
}

func (OptimizerOptions_GlobalJitLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e2349c44c118036b, []int{1, 1}
}

// TODO(pbar) Turn this into a TraceOptions proto which allows
// tracing to be controlled in a more orthogonal manner?
type RunOptions_TraceLevel int32

const (
	RunOptions_NO_TRACE       RunOptions_TraceLevel = 0
	RunOptions_SOFTWARE_TRACE RunOptions_TraceLevel = 1
	RunOptions_HARDWARE_TRACE RunOptions_TraceLevel = 2
	RunOptions_FULL_TRACE     RunOptions_TraceLevel = 3
)

var RunOptions_TraceLevel_name = map[int32]string{
	0: "NO_TRACE",
	1: "SOFTWARE_TRACE",
	2: "HARDWARE_TRACE",
	3: "FULL_TRACE",
}

var RunOptions_TraceLevel_value = map[string]int32{
	"NO_TRACE":       0,
	"SOFTWARE_TRACE": 1,
	"HARDWARE_TRACE": 2,
	"FULL_TRACE":     3,
}

func (x RunOptions_TraceLevel) String() string {
	return proto.EnumName(RunOptions_TraceLevel_name, int32(x))
}

func (RunOptions_TraceLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e2349c44c118036b, []int{7, 0}
}

type GPUOptions struct {
	// Fraction of the available GPU memory to allocate for each process.
	// 1 means to allocate all of the GPU memory, 0.5 means the process
	// allocates up to ~50% of the available GPU memory.
	//
	// GPU memory is pre-allocated unless the allow_growth option is enabled.
	//
	// If greater than 1.0, uses CUDA unified memory to potentially oversubscribe
	// the amount of memory available on the GPU device by using host memory as a
	// swap space. Accessing memory not available on the device will be
	// significantly slower as that would require memory transfer between the host
	// and the device. Options to reduce the memory requirement should be
	// considered before enabling this option as this may come with a negative
	// performance impact. Oversubscription using the unified memory requires
	// Pascal class or newer GPUs and it is currently only supported on the Linux
	// operating system. See
	// https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#um-requirements
	// for the detailed requirements.
	PerProcessGpuMemoryFraction float64 `protobuf:"fixed64,1,opt,name=per_process_gpu_memory_fraction,json=perProcessGpuMemoryFraction,proto3" json:"per_process_gpu_memory_fraction,omitempty"`
	// If true, the allocator does not pre-allocate the entire specified
	// GPU memory region, instead starting small and growing as needed.
	AllowGrowth bool `protobuf:"varint,4,opt,name=allow_growth,json=allowGrowth,proto3" json:"allow_growth,omitempty"`
	// The type of GPU allocation strategy to use.
	//
	// Allowed values:
	// "": The empty string (default) uses a system-chosen default
	//     which may change over time.
	//
	// "BFC": A "Best-fit with coalescing" algorithm, simplified from a
	//        version of dlmalloc.
	AllocatorType string `protobuf:"bytes,2,opt,name=allocator_type,json=allocatorType,proto3" json:"allocator_type,omitempty"`
	// Delay deletion of up to this many bytes to reduce the number of
	// interactions with gpu driver code.  If 0, the system chooses
	// a reasonable default (several MBs).
	DeferredDeletionBytes int64 `protobuf:"varint,3,opt,name=deferred_deletion_bytes,json=deferredDeletionBytes,proto3" json:"deferred_deletion_bytes,omitempty"`
	// A comma-separated list of GPU ids that determines the 'visible'
	// to 'virtual' mapping of GPU devices.  For example, if TensorFlow
	// can see 8 GPU devices in the process, and one wanted to map
	// visible GPU devices 5 and 3 as "/device:GPU:0", and "/device:GPU:1",
	// then one would specify this field as "5,3".  This field is similar in
	// spirit to the CUDA_VISIBLE_DEVICES environment variable, except
	// it applies to the visible GPU devices in the process.
	//
	// NOTE:
	// 1. The GPU driver provides the process with the visible GPUs
	//    in an order which is not guaranteed to have any correlation to
	//    the *physical* GPU id in the machine.  This field is used for
	//    remapping "visible" to "virtual", which means this operates only
	//    after the process starts.  Users are required to use vendor
	//    specific mechanisms (e.g., CUDA_VISIBLE_DEVICES) to control the
	//    physical to visible device mapping prior to invoking TensorFlow.
	// 2. In the code, the ids in this list are also called "platform GPU id"s,
	//    and the 'virtual' ids of GPU devices (i.e. the ids in the device
	//    name "/device:GPU:<id>") are also called "TF GPU id"s. Please
	//    refer to third_party/tensorflow/core/common_runtime/gpu/gpu_id.h
	//    for more information.
	VisibleDeviceList string `protobuf:"bytes,5,opt,name=visible_device_list,json=visibleDeviceList,proto3" json:"visible_device_list,omitempty"`
	// In the event polling loop sleep this many microseconds between
	// PollEvents calls, when the queue is not empty.  If value is not
	// set or set to 0, gets set to a non-zero default.
	PollingActiveDelayUsecs int32 `protobuf:"varint,6,opt,name=polling_active_delay_usecs,json=pollingActiveDelayUsecs,proto3" json:"polling_active_delay_usecs,omitempty"`
	// This field is deprecated and ignored.
	PollingInactiveDelayMsecs int32 `protobuf:"varint,7,opt,name=polling_inactive_delay_msecs,json=pollingInactiveDelayMsecs,proto3" json:"polling_inactive_delay_msecs,omitempty"`
	// Force all tensors to be gpu_compatible. On a GPU-enabled TensorFlow,
	// enabling this option forces all CPU tensors to be allocated with Cuda
	// pinned memory. Normally, TensorFlow will infer which tensors should be
	// allocated as the pinned memory. But in case where the inference is
	// incomplete, this option can significantly speed up the cross-device memory
	// copy performance as long as it fits the memory.
	// Note that this option is not something that should be
	// enabled by default for unknown or very large models, since all Cuda pinned
	// memory is unpageable, having too much pinned memory might negatively impact
	// the overall host system performance.
	ForceGpuCompatible bool `protobuf:"varint,8,opt,name=force_gpu_compatible,json=forceGpuCompatible,proto3" json:"force_gpu_compatible,omitempty"`
	// Everything inside experimental is subject to change and is not subject
	// to API stability guarantees in
	// https://www.tensorflow.org/guide/version_compat.
	Experimental *GPUOptions_Experimental `protobuf:"bytes,9,opt,name=experimental,proto3" json:"experimental,omitempty"`
}

func (m *GPUOptions) Reset()         { *m = GPUOptions{} }
func (m *GPUOptions) String() string { return proto.CompactTextString(m) }
func (*GPUOptions) ProtoMessage()    {}
func (*GPUOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_e2349c44c118036b, []int{0}
}
func (m *GPUOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GPUOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GPUOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GPUOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GPUOptions.Merge(m, src)
}
func (m *GPUOptions) XXX_Size() int {
	return m.Size()
}
func (m *GPUOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_GPUOptions.DiscardUnknown(m)
}

var xxx_messageInfo_GPUOptions proto.InternalMessageInfo

func (m *GPUOptions) GetPerProcessGpuMemoryFraction() float64 {
	if m != nil {
		return m.PerProcessGpuMemoryFraction
	}
	return 0
}

func (m *GPUOptions) GetAllowGrowth() bool {
	if m != nil {
		return m.AllowGrowth
	}
	return false
}

func (m *GPUOptions) GetAllocatorType() string {
	if m != nil {
		return m.AllocatorType
	}
	return ""
}

func (m *GPUOptions) GetDeferredDeletionBytes() int64 {
	if m != nil {
		return m.DeferredDeletionBytes
	}
	return 0
}

func (m *GPUOptions) GetVisibleDeviceList() string {
	if m != nil {
		return m.VisibleDeviceList
	}
	return ""
}

func (m *GPUOptions) GetPollingActiveDelayUsecs() int32 {
	if m != nil {
		return m.PollingActiveDelayUsecs
	}
	return 0
}

func (m *GPUOptions) GetPollingInactiveDelayMsecs() int32 {
	if m != nil {
		return m.PollingInactiveDelayMsecs
	}
	return 0
}

func (m *GPUOptions) GetForceGpuCompatible() bool {
	if m != nil {
		return m.ForceGpuCompatible
	}
	return false
}

func (m *GPUOptions) GetExperimental() *GPUOptions_Experimental {
	if m != nil {
		return m.Experimental
	}
	return nil
}

type GPUOptions_Experimental struct {
	// The multi virtual device settings. If empty (not set), it will create
	// single virtual device on each visible GPU, according to the settings
	// in "visible_device_list" above. Otherwise, the number of elements in the
	// list must be the same as the number of visible GPUs (after
	// "visible_device_list" filtering if it is set), and the string represented
	// device names (e.g. /device:GPU:<id>) will refer to the virtual
	// devices and have the <id> field assigned sequentially starting from 0,
	// according to the order they appear in this list and the "memory_limit"
	// list inside each element. For example,
	//   visible_device_list = "1,0"
	//   virtual_devices { memory_limit: 1GB memory_limit: 2GB }
	//   virtual_devices {}
	// will create three virtual devices as:
	//   /device:GPU:0 -> visible GPU 1 with 1GB memory
	//   /device:GPU:1 -> visible GPU 1 with 2GB memory
	//   /device:GPU:2 -> visible GPU 0 with all available memory
	//
	// NOTE:
	// 1. It's invalid to set both this and "per_process_gpu_memory_fraction"
	//    at the same time.
	// 2. Currently this setting is per-process, not per-session. Using
	//    different settings in different sessions within same process will
	//    result in undefined behavior.
	VirtualDevices []*GPUOptions_Experimental_VirtualDevices `protobuf:"bytes,1,rep,name=virtual_devices,json=virtualDevices,proto3" json:"virtual_devices,omitempty"`
	// If true, uses CUDA unified memory for memory allocations. If
	// per_process_gpu_memory_fraction option is greater than 1.0, then unified
	// memory is used regardless of the value for this field. See comments for
	// per_process_gpu_memory_fraction field for more details and requirements
	// of the unified memory. This option is useful to oversubscribe memory if
	// multiple processes are sharing a single GPU while individually using less
	// than 1.0 per process memory fraction.
	UseUnifiedMemory bool `protobuf:"varint,2,opt,name=use_unified_memory,json=useUnifiedMemory,proto3" json:"use_unified_memory,omitempty"`
	// If > 1, the number of device-to-device copy streams to create
	// for each GPUDevice.  Default value is 0, which is automatically
	// converted to 1.
	NumDevToDevCopyStreams int32 `protobuf:"varint,3,opt,name=num_dev_to_dev_copy_streams,json=numDevToDevCopyStreams,proto3" json:"num_dev_to_dev_copy_streams,omitempty"`
	// If non-empty, defines a good GPU ring order on a single worker based on
	// device interconnect.  This assumes that all workers have the same GPU
	// topology.  Specify as a comma-separated string, e.g. "3,2,1,0,7,6,5,4".
	// This ring order is used by the RingReducer implementation of
	// CollectiveReduce, and serves as an override to automatic ring order
	// generation in OrderTaskDeviceMap() during CollectiveParam resolution.
	CollectiveRingOrder string `protobuf:"bytes,4,opt,name=collective_ring_order,json=collectiveRingOrder,proto3" json:"collective_ring_order,omitempty"`
	// If true then extra work is done by GPUDevice and GPUBFCAllocator to
	// keep track of when GPU memory is freed and when kernels actually
	// complete so that we can know when a nominally free memory chunk
	// is really not subject to pending use.
	TimestampedAllocator bool `protobuf:"varint,5,opt,name=timestamped_allocator,json=timestampedAllocator,proto3" json:"timestamped_allocator,omitempty"`
	// Parameters for GPUKernelTracker.  By default no kernel tracking is done.
	// Note that timestamped_allocator is only effective if some tracking is
	// specified.
	//
	// If kernel_tracker_max_interval = n > 0, then a tracking event
	// is inserted after every n kernels without an event.
	KernelTrackerMaxInterval int32 `protobuf:"varint,7,opt,name=kernel_tracker_max_interval,json=kernelTrackerMaxInterval,proto3" json:"kernel_tracker_max_interval,omitempty"`
	// If kernel_tracker_max_bytes = n > 0, then a tracking event is
	// inserted after every series of kernels allocating a sum of
	// memory >= n.  If one kernel allocates b * n bytes, then one
	// event will be inserted after it, but it will count as b against
	// the pending limit.
	KernelTrackerMaxBytes int32 `protobuf:"varint,8,opt,name=kernel_tracker_max_bytes,json=kernelTrackerMaxBytes,proto3" json:"kernel_tracker_max_bytes,omitempty"`
	// If kernel_tracker_max_pending > 0 then no more than this many
	// tracking events can be outstanding at a time.  An attempt to
	// launch an additional kernel will stall until an event
	// completes.
	KernelTrackerMaxPending int32 `protobuf:"varint,9,opt,name=kernel_tracker_max_pending,json=kernelTrackerMaxPending,proto3" json:"kernel_tracker_max_pending,omitempty"`
}

func (m *GPUOptions_Experimental) Reset()         { *m = GPUOptions_Experimental{} }
func (m *GPUOptions_Experimental) String() string { return proto.CompactTextString(m) }
func (*GPUOptions_Experimental) ProtoMessage()    {}
func (*GPUOptions_Experimental) Descriptor() ([]byte, []int) {
	return fileDescriptor_e2349c44c118036b, []int{0, 0}
}
func (m *GPUOptions_Experimental) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GPUOptions_Experimental) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GPUOptions_Experimental.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GPUOptions_Experimental) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GPUOptions_Experimental.Merge(m, src)
}
func (m *GPUOptions_Experimental) XXX_Size() int {
	return m.Size()
}
func (m *GPUOptions_Experimental) XXX_DiscardUnknown() {
	xxx_messageInfo_GPUOptions_Experimental.DiscardUnknown(m)
}

var xxx_messageInfo_GPUOptions_Experimental proto.InternalMessageInfo

func (m *GPUOptions_Experimental) GetVirtualDevices() []*GPUOptions_Experimental_VirtualDevices {
	if m != nil {
		return m.VirtualDevices
	}
	return nil
}

func (m *GPUOptions_Experimental) GetUseUnifiedMemory() bool {
	if m != nil {
		return m.UseUnifiedMemory
	}
	return false
}

func (m *GPUOptions_Experimental) GetNumDevToDevCopyStreams() int32 {
	if m != nil {
		return m.NumDevToDevCopyStreams
	}
	return 0
}

func (m *GPUOptions_Experimental) GetCollectiveRingOrder() string {
	if m != nil {
		return m.CollectiveRingOrder
	}
	return ""
}

func (m *GPUOptions_Experimental) GetTimestampedAllocator() bool {
	if m != nil {
		return m.TimestampedAllocator
	}
	return false
}

func (m *GPUOptions_Experimental) GetKernelTrackerMaxInterval() int32 {
	if m != nil {
		return m.KernelTrackerMaxInterval
	}
	return 0
}

func (m *GPUOptions_Experimental) GetKernelTrackerMaxBytes() int32 {
	if m != nil {
		return m.KernelTrackerMaxBytes
	}
	return 0
}

func (m *GPUOptions_Experimental) GetKernelTrackerMaxPending() int32 {
	if m != nil {
		return m.KernelTrackerMaxPending
	}
	return 0
}

// Configuration for breaking down a visible GPU into multiple "virtual"
// devices.
type GPUOptions_Experimental_VirtualDevices struct {
	// Per "virtual" device memory limit, in MB. The number of elements in
	// the list is the number of virtual devices to create on the
	// corresponding visible GPU (see "virtual_devices" below).
	// If empty, it will create single virtual device taking all available
	// memory from the device.
	//
	// For the concept of "visible" and "virtual" GPU, see the comments for
	// "visible_device_list" above for more information.
	MemoryLimitMb []float32 `protobuf:"fixed32,1,rep,packed,name=memory_limit_mb,json=memoryLimitMb,proto3" json:"memory_limit_mb,omitempty"`
}

func (m *GPUOptions_Experimental_VirtualDevices) Reset() {
	*m = GPUOptions_Experimental_VirtualDevices{}
}
func (m *GPUOptions_Experimental_VirtualDevices) String() string { return proto.CompactTextString(m) }
func (*GPUOptions_Experimental_VirtualDevices) ProtoMessage()    {}
func (*GPUOptions_Experimental_VirtualDevices) Descriptor() ([]byte, []int) {
	return fileDescriptor_e2349c44c118036b, []int{0, 0, 0}
}
func (m *GPUOptions_Experimental_VirtualDevices) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GPUOptions_Experimental_VirtualDevices) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GPUOptions_Experimental_VirtualDevices.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GPUOptions_Experimental_VirtualDevices) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GPUOptions_Experimental_VirtualDevices.Merge(m, src)
}
func (m *GPUOptions_Experimental_VirtualDevices) XXX_Size() int {
	return m.Size()
}
func (m *GPUOptions_Experimental_VirtualDevices) XXX_DiscardUnknown() {
	xxx_messageInfo_GPUOptions_Experimental_VirtualDevices.DiscardUnknown(m)
}

var xxx_messageInfo_GPUOptions_Experimental_VirtualDevices proto.InternalMessageInfo

func (m *GPUOptions_Experimental_VirtualDevices) GetMemoryLimitMb() []float32 {
	if m != nil {
		return m.MemoryLimitMb
	}
	return nil
}

// Options passed to the graph optimizer
type OptimizerOptions struct {
	// If true, optimize the graph using common subexpression elimination.
	DoCommonSubexpressionElimination bool `protobuf:"varint,1,opt,name=do_common_subexpression_elimination,json=doCommonSubexpressionElimination,proto3" json:"do_common_subexpression_elimination,omitempty"`
	// If true, perform constant folding optimization on the graph.
	DoConstantFolding bool `protobuf:"varint,2,opt,name=do_constant_folding,json=doConstantFolding,proto3" json:"do_constant_folding,omitempty"`
	// Constant folding optimization replaces tensors whose values can be
	// predetermined, with constant nodes. To avoid inserting too large constants,
	// the size of each constant created can be limited. If this value is zero, a
	// default limit of 10 MiB will be applied. If constant folding optimization
	// is disabled, this value is ignored.
	MaxFoldedConstantInBytes int64 `protobuf:"varint,6,opt,name=max_folded_constant_in_bytes,json=maxFoldedConstantInBytes,proto3" json:"max_folded_constant_in_bytes,omitempty"`
	// If true, perform function inlining on the graph.
	DoFunctionInlining bool `protobuf:"varint,4,opt,name=do_function_inlining,json=doFunctionInlining,proto3" json:"do_function_inlining,omitempty"`
	// Overall optimization level. The actual optimizations applied will be the
	// logical OR of the flags that this level implies and any flags already set.
	OptLevel       OptimizerOptions_Level          `protobuf:"varint,3,opt,name=opt_level,json=optLevel,proto3,enum=tensorflow.OptimizerOptions_Level" json:"opt_level,omitempty"`
	GlobalJitLevel OptimizerOptions_GlobalJitLevel `protobuf:"varint,5,opt,name=global_jit_level,json=globalJitLevel,proto3,enum=tensorflow.OptimizerOptions_GlobalJitLevel" json:"global_jit_level,omitempty"`
}

func (m *OptimizerOptions) Reset()         { *m = OptimizerOptions{} }
func (m *OptimizerOptions) String() string { return proto.CompactTextString(m) }
func (*OptimizerOptions) ProtoMessage()    {}
func (*OptimizerOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_e2349c44c118036b, []int{1}
}
func (m *OptimizerOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OptimizerOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OptimizerOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OptimizerOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OptimizerOptions.Merge(m, src)
}
func (m *OptimizerOptions) XXX_Size() int {
	return m.Size()
}
func (m *OptimizerOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_OptimizerOptions.DiscardUnknown(m)
}

var xxx_messageInfo_OptimizerOptions proto.InternalMessageInfo

func (m *OptimizerOptions) GetDoCommonSubexpressionElimination() bool {
	if m != nil {
		return m.DoCommonSubexpressionElimination
	}
	return false
}

func (m *OptimizerOptions) GetDoConstantFolding() bool {
	if m != nil {
		return m.DoConstantFolding
	}
	return false
}

func (m *OptimizerOptions) GetMaxFoldedConstantInBytes() int64 {
	if m != nil {
		return m.MaxFoldedConstantInBytes
	}
	return 0
}

func (m *OptimizerOptions) GetDoFunctionInlining() bool {
	if m != nil {
		return m.DoFunctionInlining
	}
	return false
}

func (m *OptimizerOptions) GetOptLevel() OptimizerOptions_Level {
	if m != nil {
		return m.OptLevel
	}
	return OptimizerOptions_L1
}

func (m *OptimizerOptions) GetGlobalJitLevel() OptimizerOptions_GlobalJitLevel {
	if m != nil {
		return m.GlobalJitLevel
	}
	return OptimizerOptions_DEFAULT
}

type GraphOptions struct {
	// If true, use control flow to schedule the activation of Recv nodes.
	// (Currently ignored.)
	EnableRecvScheduling bool `protobuf:"varint,2,opt,name=enable_recv_scheduling,json=enableRecvScheduling,proto3" json:"enable_recv_scheduling,omitempty"`
	// Options controlling how graph is optimized.
	OptimizerOptions *OptimizerOptions `protobuf:"bytes,3,opt,name=optimizer_options,json=optimizerOptions,proto3" json:"optimizer_options,omitempty"`
	// The number of steps to run before returning a cost model detailing
	// the memory usage and performance of each node of the graph. 0 means
	// no cost model.
	BuildCostModel int64 `protobuf:"varint,4,opt,name=build_cost_model,json=buildCostModel,proto3" json:"build_cost_model,omitempty"`
	// The number of steps to skip before collecting statistics for the
	// cost model.
	BuildCostModelAfter int64 `protobuf:"varint,9,opt,name=build_cost_model_after,json=buildCostModelAfter,proto3" json:"build_cost_model_after,omitempty"`
	// Annotate each Node with Op output shape data, to the extent it can
	// be statically inferred.
	InferShapes bool `protobuf:"varint,5,opt,name=infer_shapes,json=inferShapes,proto3" json:"infer_shapes,omitempty"`
	// Only place the subgraphs that are run, rather than the entire graph.
	//
	// This is useful for interactive graph building, where one might
	// produce graphs that cannot be placed during the debugging
	// process.  In particular, it allows the client to continue work in
	// a session after adding a node to a graph whose placement
	// constraints are unsatisfiable.
	PlacePrunedGraph bool `protobuf:"varint,6,opt,name=place_pruned_graph,json=placePrunedGraph,proto3" json:"place_pruned_graph,omitempty"`
	// If true, transfer float values between processes as bfloat16.
	EnableBfloat16Sendrecv bool `protobuf:"varint,7,opt,name=enable_bfloat16_sendrecv,json=enableBfloat16Sendrecv,proto3" json:"enable_bfloat16_sendrecv,omitempty"`
	// If > 0, record a timeline every this many steps.
	// EXPERIMENTAL: This currently has no effect in MasterSession.
	TimelineStep int32 `protobuf:"varint,8,opt,name=timeline_step,json=timelineStep,proto3" json:"timeline_step,omitempty"`
	// Options that control the type and amount of graph rewriting.
	// Not currently configurable via the public Python API (i.e. there is no API
	// stability guarantee if you import RewriterConfig explicitly).
	RewriteOptions *RewriterConfig `protobuf:"bytes,10,opt,name=rewrite_options,json=rewriteOptions,proto3" json:"rewrite_options,omitempty"`
}

func (m *GraphOptions) Reset()         { *m = GraphOptions{} }
func (m *GraphOptions) String() string { return proto.CompactTextString(m) }
func (*GraphOptions) ProtoMessage()    {}
func (*GraphOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_e2349c44c118036b, []int{2}
}
func (m *GraphOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GraphOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GraphOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GraphOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GraphOptions.Merge(m, src)
}
func (m *GraphOptions) XXX_Size() int {
	return m.Size()
}
func (m *GraphOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_GraphOptions.DiscardUnknown(m)
}

var xxx_messageInfo_GraphOptions proto.InternalMessageInfo

func (m *GraphOptions) GetEnableRecvScheduling() bool {
	if m != nil {
		return m.EnableRecvScheduling
	}
	return false
}

func (m *GraphOptions) GetOptimizerOptions() *OptimizerOptions {
	if m != nil {
		return m.OptimizerOptions
	}
	return nil
}

func (m *GraphOptions) GetBuildCostModel() int64 {
	if m != nil {
		return m.BuildCostModel
	}
	return 0
}

func (m *GraphOptions) GetBuildCostModelAfter() int64 {
	if m != nil {
		return m.BuildCostModelAfter
	}
	return 0
}

func (m *GraphOptions) GetInferShapes() bool {
	if m != nil {
		return m.InferShapes
	}
	return false
}

func (m *GraphOptions) GetPlacePrunedGraph() bool {
	if m != nil {
		return m.PlacePrunedGraph
	}
	return false
}

func (m *GraphOptions) GetEnableBfloat16Sendrecv() bool {
	if m != nil {
		return m.EnableBfloat16Sendrecv
	}
	return false
}

func (m *GraphOptions) GetTimelineStep() int32 {
	if m != nil {
		return m.TimelineStep
	}
	return 0
}

func (m *GraphOptions) GetRewriteOptions() *RewriterConfig {
	if m != nil {
		return m.RewriteOptions
	}
	return nil
}

type ThreadPoolOptionProto struct {
	// The number of threads in the pool.
	//
	// 0 means the system picks a value based on where this option proto is used
	// (see the declaration of the specific field for more info).
	NumThreads int32 `protobuf:"varint,1,opt,name=num_threads,json=numThreads,proto3" json:"num_threads,omitempty"`
	// The global name of the threadpool.
	//
	// If empty, then the threadpool is made and used according to the scope it's
	// in - e.g., for a session threadpool, it is used by that session only.
	//
	// If non-empty, then:
	// - a global threadpool associated with this name is looked
	//   up or created. This allows, for example, sharing one threadpool across
	//   many sessions (e.g., like the default behavior, if
	//   inter_op_parallelism_threads is not configured), but still partitioning
	//   into a large and small pool.
	// - if the threadpool for this global_name already exists, then it is an
	//   error if the existing pool was created using a different num_threads
	//   value as is specified on this call.
	// - threadpools created this way are never garbage collected.
	GlobalName string `protobuf:"bytes,2,opt,name=global_name,json=globalName,proto3" json:"global_name,omitempty"`
}

func (m *ThreadPoolOptionProto) Reset()         { *m = ThreadPoolOptionProto{} }
func (m *ThreadPoolOptionProto) String() string { return proto.CompactTextString(m) }
func (*ThreadPoolOptionProto) ProtoMessage()    {}
func (*ThreadPoolOptionProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_e2349c44c118036b, []int{3}
}
func (m *ThreadPoolOptionProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ThreadPoolOptionProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ThreadPoolOptionProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ThreadPoolOptionProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThreadPoolOptionProto.Merge(m, src)
}
func (m *ThreadPoolOptionProto) XXX_Size() int {
	return m.Size()
}
func (m *ThreadPoolOptionProto) XXX_DiscardUnknown() {
	xxx_messageInfo_ThreadPoolOptionProto.DiscardUnknown(m)
}

var xxx_messageInfo_ThreadPoolOptionProto proto.InternalMessageInfo

func (m *ThreadPoolOptionProto) GetNumThreads() int32 {
	if m != nil {
		return m.NumThreads
	}
	return 0
}

func (m *ThreadPoolOptionProto) GetGlobalName() string {
	if m != nil {
		return m.GlobalName
	}
	return ""
}

type RPCOptions struct {
	// If true, always use RPC to contact the session target.
	//
	// If false (the default option), TensorFlow may use an optimized
	// transport for client-master communication that avoids the RPC
	// stack. This option is primarily for used testing the RPC stack.
	UseRpcForInprocessMaster bool `protobuf:"varint,1,opt,name=use_rpc_for_inprocess_master,json=useRpcForInprocessMaster,proto3" json:"use_rpc_for_inprocess_master,omitempty"`
	// The compression algorithm to be used. One of "deflate", "gzip".
	CompressionAlgorithm string `protobuf:"bytes,2,opt,name=compression_algorithm,json=compressionAlgorithm,proto3" json:"compression_algorithm,omitempty"`
	// If compression_algorithm is set, the compression level to be used.
	// From 0 (no compression), up to 3.
	CompressionLevel int32 `protobuf:"varint,3,opt,name=compression_level,json=compressionLevel,proto3" json:"compression_level,omitempty"`
	// Setting cache_rpc_response to true will enable sender side caching of
	// response for RecvTensorAsync and RecvBufAsync to allow receiver to retry
	// requests . This is only necessary when the network fabric is experiencing a
	// significant error rate.  Without it we'll fail a step on an network error,
	// while with it we'll be able to complete long steps (like complex
	// initializations) in the face of some network errors during RecvTensor.
	CacheRpcResponse bool `protobuf:"varint,4,opt,name=cache_rpc_response,json=cacheRpcResponse,proto3" json:"cache_rpc_response,omitempty"`
	// Disables TCP connection sharing when opening a new RPC channel.
	DisableSessionConnectionSharing bool `protobuf:"varint,5,opt,name=disable_session_connection_sharing,json=disableSessionConnectionSharing,proto3" json:"disable_session_connection_sharing,omitempty"`
}

func (m *RPCOptions) Reset()         { *m = RPCOptions{} }
func (m *RPCOptions) String() string { return proto.CompactTextString(m) }
func (*RPCOptions) ProtoMessage()    {}
func (*RPCOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_e2349c44c118036b, []int{4}
}
func (m *RPCOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RPCOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RPCOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RPCOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RPCOptions.Merge(m, src)
}
func (m *RPCOptions) XXX_Size() int {
	return m.Size()
}
func (m *RPCOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_RPCOptions.DiscardUnknown(m)
}

var xxx_messageInfo_RPCOptions proto.InternalMessageInfo

func (m *RPCOptions) GetUseRpcForInprocessMaster() bool {
	if m != nil {
		return m.UseRpcForInprocessMaster
	}
	return false
}

func (m *RPCOptions) GetCompressionAlgorithm() string {
	if m != nil {
		return m.CompressionAlgorithm
	}
	return ""
}

func (m *RPCOptions) GetCompressionLevel() int32 {
	if m != nil {
		return m.CompressionLevel
	}
	return 0
}

func (m *RPCOptions) GetCacheRpcResponse() bool {
	if m != nil {
		return m.CacheRpcResponse
	}
	return false
}

func (m *RPCOptions) GetDisableSessionConnectionSharing() bool {
	if m != nil {
		return m.DisableSessionConnectionSharing
	}
	return false
}

// Metadata about the session.
//
// This can be used by the runtime and the Ops for debugging, monitoring, etc.
//
// The (name, version) tuple is expected to be a unique identifier for
// sessions within the same process.
//
// NOTE: This is currently used and propagated only by the direct session.
type SessionMetadata struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The version is optional. If set, needs to be >= 0.
	Version int64 `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *SessionMetadata) Reset()         { *m = SessionMetadata{} }
func (m *SessionMetadata) String() string { return proto.CompactTextString(m) }
func (*SessionMetadata) ProtoMessage()    {}
func (*SessionMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_e2349c44c118036b, []int{5}
}
func (m *SessionMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionMetadata.Merge(m, src)
}
func (m *SessionMetadata) XXX_Size() int {
	return m.Size()
}
func (m *SessionMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_SessionMetadata proto.InternalMessageInfo

func (m *SessionMetadata) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SessionMetadata) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

// Session configuration parameters.
// The system picks appropriate values for fields that are not set.
type ConfigProto struct {
	// Map from device type name (e.g., "CPU" or "GPU" ) to maximum
	// number of devices of that type to use.  If a particular device
	// type is not found in the map, the system picks an appropriate
	// number.
	DeviceCount map[string]int32 `protobuf:"bytes,1,rep,name=device_count,json=deviceCount,proto3" json:"device_count,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// The execution of an individual op (for some op types) can be
	// parallelized on a pool of intra_op_parallelism_threads.
	// 0 means the system picks an appropriate number.
	//
	// If you create an ordinary session, e.g., from Python or C++,
	// then there is exactly one intra op thread pool per process.
	// The first session created determines the number of threads in this pool.
	// All subsequent sessions reuse/share this one global pool.
	//
	// There are notable exceptions to the default behavior describe above:
	// 1. There is an environment variable  for overriding this thread pool,
	//    named TF_OVERRIDE_GLOBAL_THREADPOOL.
	// 2. When connecting to a server, such as a remote `tf.train.Server`
	//    instance, then this option will be ignored altogether.
	IntraOpParallelismThreads int32 `protobuf:"varint,2,opt,name=intra_op_parallelism_threads,json=intraOpParallelismThreads,proto3" json:"intra_op_parallelism_threads,omitempty"`
	// Nodes that perform blocking operations are enqueued on a pool of
	// inter_op_parallelism_threads available in each process.
	//
	// 0 means the system picks an appropriate number.
	// Negative means all operations are performed in caller's thread.
	//
	// Note that the first Session created in the process sets the
	// number of threads for all future sessions unless use_per_session_threads is
	// true or session_inter_op_thread_pool is configured.
	InterOpParallelismThreads int32 `protobuf:"varint,5,opt,name=inter_op_parallelism_threads,json=interOpParallelismThreads,proto3" json:"inter_op_parallelism_threads,omitempty"`
	// If true, use a new set of threads for this session rather than the global
	// pool of threads. Only supported by direct sessions.
	//
	// If false, use the global threads created by the first session, or the
	// per-session thread pools configured by session_inter_op_thread_pool.
	//
	// This option is deprecated. The same effect can be achieved by setting
	// session_inter_op_thread_pool to have one element, whose num_threads equals
	// inter_op_parallelism_threads.
	UsePerSessionThreads bool `protobuf:"varint,9,opt,name=use_per_session_threads,json=usePerSessionThreads,proto3" json:"use_per_session_threads,omitempty"`
	// This option is experimental - it may be replaced with a different mechanism
	// in the future.
	//
	// Configures session thread pools. If this is configured, then RunOptions for
	// a Run call can select the thread pool to use.
	//
	// The intended use is for when some session invocations need to run in a
	// background pool limited to a small number of threads:
	// - For example, a session may be configured to have one large pool (for
	// regular compute) and one small pool (for periodic, low priority work);
	// using the small pool is currently the mechanism for limiting the inter-op
	// parallelism of the low priority work.  Note that it does not limit the
	// parallelism of work spawned by a single op kernel implementation.
	// - Using this setting is normally not needed in training, but may help some
	// serving use cases.
	// - It is also generally recommended to set the global_name field of this
	// proto, to avoid creating multiple large pools. It is typically better to
	// run the non-low-priority work, even across sessions, in a single large
	// pool.
	SessionInterOpThreadPool []*ThreadPoolOptionProto `protobuf:"bytes,12,rep,name=session_inter_op_thread_pool,json=sessionInterOpThreadPool,proto3" json:"session_inter_op_thread_pool,omitempty"`
	// Assignment of Nodes to Devices is recomputed every placement_period
	// steps until the system warms up (at which point the recomputation
	// typically slows down automatically).
	PlacementPeriod int32 `protobuf:"varint,3,opt,name=placement_period,json=placementPeriod,proto3" json:"placement_period,omitempty"`
	// When any filters are present sessions will ignore all devices which do not
	// match the filters. Each filter can be partially specified, e.g. "/job:ps"
	// "/job:worker/replica:3", etc.
	DeviceFilters []string `protobuf:"bytes,4,rep,name=device_filters,json=deviceFilters,proto3" json:"device_filters,omitempty"`
	// Options that apply to all GPUs.
	GpuOptions *GPUOptions `protobuf:"bytes,6,opt,name=gpu_options,json=gpuOptions,proto3" json:"gpu_options,omitempty"`
	// Whether soft placement is allowed. If allow_soft_placement is true,
	// an op will be placed on CPU if
	//   1. there's no GPU implementation for the OP
	// or
	//   2. no GPU devices are known or registered
	// or
	//   3. need to co-locate with reftype input(s) which are from CPU.
	AllowSoftPlacement bool `protobuf:"varint,7,opt,name=allow_soft_placement,json=allowSoftPlacement,proto3" json:"allow_soft_placement,omitempty"`
	// Whether device placements should be logged.
	LogDevicePlacement bool `protobuf:"varint,8,opt,name=log_device_placement,json=logDevicePlacement,proto3" json:"log_device_placement,omitempty"`
	// Options that apply to all graphs.
	GraphOptions *GraphOptions `protobuf:"bytes,10,opt,name=graph_options,json=graphOptions,proto3" json:"graph_options,omitempty"`
	// Global timeout for all blocking operations in this session.  If non-zero,
	// and not overridden on a per-operation basis, this value will be used as the
	// deadline for all blocking operations.
	OperationTimeoutInMs int64 `protobuf:"varint,11,opt,name=operation_timeout_in_ms,json=operationTimeoutInMs,proto3" json:"operation_timeout_in_ms,omitempty"`
	// Options that apply when this session uses the distributed runtime.
	RpcOptions *RPCOptions `protobuf:"bytes,13,opt,name=rpc_options,json=rpcOptions,proto3" json:"rpc_options,omitempty"`
	// Optional list of all workers to use in this session.
	ClusterDef *ClusterDef `protobuf:"bytes,14,opt,name=cluster_def,json=clusterDef,proto3" json:"cluster_def,omitempty"`
	// If true, any resources such as Variables used in the session will not be
	// shared with other sessions. However, when clusterspec propagation is
	// enabled, this field is ignored and sessions are always isolated.
	IsolateSessionState bool                      `protobuf:"varint,15,opt,name=isolate_session_state,json=isolateSessionState,proto3" json:"isolate_session_state,omitempty"`
	Experimental        *ConfigProto_Experimental `protobuf:"bytes,16,opt,name=experimental,proto3" json:"experimental,omitempty"`
}

func (m *ConfigProto) Reset()         { *m = ConfigProto{} }
func (m *ConfigProto) String() string { return proto.CompactTextString(m) }
func (*ConfigProto) ProtoMessage()    {}
func (*ConfigProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_e2349c44c118036b, []int{6}
}
func (m *ConfigProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigProto.Merge(m, src)
}
func (m *ConfigProto) XXX_Size() int {
	return m.Size()
}
func (m *ConfigProto) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigProto.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigProto proto.InternalMessageInfo

func (m *ConfigProto) GetDeviceCount() map[string]int32 {
	if m != nil {
		return m.DeviceCount
	}
	return nil
}

func (m *ConfigProto) GetIntraOpParallelismThreads() int32 {
	if m != nil {
		return m.IntraOpParallelismThreads
	}
	return 0
}

func (m *ConfigProto) GetInterOpParallelismThreads() int32 {
	if m != nil {
		return m.InterOpParallelismThreads
	}
	return 0
}

func (m *ConfigProto) GetUsePerSessionThreads() bool {
	if m != nil {
		return m.UsePerSessionThreads
	}
	return false
}

func (m *ConfigProto) GetSessionInterOpThreadPool() []*ThreadPoolOptionProto {
	if m != nil {
		return m.SessionInterOpThreadPool
	}
	return nil
}

func (m *ConfigProto) GetPlacementPeriod() int32 {
	if m != nil {
		return m.PlacementPeriod
	}
	return 0
}

func (m *ConfigProto) GetDeviceFilters() []string {
	if m != nil {
		return m.DeviceFilters
	}
	return nil
}

func (m *ConfigProto) GetGpuOptions() *GPUOptions {
	if m != nil {
		return m.GpuOptions
	}
	return nil
}

func (m *ConfigProto) GetAllowSoftPlacement() bool {
	if m != nil {
		return m.AllowSoftPlacement
	}
	return false
}

func (m *ConfigProto) GetLogDevicePlacement() bool {
	if m != nil {
		return m.LogDevicePlacement
	}
	return false
}

func (m *ConfigProto) GetGraphOptions() *GraphOptions {
	if m != nil {
		return m.GraphOptions
	}
	return nil
}

func (m *ConfigProto) GetOperationTimeoutInMs() int64 {
	if m != nil {
		return m.OperationTimeoutInMs
	}
	return 0
}

func (m *ConfigProto) GetRpcOptions() *RPCOptions {
	if m != nil {
		return m.RpcOptions
	}
	return nil
}

func (m *ConfigProto) GetClusterDef() *ClusterDef {
	if m != nil {
		return m.ClusterDef
	}
	return nil
}

func (m *ConfigProto) GetIsolateSessionState() bool {
	if m != nil {
		return m.IsolateSessionState
	}
	return false
}

func (m *ConfigProto) GetExperimental() *ConfigProto_Experimental {
	if m != nil {
		return m.Experimental
	}
	return nil
}

// Everything inside Experimental is subject to change and is not subject
// to API stability guarantees in
// https://www.tensorflow.org/guide/version_compat.
type ConfigProto_Experimental struct {
	// Task name for group resolution.
	CollectiveGroupLeader string `protobuf:"bytes,1,opt,name=collective_group_leader,json=collectiveGroupLeader,proto3" json:"collective_group_leader,omitempty"`
	// Which executor to use, the default executor will be used
	// if it is an empty string or "DEFAULT"
	ExecutorType string `protobuf:"bytes,3,opt,name=executor_type,json=executorType,proto3" json:"executor_type,omitempty"`
	// Guidance to formatting of large RecvBuf fields for transfer.
	// Any positive value sets the max chunk size.  0 defaults to 4096.
	// Any negative value indicates no max, i.e. one chunk only.
	RecvBufMaxChunk int32 `protobuf:"varint,4,opt,name=recv_buf_max_chunk,json=recvBufMaxChunk,proto3" json:"recv_buf_max_chunk,omitempty"`
	// If true, and supported by the platform, the runtime will attempt to
	// use NUMA affinity where applicable.  One consequence will be the
	// existence of as many CPU devices as there are available NUMA nodes.
	UseNumaAffinity bool `protobuf:"varint,5,opt,name=use_numa_affinity,json=useNumaAffinity,proto3" json:"use_numa_affinity,omitempty"`
	// If true, make collective op execution order sequential and deterministic
	// for potentially concurrent collective instances.
	CollectiveDeterministicSequentialExecution bool `protobuf:"varint,6,opt,name=collective_deterministic_sequential_execution,json=collectiveDeterministicSequentialExecution,proto3" json:"collective_deterministic_sequential_execution,omitempty"`
	// If true, use NCCL for CollectiveOps.  This feature is highly
	// experimental.
	CollectiveNccl bool `protobuf:"varint,7,opt,name=collective_nccl,json=collectiveNccl,proto3" json:"collective_nccl,omitempty"`
	// In the following, session state means the value of a variable, elements
	// in a hash table, or any other resource, accessible by worker sessions
	// held by a TF server.
	//
	// When ClusterSpec propagation is enabled, the value of
	// isolate_session_state is ignored when deciding whether to share session
	// states in a TF server (for backwards compatibility reasons).
	// - If share_session_state_in_clusterspec_propagation is true, the session
	// states are shared.
	// - If share_session_state_in_clusterspec_propagation is false, session
	// states are isolated.
	//
	// When clusterspec propagation is not used, the value of
	// share_session_state_in_clusterspec_propagation is ignored when deciding
	// whether to share session states in a TF server.
	// - If isolate_session_state is true, session states are isolated.
	// - If isolate_session_state is false, session states are shared.
	//
	// TODO(b/129330037): Add a single API that consistently treats
	// isolate_session_state and ClusterSpec propagation.
	ShareSessionStateInClusterspecPropagation bool `protobuf:"varint,8,opt,name=share_session_state_in_clusterspec_propagation,json=shareSessionStateInClusterspecPropagation,proto3" json:"share_session_state_in_clusterspec_propagation,omitempty"`
	// If using a direct session, disable spinning while waiting for work in
	// the thread pool. This may result in higher latency for completing ops,
	// but in the case where there is a lot of spinning may result in lower
	// CPU usage.
	DisableThreadSpinning bool `protobuf:"varint,9,opt,name=disable_thread_spinning,json=disableThreadSpinning,proto3" json:"disable_thread_spinning,omitempty"`
	// When true, WorkerSessions are created with device attributes from the
	// full cluster.
	// This is helpful when a worker wants to partition a graph
	// (for example during a PartitionedCallOp).
	ShareClusterDevicesInSession bool `protobuf:"varint,10,opt,name=share_cluster_devices_in_session,json=shareClusterDevicesInSession,proto3" json:"share_cluster_devices_in_session,omitempty"`
	// Metadata about the session.
	//
	// If set, this can be used by the runtime and the Ops for debugging,
	// monitoring, etc.
	//
	// NOTE: This is currently used and propagated only by the direct session.
	SessionMetadata *SessionMetadata `protobuf:"bytes,11,opt,name=session_metadata,json=sessionMetadata,proto3" json:"session_metadata,omitempty"`
	// If true, the session may treat the graph as being static for optimization
	// purposes.
	//
	// If this option is set to true when a session is created, the full
	// GraphDef must be passed in a single call to Session::Create(), and
	// Session::Extend() may not be supported.
	OptimizeForStaticGraph bool `protobuf:"varint,12,opt,name=optimize_for_static_graph,json=optimizeForStaticGraph,proto3" json:"optimize_for_static_graph,omitempty"`
	// Whether to enable the MLIR-based TF->XLA bridge.
	//
	// This is a replacement to the existing bridge, and not ready for
	// production usage yet.
	// If this option is set to true when a session is created, MLIR is used to
	// perform the set of graph transformations to put the graph in a form that
	// can be executed with delegation of some computations to an accelerator.
	// This builds on the model of XLA where a subset of the graph is
	// encapsulated and attached to a "compile" operation, whose result is fed
	// to an "execute" operation. The kernel for these operations is responsible
	// to lower the encapsulated graph to a particular device.
	EnableMlirBridge bool `protobuf:"varint,13,opt,name=enable_mlir_bridge,json=enableMlirBridge,proto3" json:"enable_mlir_bridge,omitempty"`
	// If true, the session will not store an additional copy of the graph for
	// each subgraph.
	//
	// If this option is set to true when a session is created, the
	// `RunOptions.output_partition_graphs` options must not be set.
	DisableOutputPartitionGraphs bool `protobuf:"varint,14,opt,name=disable_output_partition_graphs,json=disableOutputPartitionGraphs,proto3" json:"disable_output_partition_graphs,omitempty"`
	// Minimum number of batches run through the XLA graph before XLA fusion
	// autotuner is enabled. Default value of zero disables the autotuner.
	//
	// The XLA fusion autotuner can improve performance by executing a heuristic
	// search on the compiler parameters.
	XlaFusionAutotunerThresh int64 `protobuf:"varint,15,opt,name=xla_fusion_autotuner_thresh,json=xlaFusionAutotunerThresh,proto3" json:"xla_fusion_autotuner_thresh,omitempty"`
}

func (m *ConfigProto_Experimental) Reset()         { *m = ConfigProto_Experimental{} }
func (m *ConfigProto_Experimental) String() string { return proto.CompactTextString(m) }
func (*ConfigProto_Experimental) ProtoMessage()    {}
func (*ConfigProto_Experimental) Descriptor() ([]byte, []int) {
	return fileDescriptor_e2349c44c118036b, []int{6, 1}
}
func (m *ConfigProto_Experimental) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigProto_Experimental) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigProto_Experimental.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigProto_Experimental) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigProto_Experimental.Merge(m, src)
}
func (m *ConfigProto_Experimental) XXX_Size() int {
	return m.Size()
}
func (m *ConfigProto_Experimental) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigProto_Experimental.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigProto_Experimental proto.InternalMessageInfo

func (m *ConfigProto_Experimental) GetCollectiveGroupLeader() string {
	if m != nil {
		return m.CollectiveGroupLeader
	}
	return ""
}

func (m *ConfigProto_Experimental) GetExecutorType() string {
	if m != nil {
		return m.ExecutorType
	}
	return ""
}

func (m *ConfigProto_Experimental) GetRecvBufMaxChunk() int32 {
	if m != nil {
		return m.RecvBufMaxChunk
	}
	return 0
}

func (m *ConfigProto_Experimental) GetUseNumaAffinity() bool {
	if m != nil {
		return m.UseNumaAffinity
	}
	return false
}

func (m *ConfigProto_Experimental) GetCollectiveDeterministicSequentialExecution() bool {
	if m != nil {
		return m.CollectiveDeterministicSequentialExecution
	}
	return false
}

func (m *ConfigProto_Experimental) GetCollectiveNccl() bool {
	if m != nil {
		return m.CollectiveNccl
	}
	return false
}

func (m *ConfigProto_Experimental) GetShareSessionStateInClusterspecPropagation() bool {
	if m != nil {
		return m.ShareSessionStateInClusterspecPropagation
	}
	return false
}

func (m *ConfigProto_Experimental) GetDisableThreadSpinning() bool {
	if m != nil {
		return m.DisableThreadSpinning
	}
	return false
}

func (m *ConfigProto_Experimental) GetShareClusterDevicesInSession() bool {
	if m != nil {
		return m.ShareClusterDevicesInSession
	}
	return false
}

func (m *ConfigProto_Experimental) GetSessionMetadata() *SessionMetadata {
	if m != nil {
		return m.SessionMetadata
	}
	return nil
}

func (m *ConfigProto_Experimental) GetOptimizeForStaticGraph() bool {
	if m != nil {
		return m.OptimizeForStaticGraph
	}
	return false
}

func (m *ConfigProto_Experimental) GetEnableMlirBridge() bool {
	if m != nil {
		return m.EnableMlirBridge
	}
	return false
}

func (m *ConfigProto_Experimental) GetDisableOutputPartitionGraphs() bool {
	if m != nil {
		return m.DisableOutputPartitionGraphs
	}
	return false
}

func (m *ConfigProto_Experimental) GetXlaFusionAutotunerThresh() int64 {
	if m != nil {
		return m.XlaFusionAutotunerThresh
	}
	return 0
}

// Options for a single Run() call.
type RunOptions struct {
	TraceLevel RunOptions_TraceLevel `protobuf:"varint,1,opt,name=trace_level,json=traceLevel,proto3,enum=tensorflow.RunOptions_TraceLevel" json:"trace_level,omitempty"`
	// Time to wait for operation to complete in milliseconds.
	TimeoutInMs int64 `protobuf:"varint,2,opt,name=timeout_in_ms,json=timeoutInMs,proto3" json:"timeout_in_ms,omitempty"`
	// The thread pool to use, if session_inter_op_thread_pool is configured.
	// To use the caller thread set this to -1 - this uses the caller thread
	// to execute Session::Run() and thus avoids a context switch. Using the
	// caller thread to execute Session::Run() should be done ONLY for simple
	// graphs, where the overhead of an additional context switch is
	// comparable with the overhead of Session::Run().
	InterOpThreadPool int32 `protobuf:"varint,3,opt,name=inter_op_thread_pool,json=interOpThreadPool,proto3" json:"inter_op_thread_pool,omitempty"`
	// Whether the partition graph(s) executed by the executor(s) should be
	// outputted via RunMetadata.
	OutputPartitionGraphs bool `protobuf:"varint,5,opt,name=output_partition_graphs,json=outputPartitionGraphs,proto3" json:"output_partition_graphs,omitempty"`
	// EXPERIMENTAL.  Options used to initialize DebuggerState, if enabled.
	DebugOptions *DebugOptions `protobuf:"bytes,6,opt,name=debug_options,json=debugOptions,proto3" json:"debug_options,omitempty"`
	// When enabled, causes tensor allocation information to be included in
	// the error message when the Run() call fails because the allocator ran
	// out of memory (OOM).
	//
	// Enabling this option can slow down the Run() call.
	ReportTensorAllocationsUponOom bool                     `protobuf:"varint,7,opt,name=report_tensor_allocations_upon_oom,json=reportTensorAllocationsUponOom,proto3" json:"report_tensor_allocations_upon_oom,omitempty"`
	Experimental                   *RunOptions_Experimental `protobuf:"bytes,8,opt,name=experimental,proto3" json:"experimental,omitempty"`
}

func (m *RunOptions) Reset()         { *m = RunOptions{} }
func (m *RunOptions) String() string { return proto.CompactTextString(m) }
func (*RunOptions) ProtoMessage()    {}
func (*RunOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_e2349c44c118036b, []int{7}
}
func (m *RunOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RunOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RunOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunOptions.Merge(m, src)
}
func (m *RunOptions) XXX_Size() int {
	return m.Size()
}
func (m *RunOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_RunOptions.DiscardUnknown(m)
}

var xxx_messageInfo_RunOptions proto.InternalMessageInfo

func (m *RunOptions) GetTraceLevel() RunOptions_TraceLevel {
	if m != nil {
		return m.TraceLevel
	}
	return RunOptions_NO_TRACE
}

func (m *RunOptions) GetTimeoutInMs() int64 {
	if m != nil {
		return m.TimeoutInMs
	}
	return 0
}

func (m *RunOptions) GetInterOpThreadPool() int32 {
	if m != nil {
		return m.InterOpThreadPool
	}
	return 0
}

func (m *RunOptions) GetOutputPartitionGraphs() bool {
	if m != nil {
		return m.OutputPartitionGraphs
	}
	return false
}

func (m *RunOptions) GetDebugOptions() *DebugOptions {
	if m != nil {
		return m.DebugOptions
	}
	return nil
}

func (m *RunOptions) GetReportTensorAllocationsUponOom() bool {
	if m != nil {
		return m.ReportTensorAllocationsUponOom
	}
	return false
}

func (m *RunOptions) GetExperimental() *RunOptions_Experimental {
	if m != nil {
		return m.Experimental
	}
	return nil
}

// Everything inside Experimental is subject to change and is not subject
// to API stability guarantees in
// https://www.tensorflow.org/guide/version_compat.
type RunOptions_Experimental struct {
	// If non-zero, declares that this graph is going to use collective
	// ops and must synchronize step_ids with any other graph with this
	// same group_key value (in a distributed computation where tasks
	// run disjoint graphs).
	CollectiveGraphKey int64 `protobuf:"varint,1,opt,name=collective_graph_key,json=collectiveGraphKey,proto3" json:"collective_graph_key,omitempty"`
	// If true, then operations (using the inter-op pool) across all
	// session::run() calls will be centrally scheduled, optimizing for (median
	// and tail) latency.
	// Consider using this option for CPU-bound workloads like inference.
	UseRunHandlerPool bool `protobuf:"varint,2,opt,name=use_run_handler_pool,json=useRunHandlerPool,proto3" json:"use_run_handler_pool,omitempty"`
}

func (m *RunOptions_Experimental) Reset()         { *m = RunOptions_Experimental{} }
func (m *RunOptions_Experimental) String() string { return proto.CompactTextString(m) }
func (*RunOptions_Experimental) ProtoMessage()    {}
func (*RunOptions_Experimental) Descriptor() ([]byte, []int) {
	return fileDescriptor_e2349c44c118036b, []int{7, 0}
}
func (m *RunOptions_Experimental) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunOptions_Experimental) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RunOptions_Experimental.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RunOptions_Experimental) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunOptions_Experimental.Merge(m, src)
}
func (m *RunOptions_Experimental) XXX_Size() int {
	return m.Size()
}
func (m *RunOptions_Experimental) XXX_DiscardUnknown() {
	xxx_messageInfo_RunOptions_Experimental.DiscardUnknown(m)
}

var xxx_messageInfo_RunOptions_Experimental proto.InternalMessageInfo

func (m *RunOptions_Experimental) GetCollectiveGraphKey() int64 {
	if m != nil {
		return m.CollectiveGraphKey
	}
	return 0
}

func (m *RunOptions_Experimental) GetUseRunHandlerPool() bool {
	if m != nil {
		return m.UseRunHandlerPool
	}
	return false
}

// Metadata output (i.e., non-Tensor) for a single Run() call.
type RunMetadata struct {
	// Statistics traced for this step. Populated if tracing is turned on via the
	// "RunOptions" proto.
	// EXPERIMENTAL: The format and set of events may change in future versions.
	StepStats *framework.StepStats `protobuf:"bytes,1,opt,name=step_stats,json=stepStats,proto3" json:"step_stats,omitempty"`
	// The cost graph for the computation defined by the run call.
	CostGraph *framework.CostGraphDef `protobuf:"bytes,2,opt,name=cost_graph,json=costGraph,proto3" json:"cost_graph,omitempty"`
	// Graphs of the partitions executed by executors.
	PartitionGraphs []*framework.GraphDef `protobuf:"bytes,3,rep,name=partition_graphs,json=partitionGraphs,proto3" json:"partition_graphs,omitempty"`
	// This is only populated for graphs that are run as functions in TensorFlow
	// V2. There will be an entry below for each function that is traced.
	// The main use cases of the post_optimization_graph and the partition_graphs
	// is to give the caller insight into the graphs that were actually run by the
	// runtime. Additional information (such as those in step_stats) will match
	// these graphs.
	// We also include the pre_optimization_graph since it is usually easier to
	// read, and is helpful in situations where the caller wants to get a high
	// level idea of what the built graph looks like (since the various graph
	// optimization passes might change the structure of the graph significantly).
	FunctionGraphs []*RunMetadata_FunctionGraphs `protobuf:"bytes,4,rep,name=function_graphs,json=functionGraphs,proto3" json:"function_graphs,omitempty"`
}

func (m *RunMetadata) Reset()         { *m = RunMetadata{} }
func (m *RunMetadata) String() string { return proto.CompactTextString(m) }
func (*RunMetadata) ProtoMessage()    {}
func (*RunMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_e2349c44c118036b, []int{8}
}
func (m *RunMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RunMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RunMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunMetadata.Merge(m, src)
}
func (m *RunMetadata) XXX_Size() int {
	return m.Size()
}
func (m *RunMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_RunMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_RunMetadata proto.InternalMessageInfo

func (m *RunMetadata) GetStepStats() *framework.StepStats {
	if m != nil {
		return m.StepStats
	}
	return nil
}

func (m *RunMetadata) GetCostGraph() *framework.CostGraphDef {
	if m != nil {
		return m.CostGraph
	}
	return nil
}

func (m *RunMetadata) GetPartitionGraphs() []*framework.GraphDef {
	if m != nil {
		return m.PartitionGraphs
	}
	return nil
}

func (m *RunMetadata) GetFunctionGraphs() []*RunMetadata_FunctionGraphs {
	if m != nil {
		return m.FunctionGraphs
	}
	return nil
}

type RunMetadata_FunctionGraphs struct {
	// TODO(nareshmodi): Include some sort of function/cache-key identifier?
	PartitionGraphs       []*framework.GraphDef `protobuf:"bytes,1,rep,name=partition_graphs,json=partitionGraphs,proto3" json:"partition_graphs,omitempty"`
	PreOptimizationGraph  *framework.GraphDef   `protobuf:"bytes,2,opt,name=pre_optimization_graph,json=preOptimizationGraph,proto3" json:"pre_optimization_graph,omitempty"`
	PostOptimizationGraph *framework.GraphDef   `protobuf:"bytes,3,opt,name=post_optimization_graph,json=postOptimizationGraph,proto3" json:"post_optimization_graph,omitempty"`
}

func (m *RunMetadata_FunctionGraphs) Reset()         { *m = RunMetadata_FunctionGraphs{} }
func (m *RunMetadata_FunctionGraphs) String() string { return proto.CompactTextString(m) }
func (*RunMetadata_FunctionGraphs) ProtoMessage()    {}
func (*RunMetadata_FunctionGraphs) Descriptor() ([]byte, []int) {
	return fileDescriptor_e2349c44c118036b, []int{8, 0}
}
func (m *RunMetadata_FunctionGraphs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunMetadata_FunctionGraphs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RunMetadata_FunctionGraphs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RunMetadata_FunctionGraphs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunMetadata_FunctionGraphs.Merge(m, src)
}
func (m *RunMetadata_FunctionGraphs) XXX_Size() int {
	return m.Size()
}
func (m *RunMetadata_FunctionGraphs) XXX_DiscardUnknown() {
	xxx_messageInfo_RunMetadata_FunctionGraphs.DiscardUnknown(m)
}

var xxx_messageInfo_RunMetadata_FunctionGraphs proto.InternalMessageInfo

func (m *RunMetadata_FunctionGraphs) GetPartitionGraphs() []*framework.GraphDef {
	if m != nil {
		return m.PartitionGraphs
	}
	return nil
}

func (m *RunMetadata_FunctionGraphs) GetPreOptimizationGraph() *framework.GraphDef {
	if m != nil {
		return m.PreOptimizationGraph
	}
	return nil
}

func (m *RunMetadata_FunctionGraphs) GetPostOptimizationGraph() *framework.GraphDef {
	if m != nil {
		return m.PostOptimizationGraph
	}
	return nil
}

// Defines a connection between two tensors in a `GraphDef`.
type TensorConnection struct {
	// A tensor name. The value of this tensor will be substituted for
	// the tensor named in `to_tensor`.
	FromTensor string `protobuf:"bytes,1,opt,name=from_tensor,json=fromTensor,proto3" json:"from_tensor,omitempty"`
	// A tensor name. The value of this tensor will be bound to the
	// value of the tensor named in `from_tensor`.
	ToTensor string `protobuf:"bytes,2,opt,name=to_tensor,json=toTensor,proto3" json:"to_tensor,omitempty"`
}

func (m *TensorConnection) Reset()         { *m = TensorConnection{} }
func (m *TensorConnection) String() string { return proto.CompactTextString(m) }
func (*TensorConnection) ProtoMessage()    {}
func (*TensorConnection) Descriptor() ([]byte, []int) {
	return fileDescriptor_e2349c44c118036b, []int{9}
}
func (m *TensorConnection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TensorConnection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TensorConnection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TensorConnection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TensorConnection.Merge(m, src)
}
func (m *TensorConnection) XXX_Size() int {
	return m.Size()
}
func (m *TensorConnection) XXX_DiscardUnknown() {
	xxx_messageInfo_TensorConnection.DiscardUnknown(m)
}

var xxx_messageInfo_TensorConnection proto.InternalMessageInfo

func (m *TensorConnection) GetFromTensor() string {
	if m != nil {
		return m.FromTensor
	}
	return ""
}

func (m *TensorConnection) GetToTensor() string {
	if m != nil {
		return m.ToTensor
	}
	return ""
}

// Defines a subgraph in another `GraphDef` as a set of feed points and nodes
// to be fetched or executed.
//
// Compare with the arguments to `Session::Run()`.
type CallableOptions struct {
	// Tensors to be fed in the callable. Each feed is the name of a tensor.
	Feed []string `protobuf:"bytes,1,rep,name=feed,proto3" json:"feed,omitempty"`
	// Fetches. A list of tensor names. The caller of the callable expects a
	// tensor to be returned for each fetch[i] (see RunStepResponse.tensor). The
	// order of specified fetches does not change the execution order.
	Fetch []string `protobuf:"bytes,2,rep,name=fetch,proto3" json:"fetch,omitempty"`
	// Target Nodes. A list of node names. The named nodes will be run by the
	// callable but their outputs will not be returned.
	Target []string `protobuf:"bytes,3,rep,name=target,proto3" json:"target,omitempty"`
	// Options that will be applied to each run.
	RunOptions *RunOptions `protobuf:"bytes,4,opt,name=run_options,json=runOptions,proto3" json:"run_options,omitempty"`
	// Tensors to be connected in the callable. Each TensorConnection denotes
	// a pair of tensors in the graph, between which an edge will be created
	// in the callable.
	TensorConnection []*TensorConnection `protobuf:"bytes,5,rep,name=tensor_connection,json=tensorConnection,proto3" json:"tensor_connection,omitempty"`
	// The Tensor objects fed in the callable and fetched from the callable
	// are expected to be backed by host (CPU) memory by default.
	//
	// The options below allow changing that - feeding tensors backed by
	// device memory, or returning tensors that are backed by device memory.
	//
	// The maps below map the name of a feed/fetch tensor (which appears in
	// 'feed' or 'fetch' fields above), to the fully qualified name of the device
	// owning the memory backing the contents of the tensor.
	//
	// For example, creating a callable with the following options:
	//
	// CallableOptions {
	//   feed: "a:0"
	//   feed: "b:0"
	//
	//   fetch: "x:0"
	//   fetch: "y:0"
	//
	//   feed_devices: {
	//     "a:0": "/job:localhost/replica:0/task:0/device:GPU:0"
	//   }
	//
	//   fetch_devices: {
	//     "y:0": "/job:localhost/replica:0/task:0/device:GPU:0"
	//  }
	// }
	//
	// means that the Callable expects:
	// - The first argument ("a:0") is a Tensor backed by GPU memory.
	// - The second argument ("b:0") is a Tensor backed by host memory.
	// and of its return values:
	// - The first output ("x:0") will be backed by host memory.
	// - The second output ("y:0") will be backed by GPU memory.
	//
	// FEEDS:
	// It is the responsibility of the caller to ensure that the memory of the fed
	// tensors will be correctly initialized and synchronized before it is
	// accessed by operations executed during the call to Session::RunCallable().
	//
	// This is typically ensured by using the TensorFlow memory allocators
	// (Device::GetAllocator()) to create the Tensor to be fed.
	//
	// Alternatively, for CUDA-enabled GPU devices, this typically means that the
	// operation that produced the contents of the tensor has completed, i.e., the
	// CUDA stream has been synchronized (e.g., via cuCtxSynchronize() or
	// cuStreamSynchronize()).
	FeedDevices  map[string]string `protobuf:"bytes,6,rep,name=feed_devices,json=feedDevices,proto3" json:"feed_devices,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	FetchDevices map[string]string `protobuf:"bytes,7,rep,name=fetch_devices,json=fetchDevices,proto3" json:"fetch_devices,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// By default, RunCallable() will synchronize the GPU stream before returning
	// fetched tensors on a GPU device, to ensure that the values in those tensors
	// have been produced. This simplifies interacting with the tensors, but
	// potentially incurs a performance hit.
	//
	// If this options is set to true, the caller is responsible for ensuring
	// that the values in the fetched tensors have been produced before they are
	// used. The caller can do this by invoking `Device::Sync()` on the underlying
	// device(s), or by feeding the tensors back to the same Session using
	// `feed_devices` with the same corresponding device name.
	FetchSkipSync bool `protobuf:"varint,8,opt,name=fetch_skip_sync,json=fetchSkipSync,proto3" json:"fetch_skip_sync,omitempty"`
}

func (m *CallableOptions) Reset()         { *m = CallableOptions{} }
func (m *CallableOptions) String() string { return proto.CompactTextString(m) }
func (*CallableOptions) ProtoMessage()    {}
func (*CallableOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_e2349c44c118036b, []int{10}
}
func (m *CallableOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CallableOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CallableOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CallableOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CallableOptions.Merge(m, src)
}
func (m *CallableOptions) XXX_Size() int {
	return m.Size()
}
func (m *CallableOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_CallableOptions.DiscardUnknown(m)
}

var xxx_messageInfo_CallableOptions proto.InternalMessageInfo

func (m *CallableOptions) GetFeed() []string {
	if m != nil {
		return m.Feed
	}
	return nil
}

func (m *CallableOptions) GetFetch() []string {
	if m != nil {
		return m.Fetch
	}
	return nil
}

func (m *CallableOptions) GetTarget() []string {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *CallableOptions) GetRunOptions() *RunOptions {
	if m != nil {
		return m.RunOptions
	}
	return nil
}

func (m *CallableOptions) GetTensorConnection() []*TensorConnection {
	if m != nil {
		return m.TensorConnection
	}
	return nil
}

func (m *CallableOptions) GetFeedDevices() map[string]string {
	if m != nil {
		return m.FeedDevices
	}
	return nil
}

func (m *CallableOptions) GetFetchDevices() map[string]string {
	if m != nil {
		return m.FetchDevices
	}
	return nil
}

func (m *CallableOptions) GetFetchSkipSync() bool {
	if m != nil {
		return m.FetchSkipSync
	}
	return false
}

func init() {
	proto.RegisterEnum("tensorflow.OptimizerOptions_Level", OptimizerOptions_Level_name, OptimizerOptions_Level_value)
	proto.RegisterEnum("tensorflow.OptimizerOptions_GlobalJitLevel", OptimizerOptions_GlobalJitLevel_name, OptimizerOptions_GlobalJitLevel_value)
	proto.RegisterEnum("tensorflow.RunOptions_TraceLevel", RunOptions_TraceLevel_name, RunOptions_TraceLevel_value)
	proto.RegisterType((*GPUOptions)(nil), "tensorflow.GPUOptions")
	proto.RegisterType((*GPUOptions_Experimental)(nil), "tensorflow.GPUOptions.Experimental")
	proto.RegisterType((*GPUOptions_Experimental_VirtualDevices)(nil), "tensorflow.GPUOptions.Experimental.VirtualDevices")
	proto.RegisterType((*OptimizerOptions)(nil), "tensorflow.OptimizerOptions")
	proto.RegisterType((*GraphOptions)(nil), "tensorflow.GraphOptions")
	proto.RegisterType((*ThreadPoolOptionProto)(nil), "tensorflow.ThreadPoolOptionProto")
	proto.RegisterType((*RPCOptions)(nil), "tensorflow.RPCOptions")
	proto.RegisterType((*SessionMetadata)(nil), "tensorflow.SessionMetadata")
	proto.RegisterType((*ConfigProto)(nil), "tensorflow.ConfigProto")
	proto.RegisterMapType((map[string]int32)(nil), "tensorflow.ConfigProto.DeviceCountEntry")
	proto.RegisterType((*ConfigProto_Experimental)(nil), "tensorflow.ConfigProto.Experimental")
	proto.RegisterType((*RunOptions)(nil), "tensorflow.RunOptions")
	proto.RegisterType((*RunOptions_Experimental)(nil), "tensorflow.RunOptions.Experimental")
	proto.RegisterType((*RunMetadata)(nil), "tensorflow.RunMetadata")
	proto.RegisterType((*RunMetadata_FunctionGraphs)(nil), "tensorflow.RunMetadata.FunctionGraphs")
	proto.RegisterType((*TensorConnection)(nil), "tensorflow.TensorConnection")
	proto.RegisterType((*CallableOptions)(nil), "tensorflow.CallableOptions")
	proto.RegisterMapType((map[string]string)(nil), "tensorflow.CallableOptions.FeedDevicesEntry")
	proto.RegisterMapType((map[string]string)(nil), "tensorflow.CallableOptions.FetchDevicesEntry")
}

func init() {
	proto.RegisterFile("tensorflow/core/protobuf/config.proto", fileDescriptor_e2349c44c118036b)
}

var fileDescriptor_e2349c44c118036b = []byte{
	// 2858 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x59, 0xcf, 0x53, 0x1c, 0xc7,
	0xf5, 0xd7, 0xb2, 0x0b, 0x5a, 0xde, 0x22, 0x76, 0x69, 0x81, 0x58, 0x23, 0x95, 0x8c, 0xd7, 0x96,
	0xbe, 0xd8, 0x96, 0x41, 0xc6, 0xb6, 0xe4, 0x6f, 0x5c, 0xb6, 0x0a, 0x2d, 0x2c, 0x46, 0x06, 0xb1,
	0xd5, 0x8b, 0x92, 0x4a, 0x72, 0xe8, 0x6a, 0x66, 0x7a, 0x96, 0x89, 0x66, 0xa6, 0xc7, 0xdd, 0x3d,
	0x08, 0x7c, 0xcc, 0x29, 0x47, 0xff, 0x13, 0x39, 0xe4, 0xe2, 0xbf, 0x23, 0x47, 0x1f, 0x73, 0x4c,
	0xd9, 0xc7, 0x5c, 0x72, 0xcc, 0x21, 0xe5, 0xa4, 0xfa, 0xc7, 0xec, 0xcc, 0x2e, 0x20, 0xc7, 0xba,
	0x68, 0xe6, 0x7d, 0x3e, 0xef, 0x4d, 0xf7, 0xeb, 0xf7, 0xab, 0x17, 0xb8, 0xa7, 0x58, 0x22, 0xb9,
	0x08, 0x22, 0xfe, 0x6a, 0xc3, 0xe3, 0x82, 0x6d, 0xa4, 0x82, 0x2b, 0x7e, 0x9c, 0x05, 0x1b, 0x1e,
	0x4f, 0x82, 0x70, 0xb8, 0x6e, 0xde, 0x11, 0x14, 0xb4, 0x95, 0xf7, 0x26, 0x55, 0x02, 0x41, 0x63,
	0xf6, 0x8a, 0x8b, 0x97, 0x1b, 0x1e, 0x97, 0x8a, 0x0c, 0x05, 0x4d, 0x4f, 0xac, 0xde, 0xca, 0xbd,
	0xab, 0xb9, 0x65, 0xda, 0x6b, 0x4c, 0x4a, 0xc5, 0x52, 0x22, 0x15, 0x55, 0xd2, 0x71, 0xef, 0x5f,
	0xbd, 0xe2, 0x28, 0x93, 0x8a, 0x09, 0xc7, 0x7b, 0xe7, 0x4a, 0x9e, 0xcf, 0x8e, 0x33, 0xb7, 0xb1,
	0x95, 0xf5, 0x2b, 0x59, 0x82, 0xbd, 0x12, 0xa1, 0x62, 0x82, 0x94, 0x1d, 0xd1, 0xf9, 0xae, 0x0e,
	0xb0, 0xdb, 0x7f, 0x71, 0x98, 0xaa, 0x90, 0x27, 0x12, 0x6d, 0xc3, 0x9b, 0x29, 0x13, 0x24, 0x15,
	0xdc, 0x63, 0x52, 0x92, 0x61, 0x9a, 0x91, 0x98, 0xc5, 0x5c, 0x9c, 0x93, 0x40, 0x50, 0x4f, 0x73,
	0xda, 0x95, 0xd5, 0xca, 0x5a, 0x05, 0xdf, 0x4e, 0x99, 0xe8, 0x5b, 0xd6, 0x6e, 0x9a, 0x1d, 0x18,
	0x4e, 0xcf, 0x51, 0xd0, 0x5b, 0x30, 0x47, 0xa3, 0x88, 0xbf, 0x22, 0x43, 0xc1, 0x5f, 0xa9, 0x93,
	0x76, 0x6d, 0xb5, 0xb2, 0x56, 0xc7, 0x0d, 0x23, 0xdb, 0x35, 0x22, 0x74, 0x0f, 0xe6, 0xf5, 0xab,
	0x47, 0x15, 0x17, 0x44, 0x9d, 0xa7, 0xac, 0x3d, 0xb5, 0x5a, 0x59, 0x9b, 0xc5, 0x37, 0x46, 0xd2,
	0xa3, 0xf3, 0x94, 0xa1, 0x47, 0xb0, 0xec, 0xb3, 0x80, 0x09, 0xc1, 0x7c, 0xe2, 0xb3, 0x88, 0x69,
	0xf3, 0xe4, 0xf8, 0x5c, 0x31, 0xd9, 0xae, 0xae, 0x56, 0xd6, 0xaa, 0x78, 0x29, 0x87, 0xb7, 0x1d,
	0xfa, 0x54, 0x83, 0x68, 0x1d, 0x6e, 0x9e, 0x86, 0x32, 0x3c, 0x8e, 0x18, 0xf1, 0xd9, 0x69, 0xe8,
	0x31, 0x12, 0x85, 0x52, 0xb5, 0xa7, 0xcd, 0x37, 0x16, 0x1c, 0xb4, 0x6d, 0x90, 0xfd, 0x50, 0x2a,
	0xf4, 0x19, 0xac, 0xa4, 0x3c, 0x8a, 0xc2, 0x64, 0x48, 0xf4, 0x1e, 0x4e, 0xb5, 0x5a, 0x44, 0xcf,
	0x49, 0x26, 0x99, 0x27, 0xdb, 0x33, 0xab, 0x95, 0xb5, 0x69, 0xbc, 0xec, 0x18, 0x5b, 0x86, 0xb0,
	0xad, 0xf1, 0x17, 0x1a, 0x46, 0x4f, 0xe0, 0x4e, 0xae, 0x1c, 0x26, 0x63, 0xea, 0xb1, 0x51, 0xbf,
	0x6e, 0xd4, 0xdf, 0x70, 0x9c, 0x3d, 0x47, 0x31, 0x06, 0x0e, 0x8c, 0x81, 0x87, 0xb0, 0x18, 0x70,
	0xe1, 0x31, 0xe3, 0x6f, 0x8f, 0xc7, 0x29, 0x55, 0x7a, 0x7d, 0xed, 0xba, 0xf1, 0x1b, 0x32, 0xd8,
	0x6e, 0x9a, 0x75, 0x47, 0x08, 0xda, 0x85, 0x39, 0x76, 0x96, 0x32, 0x11, 0xc6, 0x2c, 0x51, 0x34,
	0x6a, 0xcf, 0xae, 0x56, 0xd6, 0x1a, 0x9b, 0x6f, 0x97, 0x4e, 0x7f, 0xbd, 0x38, 0xd5, 0xf5, 0x9d,
	0x12, 0x15, 0x8f, 0x29, 0xae, 0x7c, 0x57, 0x83, 0xb9, 0x32, 0x8c, 0x7e, 0x0f, 0xcd, 0xd3, 0x50,
	0xa8, 0x8c, 0x46, 0xce, 0x73, 0xb2, 0x5d, 0x59, 0xad, 0xae, 0x35, 0x36, 0x37, 0xff, 0x07, 0xe3,
	0xeb, 0xbf, 0xb6, 0xaa, 0xd6, 0xb3, 0x12, 0xcf, 0x9f, 0x8e, 0xbd, 0xa3, 0x07, 0x80, 0x32, 0xc9,
	0x48, 0x96, 0x84, 0x41, 0xc8, 0x7c, 0x17, 0x5a, 0xe6, 0xe4, 0xeb, 0xb8, 0x95, 0x49, 0xf6, 0xc2,
	0x02, 0x36, 0x9c, 0xd0, 0x67, 0x70, 0x3b, 0xc9, 0x62, 0xbd, 0x0c, 0xa2, 0xb8, 0xf9, 0xcf, 0xe3,
	0xe9, 0x39, 0x91, 0x4a, 0x30, 0x1a, 0xdb, 0x00, 0x98, 0xc6, 0xb7, 0x92, 0x2c, 0xde, 0x66, 0xa7,
	0x47, 0x7c, 0x9b, 0x9d, 0x76, 0x79, 0x7a, 0x3e, 0xb0, 0x28, 0xda, 0x84, 0x25, 0x8f, 0x47, 0x11,
	0xb3, 0xc7, 0x21, 0xf4, 0xe1, 0x70, 0xe1, 0x33, 0x61, 0x82, 0x71, 0x16, 0xdf, 0x2c, 0x40, 0x1c,
	0x26, 0xc3, 0x43, 0x0d, 0xa1, 0x8f, 0x60, 0x49, 0x85, 0x31, 0x93, 0x8a, 0xc6, 0x29, 0xf3, 0xc9,
	0x28, 0x14, 0x4d, 0xdc, 0xd4, 0xf1, 0x62, 0x09, 0xdc, 0xca, 0x31, 0xf4, 0x39, 0xdc, 0x7e, 0xc9,
	0x44, 0xc2, 0x22, 0xa2, 0x04, 0xf5, 0x5e, 0x32, 0x41, 0x62, 0x7a, 0x46, 0xc2, 0x44, 0x31, 0x71,
	0x4a, 0x23, 0x77, 0xf8, 0x6d, 0x4b, 0x39, 0xb2, 0x8c, 0x03, 0x7a, 0xb6, 0xe7, 0x70, 0xf4, 0x18,
	0xda, 0x97, 0xa8, 0xdb, 0x10, 0xaf, 0x1b, 0xdd, 0xa5, 0x49, 0x5d, 0x1b, 0xe2, 0x9f, 0xc1, 0xca,
	0x25, 0x8a, 0x29, 0x4b, 0xfc, 0x30, 0x19, 0x9a, 0x80, 0x98, 0xc6, 0xcb, 0x93, 0xaa, 0x7d, 0x0b,
	0xaf, 0x7c, 0x0a, 0xf3, 0xe3, 0x47, 0x85, 0xee, 0x43, 0xd3, 0x65, 0x7a, 0x14, 0xc6, 0xa1, 0x22,
	0xf1, 0xb1, 0x39, 0xf7, 0x29, 0x7c, 0xc3, 0x8a, 0xf7, 0xb5, 0xf4, 0xe0, 0xb8, 0xf3, 0xc7, 0x1a,
	0xb4, 0xf4, 0xd1, 0xc7, 0xe1, 0x37, 0x4c, 0xe4, 0x65, 0xe3, 0x00, 0xde, 0xf6, 0xb9, 0x8e, 0xdc,
	0x98, 0x27, 0x44, 0x66, 0xc7, 0xec, 0x2c, 0x15, 0x4c, 0x4a, 0x9d, 0xac, 0x4c, 0x9b, 0x4b, 0xe8,
	0xa8, 0x74, 0xd4, 0xf1, 0xaa, 0xcf, 0xbb, 0x86, 0x39, 0x28, 0x13, 0x77, 0x0a, 0x9e, 0xce, 0x5e,
	0x63, 0x2e, 0x91, 0x8a, 0x26, 0x8a, 0x04, 0x3c, 0x32, 0x7b, 0xb2, 0x71, 0xb2, 0xa0, 0xd5, 0x2d,
	0xd2, 0xb3, 0x00, 0xfa, 0x02, 0xee, 0xe8, 0xbd, 0x6b, 0x1e, 0xf3, 0x0b, 0xbd, 0x30, 0x2f, 0x15,
	0x33, 0xa6, 0x54, 0xb4, 0x63, 0x7a, 0xd6, 0x33, 0x94, 0x5c, 0x7f, 0xcf, 0x55, 0x8b, 0x87, 0xb0,
	0xe8, 0x73, 0x12, 0x64, 0x89, 0x29, 0x5f, 0x24, 0x4c, 0xa2, 0x30, 0xd1, 0x1f, 0xb4, 0x75, 0x0b,
	0xf9, 0xbc, 0xe7, 0xa0, 0x3d, 0x87, 0xa0, 0x27, 0x30, 0xcb, 0x53, 0x45, 0x22, 0x76, 0xca, 0x22,
	0x13, 0x88, 0xf3, 0x9b, 0x9d, 0x72, 0x7e, 0x4c, 0x7a, 0x68, 0x7d, 0x5f, 0x33, 0x71, 0x9d, 0xa7,
	0xca, 0x3c, 0xa1, 0x17, 0xd0, 0x1a, 0x46, 0xfc, 0x98, 0x46, 0xe4, 0x0f, 0x61, 0x6e, 0x67, 0xda,
	0xd8, 0x79, 0xff, 0xb5, 0x76, 0x76, 0x8d, 0xd2, 0xb3, 0xd0, 0x9a, 0xc1, 0xf3, 0xc3, 0xb1, 0xf7,
	0xce, 0x2a, 0x4c, 0x5b, 0xfb, 0x33, 0x30, 0xb5, 0xff, 0x61, 0xeb, 0x1a, 0x6a, 0xc2, 0xd4, 0xfe,
	0xc3, 0xd6, 0x7f, 0xf2, 0x7f, 0x95, 0x4e, 0x17, 0xe6, 0xc7, 0x6d, 0xa0, 0x06, 0x5c, 0xdf, 0xde,
	0xe9, 0x6d, 0xbd, 0xd8, 0x3f, 0x6a, 0x5d, 0x43, 0x2d, 0xa8, 0x1e, 0xf6, 0x7a, 0x25, 0x05, 0x54,
	0x87, 0xda, 0xe1, 0x73, 0xf2, 0x61, 0x2b, 0x7f, 0xda, 0x6c, 0x4d, 0x75, 0xbe, 0xad, 0xc1, 0xdc,
	0xae, 0xee, 0x77, 0x79, 0x00, 0x7c, 0x0c, 0xb7, 0x58, 0x42, 0x75, 0xb9, 0x15, 0xcc, 0x3b, 0x25,
	0xd2, 0x3b, 0x61, 0x7e, 0x16, 0x15, 0x87, 0xb6, 0x68, 0x51, 0xcc, 0xbc, 0xd3, 0xc1, 0x08, 0x43,
	0x7b, 0xb0, 0xc0, 0xf3, 0x0d, 0x12, 0x6e, 0x4d, 0x19, 0x6f, 0x36, 0x36, 0xef, 0xbc, 0xce, 0x0b,
	0xb8, 0xc5, 0x27, 0x23, 0x70, 0x0d, 0x5a, 0xc7, 0x59, 0x18, 0xe9, 0xd3, 0x97, 0x8a, 0xc4, 0xdc,
	0x67, 0x91, 0x39, 0xbe, 0x2a, 0x9e, 0x37, 0xf2, 0x2e, 0x97, 0xea, 0x40, 0x4b, 0xd1, 0x47, 0x70,
	0x6b, 0x92, 0x49, 0x68, 0xa0, 0x98, 0x30, 0x39, 0x53, 0xc5, 0x37, 0xc7, 0xf9, 0x5b, 0x1a, 0xd2,
	0x1d, 0x2d, 0x4c, 0x02, 0x26, 0x88, 0x3c, 0xa1, 0x29, 0x93, 0xae, 0x20, 0x34, 0x8c, 0x6c, 0x60,
	0x44, 0xba, 0xb6, 0xa5, 0x11, 0xf5, 0x18, 0x49, 0x45, 0x96, 0x30, 0xdf, 0x8e, 0x0d, 0x26, 0xf4,
	0xea, 0xb8, 0x65, 0x90, 0xbe, 0x01, 0x8c, 0xdf, 0xd0, 0xa7, 0xd0, 0x76, 0x0e, 0x3b, 0x0e, 0x22,
	0x4e, 0xd5, 0x87, 0x8f, 0x88, 0x64, 0x89, 0xaf, 0xbd, 0x67, 0x4a, 0x46, 0x1d, 0x3b, 0x87, 0x3e,
	0x75, 0xf0, 0xc0, 0xa1, 0xe8, 0x6d, 0xb8, 0xa1, 0xeb, 0x50, 0x14, 0x26, 0x8c, 0xe8, 0x61, 0xc2,
	0x55, 0x89, 0xb9, 0x5c, 0x38, 0x50, 0x2c, 0x45, 0x5d, 0x68, 0xba, 0x7e, 0x3f, 0xf2, 0x2b, 0x18,
	0xbf, 0x96, 0x07, 0x84, 0x75, 0xec, 0x46, 0x82, 0xae, 0x99, 0x08, 0xf0, 0xbc, 0x53, 0x71, 0x3e,
	0x7d, 0x56, 0xab, 0x57, 0x5a, 0x53, 0xf8, 0x9e, 0x7c, 0x19, 0xa6, 0x3f, 0x9b, 0xdb, 0x9d, 0xdf,
	0xc2, 0xd2, 0xd1, 0x89, 0x60, 0xd4, 0xef, 0x73, 0x1e, 0x59, 0x0b, 0x7d, 0x33, 0x6a, 0xbd, 0x09,
	0x0d, 0x5d, 0xc5, 0x95, 0x01, 0xa5, 0xa9, 0x01, 0xd3, 0x18, 0x92, 0x2c, 0xb6, 0x74, 0xa9, 0x09,
	0x2e, 0x15, 0x12, 0x1a, 0xe7, 0x73, 0x00, 0x58, 0xd1, 0x73, 0x1a, 0xb3, 0xce, 0x5f, 0xa6, 0x00,
	0x70, 0xbf, 0x9b, 0x1f, 0xf5, 0x17, 0x70, 0x47, 0x37, 0x11, 0x91, 0x7a, 0x24, 0xe0, 0x82, 0x84,
	0x49, 0x3e, 0xad, 0xc4, 0x54, 0x8f, 0x4b, 0xae, 0xca, 0xb4, 0x33, 0xc9, 0x70, 0xea, 0xf5, 0xb8,
	0xd8, 0xcb, 0x09, 0x07, 0x06, 0xd7, 0x55, 0x5e, 0xf7, 0xd8, 0x7c, 0x13, 0x34, 0x1a, 0x72, 0x11,
	0xaa, 0x93, 0xd8, 0x7d, 0x79, 0xb1, 0x04, 0x6e, 0xe5, 0x18, 0x7a, 0x1f, 0x16, 0xca, 0x4a, 0x45,
	0xe2, 0x4f, 0xe3, 0x56, 0x09, 0xb0, 0x19, 0xf5, 0x00, 0x90, 0x47, 0xbd, 0x13, 0xbb, 0x46, 0xc1,
	0x64, 0xca, 0x13, 0xc9, 0x5c, 0x35, 0x69, 0x19, 0x04, 0xa7, 0x1e, 0x76, 0x72, 0xf4, 0x15, 0x74,
	0xfc, 0x50, 0x9a, 0x58, 0x90, 0xce, 0xbc, 0xc7, 0x93, 0x84, 0xd9, 0x62, 0x24, 0x4f, 0xa8, 0x6e,
	0x5e, 0x2e, 0xe2, 0xde, 0x74, 0xcc, 0x81, 0x25, 0x76, 0x47, 0xbc, 0x81, 0xa5, 0x75, 0x9e, 0x40,
	0xd3, 0x61, 0x07, 0x4c, 0x51, 0x9f, 0x2a, 0x8a, 0x10, 0xd4, 0x8c, 0x63, 0x2b, 0x66, 0x7b, 0xe6,
	0x19, 0xb5, 0xe1, 0xfa, 0x29, 0x13, 0x9a, 0x66, 0x76, 0x5d, 0xc5, 0xf9, 0x6b, 0xe7, 0xa7, 0x79,
	0x68, 0xd8, 0x78, 0xb0, 0xc7, 0xf7, 0x15, 0xcc, 0xb9, 0x09, 0xca, 0xe3, 0x59, 0xa2, 0xdc, 0x30,
	0xb0, 0x56, 0x0e, 0xa3, 0x12, 0x7d, 0xdd, 0xb6, 0x93, 0xae, 0xa6, 0xee, 0x24, 0x4a, 0x9c, 0xe3,
	0x86, 0x5f, 0x48, 0xf4, 0xa4, 0x14, 0x26, 0x4a, 0x50, 0xc2, 0x53, 0x92, 0x52, 0x41, 0xa3, 0x88,
	0x45, 0xa1, 0x2c, 0x82, 0x63, 0xca, 0x4e, 0x4a, 0x86, 0x73, 0x98, 0xf6, 0x0b, 0x46, 0x1e, 0x2b,
	0xd6, 0x80, 0xa9, 0x16, 0x97, 0x1a, 0x98, 0x1e, 0x19, 0xd0, 0xa5, 0xe1, 0x12, 0x03, 0x9f, 0xc0,
	0xb2, 0x0e, 0x1e, 0x3d, 0xe4, 0xe6, 0xce, 0xce, 0x75, 0x67, 0x6d, 0xa5, 0xca, 0x24, 0xeb, 0x33,
	0xe1, 0x9c, 0x98, 0xab, 0x51, 0xb8, 0x93, 0xd3, 0x47, 0xdf, 0xb7, 0x7a, 0x24, 0xe5, 0x3c, 0x6a,
	0xcf, 0x19, 0xaf, 0xbc, 0x55, 0xf6, 0xca, 0xa5, 0xd9, 0x80, 0xdb, 0xce, 0xcc, 0x9e, 0x5d, 0x61,
	0x41, 0x42, 0xef, 0x82, 0xad, 0x12, 0x7a, 0x92, 0xd2, 0xeb, 0x0b, 0xb9, 0xef, 0x02, 0xac, 0x39,
	0x92, 0xf7, 0x8d, 0x58, 0x0f, 0xcf, 0xee, 0x4c, 0x82, 0x30, 0x52, 0x4c, 0xc8, 0x76, 0x6d, 0xb5,
	0xaa, 0x87, 0x67, 0x2b, 0xed, 0x59, 0x21, 0x7a, 0x0c, 0x0d, 0x3d, 0x50, 0xe6, 0x05, 0x60, 0xc6,
	0x14, 0x80, 0x5b, 0x97, 0x8f, 0x71, 0x18, 0x86, 0x69, 0x96, 0x67, 0xd8, 0x43, 0x58, 0xb4, 0xf3,
	0xbb, 0xe4, 0x81, 0x22, 0xa3, 0xaf, 0xbb, 0xc2, 0x84, 0x0c, 0x36, 0xe0, 0x81, 0xea, 0xe7, 0x88,
	0xd6, 0x88, 0xf8, 0x30, 0x9f, 0xb5, 0x0b, 0x0d, 0x37, 0xc1, 0x46, 0x7c, 0x68, 0x03, 0xa3, 0xd0,
	0xf8, 0x1c, 0x6e, 0x98, 0x0a, 0x39, 0x51, 0x9f, 0xda, 0x63, 0xcb, 0x2b, 0xb5, 0x18, 0x3c, 0x37,
	0x2c, 0x37, 0x9c, 0x4f, 0x60, 0x99, 0xa7, 0x4c, 0x98, 0xda, 0x43, 0x74, 0xe9, 0xe3, 0x99, 0x69,
	0xf8, 0xb1, 0x6c, 0x37, 0x4c, 0x40, 0x2f, 0x8e, 0xe0, 0x23, 0x8b, 0xee, 0x25, 0x07, 0xc6, 0x25,
	0x3a, 0x27, 0xf3, 0x6f, 0xde, 0xb8, 0xe8, 0x92, 0xa2, 0xd0, 0x60, 0x10, 0xa9, 0x97, 0x7f, 0xef,
	0x31, 0x34, 0xdc, 0x75, 0x8c, 0xf8, 0x2c, 0x68, 0xcf, 0x5f, 0x54, 0xec, 0x5a, 0x78, 0x9b, 0x05,
	0x18, 0xbc, 0xd1, 0xb3, 0x9e, 0x43, 0x43, 0xc9, 0x23, 0xaa, 0x8a, 0xec, 0xd6, 0xb7, 0x3f, 0xd6,
	0x6e, 0x1a, 0xd7, 0xdc, 0x74, 0xa0, 0x8b, 0xb7, 0x81, 0x86, 0xd0, 0x97, 0x13, 0xd3, 0x7d, 0xcb,
	0x7c, 0xed, 0x9d, 0xab, 0x72, 0xee, 0x35, 0xe3, 0xfd, 0x17, 0xd0, 0x9a, 0xcc, 0x48, 0xdd, 0xe2,
	0x5f, 0xb2, 0x73, 0x57, 0x0e, 0xf4, 0x23, 0x5a, 0x84, 0xe9, 0x53, 0x1a, 0x65, 0xcc, 0xe5, 0x9f,
	0x7d, 0xf9, 0xd5, 0xd4, 0xa7, 0x95, 0x95, 0x7f, 0xce, 0x4c, 0x5c, 0x0f, 0x1e, 0xc1, 0x72, 0x69,
	0xac, 0x1e, 0x0a, 0x9e, 0xa5, 0x24, 0x62, 0xd4, 0x77, 0x75, 0x77, 0x16, 0x97, 0xa6, 0xee, 0x5d,
	0x8d, 0xee, 0x1b, 0x50, 0x77, 0x2d, 0x76, 0xc6, 0xbc, 0x6c, 0x74, 0xdd, 0xab, 0x1a, 0xf6, 0x5c,
	0x2e, 0x34, 0xb7, 0xbd, 0xf7, 0x01, 0x99, 0xf1, 0xe1, 0x38, 0x0b, 0xcc, 0x30, 0xeb, 0x9d, 0x64,
	0xc9, 0x4b, 0x53, 0x37, 0xa7, 0x71, 0x53, 0x23, 0x4f, 0xb3, 0xe0, 0x80, 0x9e, 0x75, 0xb5, 0x18,
	0xbd, 0x07, 0x0b, 0x3a, 0x93, 0x93, 0x2c, 0xa6, 0x84, 0x06, 0x41, 0x98, 0x84, 0xea, 0xdc, 0x55,
	0xc9, 0x66, 0x26, 0xd9, 0xf3, 0x2c, 0xa6, 0x5b, 0x4e, 0x8c, 0x28, 0x7c, 0x50, 0x5a, 0xb5, 0xcf,
	0x14, 0x13, 0x71, 0x98, 0x84, 0x52, 0x85, 0x1e, 0x91, 0xec, 0xeb, 0x8c, 0x25, 0x2a, 0xa4, 0x11,
	0xb1, 0x8b, 0xd1, 0x45, 0xd1, 0xb6, 0xed, 0xf7, 0x0a, 0xa5, 0xed, 0xb2, 0xce, 0x60, 0xa4, 0xb2,
	0x93, 0x6b, 0xa0, 0xff, 0x83, 0x66, 0xe9, 0x13, 0x89, 0xe7, 0x45, 0x2e, 0x5d, 0xe6, 0x0b, 0xf1,
	0x73, 0xcf, 0x8b, 0x10, 0x85, 0x75, 0x5d, 0xd3, 0x27, 0xc2, 0x41, 0xc7, 0xae, 0x8b, 0x1a, 0x99,
	0x32, 0x4f, 0xdf, 0xc0, 0x53, 0x3a, 0xb4, 0x63, 0xb3, 0x4d, 0xa2, 0x77, 0x8d, 0x56, 0x39, 0x4e,
	0xf6, 0x92, 0x6e, 0xa1, 0xd1, 0x2f, 0x14, 0xcc, 0xad, 0xd9, 0x75, 0x14, 0x57, 0xa4, 0x64, 0x1a,
	0x26, 0x49, 0x7e, 0x2f, 0xa8, 0xe3, 0x25, 0x07, 0xdb, 0xf2, 0x33, 0x70, 0x20, 0xea, 0xc1, 0xaa,
	0x5d, 0x5a, 0x11, 0xea, 0xe6, 0x72, 0xa0, 0x17, 0xe7, 0x56, 0x6b, 0xd2, 0xb4, 0x8e, 0xef, 0x18,
	0xde, 0x28, 0xe4, 0x0d, 0x6b, 0x2f, 0x71, 0x8b, 0x43, 0x3d, 0x68, 0xe5, 0x9b, 0x8b, 0x5d, 0x17,
	0x32, 0x59, 0xd9, 0xd8, 0xbc, 0x5d, 0x8e, 0xe1, 0x89, 0x46, 0x85, 0x9b, 0x72, 0xa2, 0x73, 0xfd,
	0x3f, 0xbc, 0x91, 0x0f, 0x7a, 0xa6, 0xd5, 0x6b, 0x4f, 0x85, 0x9e, 0x9b, 0xac, 0xe6, 0xec, 0x94,
	0x94, 0x13, 0x7a, 0x5c, 0x0c, 0x0c, 0x6c, 0xe7, 0xab, 0x07, 0x80, 0xdc, 0x7c, 0x15, 0x47, 0xa1,
	0x20, 0xc7, 0x22, 0xf4, 0x87, 0xcc, 0xe4, 0x7b, 0x1d, 0xb7, 0x2c, 0x72, 0x10, 0x85, 0xe2, 0xa9,
	0x91, 0xa3, 0x1d, 0xc8, 0x1b, 0x2b, 0xe1, 0x99, 0x4a, 0x33, 0xa5, 0x9b, 0x8b, 0x0a, 0x4d, 0x71,
	0x31, 0x5f, 0x93, 0x26, 0xe3, 0xeb, 0xf8, 0x8e, 0xa3, 0x1d, 0x1a, 0x56, 0x3f, 0x27, 0x99, 0x6f,
	0x4a, 0x7d, 0x15, 0x3c, 0x8b, 0x28, 0x09, 0x32, 0x3b, 0x58, 0x64, 0x8a, 0xab, 0x2c, 0x61, 0xc2,
	0x1c, 0x82, 0x3c, 0x31, 0x19, 0x5f, 0xc5, 0xed, 0xb3, 0x88, 0xf6, 0x0c, 0x63, 0x2b, 0x27, 0x1c,
	0x19, 0xfc, 0x59, 0xad, 0x3e, 0xd5, 0xaa, 0x76, 0x7e, 0xaa, 0x01, 0xe0, 0x2c, 0xc9, 0x0b, 0xcf,
	0x53, 0x68, 0xe8, 0xfb, 0x1d, 0x73, 0x23, 0x47, 0xc5, 0xdc, 0x11, 0xc6, 0x1a, 0x4d, 0x41, 0x5e,
	0xd7, 0x17, 0x3d, 0x66, 0x6f, 0x06, 0xa0, 0x46, 0xcf, 0xa8, 0x63, 0x47, 0xc6, 0xa2, 0x44, 0xda,
	0x9e, 0xdf, 0x50, 0xa5, 0xca, 0xb8, 0x01, 0x8b, 0x97, 0x76, 0x36, 0xdb, 0x82, 0x16, 0xc2, 0x0b,
	0xfd, 0xea, 0x11, 0x2c, 0x5f, 0xe5, 0x2b, 0x9b, 0x85, 0x4b, 0xfc, 0x0a, 0x27, 0xdd, 0x30, 0x3f,
	0x58, 0x4d, 0xf4, 0xa5, 0xb1, 0xc2, 0xbf, 0xad, 0x09, 0xa3, 0xc2, 0xef, 0x97, 0xde, 0xd0, 0x33,
	0xe8, 0x08, 0x96, 0x72, 0xa1, 0x88, 0xe5, 0xe7, 0xb7, 0x74, 0x0d, 0x92, 0x2c, 0xe5, 0x09, 0xe1,
	0x3c, 0x76, 0xa9, 0x77, 0xd7, 0x32, 0x8f, 0x0c, 0x71, 0xab, 0xe0, 0xbd, 0x48, 0x79, 0x72, 0xc8,
	0xe3, 0x0b, 0xbf, 0xa2, 0xd4, 0x2f, 0xfe, 0x8a, 0x52, 0x72, 0xee, 0x6b, 0xca, 0xec, 0xd7, 0x13,
	0x55, 0xf2, 0x21, 0x2c, 0x8e, 0x55, 0x49, 0xdd, 0xe7, 0xf2, 0x9a, 0x5b, 0xc5, 0xa8, 0x5c, 0x22,
	0x69, 0x7a, 0xf2, 0x15, 0x3b, 0xd7, 0xee, 0x37, 0x43, 0x6d, 0x96, 0x90, 0x13, 0x9a, 0xf8, 0x11,
	0x13, 0xd6, 0xfd, 0xee, 0xce, 0xab, 0x87, 0xd9, 0x2c, 0xf9, 0xd2, 0x22, 0xda, 0xfd, 0x1d, 0x0c,
	0x50, 0x9c, 0x36, 0x9a, 0x83, 0xfa, 0xf3, 0x43, 0x72, 0x84, 0xb7, 0xba, 0x3b, 0xad, 0x6b, 0x08,
	0xc1, 0xfc, 0xe0, 0xb0, 0x77, 0xf4, 0x9b, 0x2d, 0xbc, 0xe3, 0x64, 0x15, 0x2d, 0xfb, 0x72, 0x0b,
	0x6f, 0x97, 0x64, 0x53, 0x68, 0x1e, 0xa0, 0xf7, 0x62, 0x7f, 0xdf, 0xbd, 0x57, 0x9f, 0xd5, 0xea,
	0xb5, 0xd6, 0x74, 0xe7, 0xdf, 0x55, 0x68, 0xe0, 0xac, 0xc8, 0xc2, 0x8f, 0x01, 0x8a, 0x1f, 0x2d,
	0xcd, 0x16, 0x1a, 0x9b, 0x4b, 0x63, 0x79, 0xac, 0x58, 0xaa, 0x73, 0x4f, 0xe2, 0x59, 0x99, 0x3f,
	0xa2, 0xc7, 0x00, 0xc5, 0xaf, 0xa7, 0x66, 0x1b, 0x13, 0x67, 0xac, 0x6f, 0x58, 0x66, 0xfb, 0xba,
	0x63, 0xce, 0x7a, 0xf9, 0x1b, 0x7a, 0x02, 0xad, 0x0b, 0x01, 0x55, 0x35, 0xe3, 0xd5, 0xe2, 0x85,
	0xd9, 0x40, 0xab, 0x36, 0xd3, 0x89, 0x00, 0x3b, 0x84, 0xe6, 0xe8, 0x2a, 0xef, 0xf4, 0x6b, 0x46,
	0xff, 0xfe, 0xc4, 0xc1, 0xe6, 0x3b, 0x5c, 0xcf, 0xaf, 0xf7, 0xd6, 0x00, 0x9e, 0x0f, 0xc6, 0xde,
	0x57, 0xfe, 0x51, 0x81, 0xf9, 0x71, 0xca, 0xa5, 0x8b, 0xac, 0xfc, 0x92, 0x45, 0x3e, 0x83, 0x5b,
	0xa9, 0xb0, 0x97, 0xb3, 0x38, 0xfc, 0x86, 0x16, 0x76, 0x9c, 0xab, 0x2e, 0x37, 0xb3, 0x98, 0x0a,
	0x76, 0x58, 0x52, 0xb1, 0x1e, 0xdb, 0x87, 0xe5, 0x54, 0xbb, 0xfa, 0x12, 0x63, 0xd5, 0xd7, 0x18,
	0x5b, 0xd2, 0x4a, 0x17, 0xac, 0x75, 0xfa, 0xd0, 0xb2, 0x09, 0x53, 0x5c, 0x2e, 0xf4, 0x15, 0x2d,
	0x10, 0x3c, 0x76, 0x29, 0xe7, 0x3a, 0x3d, 0x68, 0x91, 0xa5, 0xa2, 0xdb, 0x30, 0xab, 0x78, 0x0e,
	0xdb, 0x7b, 0x54, 0x5d, 0x71, 0x0b, 0x76, 0xfe, 0x5c, 0x83, 0x66, 0x97, 0x46, 0x91, 0x29, 0x9c,
	0x2e, 0x8d, 0x11, 0xd4, 0x02, 0xc6, 0x7c, 0xe3, 0xb4, 0x59, 0x6c, 0x9e, 0xf5, 0x18, 0x12, 0x30,
	0xe5, 0x69, 0x17, 0x68, 0xa1, 0x7d, 0x41, 0xb7, 0x60, 0x46, 0x51, 0x31, 0x64, 0xca, 0x44, 0xc1,
	0x2c, 0x76, 0x6f, 0x66, 0x94, 0xcb, 0x92, 0x51, 0x15, 0xa9, 0x5d, 0x32, 0xca, 0x8d, 0x72, 0x17,
	0x83, 0x28, 0x2a, 0xea, 0x1e, 0x2c, 0xb8, 0xd2, 0x51, 0x5c, 0xb3, 0xda, 0xd3, 0xe6, 0xf0, 0xc6,
	0x7e, 0x75, 0x98, 0xf4, 0x02, 0x6e, 0xa9, 0x49, 0xbf, 0x1c, 0xc2, 0x9c, 0x5e, 0xf9, 0xe8, 0x97,
	0xd2, 0x19, 0x63, 0xe5, 0xc1, 0x58, 0x98, 0x8f, 0x6f, 0x7c, 0xbd, 0xc7, 0x98, 0xef, 0x1a, 0xa6,
	0xbb, 0x20, 0x05, 0x85, 0x04, 0x61, 0xb8, 0x61, 0x76, 0x3d, 0xb2, 0x78, 0xdd, 0x58, 0xfc, 0xe0,
	0xf5, 0x16, 0x95, 0x77, 0x32, 0x66, 0x72, 0x2e, 0x28, 0x89, 0xd0, 0x7d, 0x68, 0x5a, 0x9b, 0xe6,
	0x22, 0x2f, 0xcf, 0x13, 0xcf, 0x4d, 0x14, 0xf6, 0x53, 0x83, 0x97, 0x61, 0x3a, 0x38, 0x4f, 0x3c,
	0x3d, 0x2b, 0x4e, 0x2e, 0xee, 0xe7, 0x66, 0xc5, 0xd9, 0xf2, 0xac, 0xf8, 0x04, 0x16, 0x2e, 0x2c,
	0xe5, 0x97, 0x18, 0x78, 0xfa, 0xa7, 0xca, 0x5f, 0x7f, 0xb8, 0x5b, 0xf9, 0xfe, 0x87, 0xbb, 0x95,
	0xbf, 0xff, 0x70, 0xb7, 0xf2, 0xed, 0x8f, 0x77, 0xaf, 0x7d, 0xff, 0xe3, 0xdd, 0x6b, 0x7f, 0xfb,
	0xf1, 0xee, 0x35, 0x68, 0x73, 0x31, 0x2c, 0xfb, 0x60, 0xf4, 0xf7, 0x94, 0xa7, 0x73, 0xa5, 0x49,
	0x58, 0xf6, 0x2b, 0xbf, 0xdb, 0x1a, 0x86, 0xea, 0x24, 0x3b, 0x5e, 0xf7, 0x78, 0xbc, 0xb1, 0x95,
	0xa6, 0x51, 0x18, 0x84, 0x4c, 0x6c, 0x0c, 0xf9, 0x07, 0xa5, 0x3f, 0x8c, 0xe8, 0x01, 0x54, 0x6e,
	0x5c, 0xf5, 0x97, 0x92, 0x7f, 0x55, 0x2a, 0xc7, 0x33, 0xe6, 0xe5, 0xa3, 0xff, 0x06, 0x00, 0x00,
	0xff, 0xff, 0xf0, 0x39, 0x21, 0x00, 0x4f, 0x1a, 0x00, 0x00,
}

func (m *GPUOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GPUOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PerProcessGpuMemoryFraction != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PerProcessGpuMemoryFraction))))
		i += 8
	}
	if len(m.AllocatorType) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.AllocatorType)))
		i += copy(dAtA[i:], m.AllocatorType)
	}
	if m.DeferredDeletionBytes != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.DeferredDeletionBytes))
	}
	if m.AllowGrowth {
		dAtA[i] = 0x20
		i++
		if m.AllowGrowth {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.VisibleDeviceList) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.VisibleDeviceList)))
		i += copy(dAtA[i:], m.VisibleDeviceList)
	}
	if m.PollingActiveDelayUsecs != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.PollingActiveDelayUsecs))
	}
	if m.PollingInactiveDelayMsecs != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.PollingInactiveDelayMsecs))
	}
	if m.ForceGpuCompatible {
		dAtA[i] = 0x40
		i++
		if m.ForceGpuCompatible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Experimental != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.Experimental.Size()))
		n1, err := m.Experimental.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *GPUOptions_Experimental) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GPUOptions_Experimental) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VirtualDevices) > 0 {
		for _, msg := range m.VirtualDevices {
			dAtA[i] = 0xa
			i++
			i = encodeVarintConfig(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.UseUnifiedMemory {
		dAtA[i] = 0x10
		i++
		if m.UseUnifiedMemory {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NumDevToDevCopyStreams != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.NumDevToDevCopyStreams))
	}
	if len(m.CollectiveRingOrder) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.CollectiveRingOrder)))
		i += copy(dAtA[i:], m.CollectiveRingOrder)
	}
	if m.TimestampedAllocator {
		dAtA[i] = 0x28
		i++
		if m.TimestampedAllocator {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.KernelTrackerMaxInterval != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.KernelTrackerMaxInterval))
	}
	if m.KernelTrackerMaxBytes != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.KernelTrackerMaxBytes))
	}
	if m.KernelTrackerMaxPending != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.KernelTrackerMaxPending))
	}
	return i, nil
}

func (m *GPUOptions_Experimental_VirtualDevices) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GPUOptions_Experimental_VirtualDevices) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MemoryLimitMb) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.MemoryLimitMb)*4))
		for _, num := range m.MemoryLimitMb {
			f2 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f2))
			i += 4
		}
	}
	return i, nil
}

func (m *OptimizerOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OptimizerOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DoCommonSubexpressionElimination {
		dAtA[i] = 0x8
		i++
		if m.DoCommonSubexpressionElimination {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DoConstantFolding {
		dAtA[i] = 0x10
		i++
		if m.DoConstantFolding {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OptLevel != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.OptLevel))
	}
	if m.DoFunctionInlining {
		dAtA[i] = 0x20
		i++
		if m.DoFunctionInlining {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.GlobalJitLevel != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.GlobalJitLevel))
	}
	if m.MaxFoldedConstantInBytes != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.MaxFoldedConstantInBytes))
	}
	return i, nil
}

func (m *GraphOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GraphOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EnableRecvScheduling {
		dAtA[i] = 0x10
		i++
		if m.EnableRecvScheduling {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OptimizerOptions != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.OptimizerOptions.Size()))
		n3, err := m.OptimizerOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.BuildCostModel != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.BuildCostModel))
	}
	if m.InferShapes {
		dAtA[i] = 0x28
		i++
		if m.InferShapes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PlacePrunedGraph {
		dAtA[i] = 0x30
		i++
		if m.PlacePrunedGraph {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EnableBfloat16Sendrecv {
		dAtA[i] = 0x38
		i++
		if m.EnableBfloat16Sendrecv {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TimelineStep != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.TimelineStep))
	}
	if m.BuildCostModelAfter != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.BuildCostModelAfter))
	}
	if m.RewriteOptions != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.RewriteOptions.Size()))
		n4, err := m.RewriteOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *ThreadPoolOptionProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThreadPoolOptionProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumThreads != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.NumThreads))
	}
	if len(m.GlobalName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.GlobalName)))
		i += copy(dAtA[i:], m.GlobalName)
	}
	return i, nil
}

func (m *RPCOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RPCOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UseRpcForInprocessMaster {
		dAtA[i] = 0x8
		i++
		if m.UseRpcForInprocessMaster {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.CompressionAlgorithm) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.CompressionAlgorithm)))
		i += copy(dAtA[i:], m.CompressionAlgorithm)
	}
	if m.CompressionLevel != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.CompressionLevel))
	}
	if m.CacheRpcResponse {
		dAtA[i] = 0x20
		i++
		if m.CacheRpcResponse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DisableSessionConnectionSharing {
		dAtA[i] = 0x28
		i++
		if m.DisableSessionConnectionSharing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SessionMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Version != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.Version))
	}
	return i, nil
}

func (m *ConfigProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DeviceCount) > 0 {
		for k, _ := range m.DeviceCount {
			dAtA[i] = 0xa
			i++
			v := m.DeviceCount[k]
			mapSize := 1 + len(k) + sovConfig(uint64(len(k))) + 1 + sovConfig(uint64(v))
			i = encodeVarintConfig(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintConfig(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintConfig(dAtA, i, uint64(v))
		}
	}
	if m.IntraOpParallelismThreads != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.IntraOpParallelismThreads))
	}
	if m.PlacementPeriod != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.PlacementPeriod))
	}
	if len(m.DeviceFilters) > 0 {
		for _, s := range m.DeviceFilters {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.InterOpParallelismThreads != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.InterOpParallelismThreads))
	}
	if m.GpuOptions != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.GpuOptions.Size()))
		n5, err := m.GpuOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.AllowSoftPlacement {
		dAtA[i] = 0x38
		i++
		if m.AllowSoftPlacement {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LogDevicePlacement {
		dAtA[i] = 0x40
		i++
		if m.LogDevicePlacement {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UsePerSessionThreads {
		dAtA[i] = 0x48
		i++
		if m.UsePerSessionThreads {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.GraphOptions != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.GraphOptions.Size()))
		n6, err := m.GraphOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.OperationTimeoutInMs != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.OperationTimeoutInMs))
	}
	if len(m.SessionInterOpThreadPool) > 0 {
		for _, msg := range m.SessionInterOpThreadPool {
			dAtA[i] = 0x62
			i++
			i = encodeVarintConfig(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.RpcOptions != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.RpcOptions.Size()))
		n7, err := m.RpcOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.ClusterDef != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.ClusterDef.Size()))
		n8, err := m.ClusterDef.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.IsolateSessionState {
		dAtA[i] = 0x78
		i++
		if m.IsolateSessionState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Experimental != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.Experimental.Size()))
		n9, err := m.Experimental.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *ConfigProto_Experimental) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigProto_Experimental) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CollectiveGroupLeader) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.CollectiveGroupLeader)))
		i += copy(dAtA[i:], m.CollectiveGroupLeader)
	}
	if len(m.ExecutorType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.ExecutorType)))
		i += copy(dAtA[i:], m.ExecutorType)
	}
	if m.RecvBufMaxChunk != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.RecvBufMaxChunk))
	}
	if m.UseNumaAffinity {
		dAtA[i] = 0x28
		i++
		if m.UseNumaAffinity {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CollectiveDeterministicSequentialExecution {
		dAtA[i] = 0x30
		i++
		if m.CollectiveDeterministicSequentialExecution {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CollectiveNccl {
		dAtA[i] = 0x38
		i++
		if m.CollectiveNccl {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ShareSessionStateInClusterspecPropagation {
		dAtA[i] = 0x40
		i++
		if m.ShareSessionStateInClusterspecPropagation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DisableThreadSpinning {
		dAtA[i] = 0x48
		i++
		if m.DisableThreadSpinning {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ShareClusterDevicesInSession {
		dAtA[i] = 0x50
		i++
		if m.ShareClusterDevicesInSession {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SessionMetadata != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.SessionMetadata.Size()))
		n10, err := m.SessionMetadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.OptimizeForStaticGraph {
		dAtA[i] = 0x60
		i++
		if m.OptimizeForStaticGraph {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EnableMlirBridge {
		dAtA[i] = 0x68
		i++
		if m.EnableMlirBridge {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DisableOutputPartitionGraphs {
		dAtA[i] = 0x70
		i++
		if m.DisableOutputPartitionGraphs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XlaFusionAutotunerThresh != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.XlaFusionAutotunerThresh))
	}
	return i, nil
}

func (m *RunOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TraceLevel != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.TraceLevel))
	}
	if m.TimeoutInMs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.TimeoutInMs))
	}
	if m.InterOpThreadPool != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.InterOpThreadPool))
	}
	if m.OutputPartitionGraphs {
		dAtA[i] = 0x28
		i++
		if m.OutputPartitionGraphs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DebugOptions != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.DebugOptions.Size()))
		n11, err := m.DebugOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.ReportTensorAllocationsUponOom {
		dAtA[i] = 0x38
		i++
		if m.ReportTensorAllocationsUponOom {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Experimental != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.Experimental.Size()))
		n12, err := m.Experimental.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *RunOptions_Experimental) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunOptions_Experimental) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CollectiveGraphKey != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.CollectiveGraphKey))
	}
	if m.UseRunHandlerPool {
		dAtA[i] = 0x10
		i++
		if m.UseRunHandlerPool {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RunMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StepStats != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.StepStats.Size()))
		n13, err := m.StepStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.CostGraph != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.CostGraph.Size()))
		n14, err := m.CostGraph.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.PartitionGraphs) > 0 {
		for _, msg := range m.PartitionGraphs {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintConfig(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.FunctionGraphs) > 0 {
		for _, msg := range m.FunctionGraphs {
			dAtA[i] = 0x22
			i++
			i = encodeVarintConfig(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RunMetadata_FunctionGraphs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunMetadata_FunctionGraphs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PartitionGraphs) > 0 {
		for _, msg := range m.PartitionGraphs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintConfig(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PreOptimizationGraph != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.PreOptimizationGraph.Size()))
		n15, err := m.PreOptimizationGraph.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.PostOptimizationGraph != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.PostOptimizationGraph.Size()))
		n16, err := m.PostOptimizationGraph.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *TensorConnection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorConnection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FromTensor) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.FromTensor)))
		i += copy(dAtA[i:], m.FromTensor)
	}
	if len(m.ToTensor) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.ToTensor)))
		i += copy(dAtA[i:], m.ToTensor)
	}
	return i, nil
}

func (m *CallableOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CallableOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Feed) > 0 {
		for _, s := range m.Feed {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Fetch) > 0 {
		for _, s := range m.Fetch {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Target) > 0 {
		for _, s := range m.Target {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.RunOptions != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.RunOptions.Size()))
		n17, err := m.RunOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if len(m.TensorConnection) > 0 {
		for _, msg := range m.TensorConnection {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintConfig(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.FeedDevices) > 0 {
		for k, _ := range m.FeedDevices {
			dAtA[i] = 0x32
			i++
			v := m.FeedDevices[k]
			mapSize := 1 + len(k) + sovConfig(uint64(len(k))) + 1 + len(v) + sovConfig(uint64(len(v)))
			i = encodeVarintConfig(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintConfig(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintConfig(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.FetchDevices) > 0 {
		for k, _ := range m.FetchDevices {
			dAtA[i] = 0x3a
			i++
			v := m.FetchDevices[k]
			mapSize := 1 + len(k) + sovConfig(uint64(len(k))) + 1 + len(v) + sovConfig(uint64(len(v)))
			i = encodeVarintConfig(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintConfig(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintConfig(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.FetchSkipSync {
		dAtA[i] = 0x40
		i++
		if m.FetchSkipSync {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func encodeVarintConfig(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GPUOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PerProcessGpuMemoryFraction != 0 {
		n += 9
	}
	l = len(m.AllocatorType)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.DeferredDeletionBytes != 0 {
		n += 1 + sovConfig(uint64(m.DeferredDeletionBytes))
	}
	if m.AllowGrowth {
		n += 2
	}
	l = len(m.VisibleDeviceList)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.PollingActiveDelayUsecs != 0 {
		n += 1 + sovConfig(uint64(m.PollingActiveDelayUsecs))
	}
	if m.PollingInactiveDelayMsecs != 0 {
		n += 1 + sovConfig(uint64(m.PollingInactiveDelayMsecs))
	}
	if m.ForceGpuCompatible {
		n += 2
	}
	if m.Experimental != nil {
		l = m.Experimental.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	return n
}

func (m *GPUOptions_Experimental) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.VirtualDevices) > 0 {
		for _, e := range m.VirtualDevices {
			l = e.Size()
			n += 1 + l + sovConfig(uint64(l))
		}
	}
	if m.UseUnifiedMemory {
		n += 2
	}
	if m.NumDevToDevCopyStreams != 0 {
		n += 1 + sovConfig(uint64(m.NumDevToDevCopyStreams))
	}
	l = len(m.CollectiveRingOrder)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.TimestampedAllocator {
		n += 2
	}
	if m.KernelTrackerMaxInterval != 0 {
		n += 1 + sovConfig(uint64(m.KernelTrackerMaxInterval))
	}
	if m.KernelTrackerMaxBytes != 0 {
		n += 1 + sovConfig(uint64(m.KernelTrackerMaxBytes))
	}
	if m.KernelTrackerMaxPending != 0 {
		n += 1 + sovConfig(uint64(m.KernelTrackerMaxPending))
	}
	return n
}

func (m *GPUOptions_Experimental_VirtualDevices) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MemoryLimitMb) > 0 {
		n += 1 + sovConfig(uint64(len(m.MemoryLimitMb)*4)) + len(m.MemoryLimitMb)*4
	}
	return n
}

func (m *OptimizerOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DoCommonSubexpressionElimination {
		n += 2
	}
	if m.DoConstantFolding {
		n += 2
	}
	if m.OptLevel != 0 {
		n += 1 + sovConfig(uint64(m.OptLevel))
	}
	if m.DoFunctionInlining {
		n += 2
	}
	if m.GlobalJitLevel != 0 {
		n += 1 + sovConfig(uint64(m.GlobalJitLevel))
	}
	if m.MaxFoldedConstantInBytes != 0 {
		n += 1 + sovConfig(uint64(m.MaxFoldedConstantInBytes))
	}
	return n
}

func (m *GraphOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableRecvScheduling {
		n += 2
	}
	if m.OptimizerOptions != nil {
		l = m.OptimizerOptions.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.BuildCostModel != 0 {
		n += 1 + sovConfig(uint64(m.BuildCostModel))
	}
	if m.InferShapes {
		n += 2
	}
	if m.PlacePrunedGraph {
		n += 2
	}
	if m.EnableBfloat16Sendrecv {
		n += 2
	}
	if m.TimelineStep != 0 {
		n += 1 + sovConfig(uint64(m.TimelineStep))
	}
	if m.BuildCostModelAfter != 0 {
		n += 1 + sovConfig(uint64(m.BuildCostModelAfter))
	}
	if m.RewriteOptions != nil {
		l = m.RewriteOptions.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	return n
}

func (m *ThreadPoolOptionProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumThreads != 0 {
		n += 1 + sovConfig(uint64(m.NumThreads))
	}
	l = len(m.GlobalName)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	return n
}

func (m *RPCOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseRpcForInprocessMaster {
		n += 2
	}
	l = len(m.CompressionAlgorithm)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.CompressionLevel != 0 {
		n += 1 + sovConfig(uint64(m.CompressionLevel))
	}
	if m.CacheRpcResponse {
		n += 2
	}
	if m.DisableSessionConnectionSharing {
		n += 2
	}
	return n
}

func (m *SessionMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovConfig(uint64(m.Version))
	}
	return n
}

func (m *ConfigProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DeviceCount) > 0 {
		for k, v := range m.DeviceCount {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovConfig(uint64(len(k))) + 1 + sovConfig(uint64(v))
			n += mapEntrySize + 1 + sovConfig(uint64(mapEntrySize))
		}
	}
	if m.IntraOpParallelismThreads != 0 {
		n += 1 + sovConfig(uint64(m.IntraOpParallelismThreads))
	}
	if m.PlacementPeriod != 0 {
		n += 1 + sovConfig(uint64(m.PlacementPeriod))
	}
	if len(m.DeviceFilters) > 0 {
		for _, s := range m.DeviceFilters {
			l = len(s)
			n += 1 + l + sovConfig(uint64(l))
		}
	}
	if m.InterOpParallelismThreads != 0 {
		n += 1 + sovConfig(uint64(m.InterOpParallelismThreads))
	}
	if m.GpuOptions != nil {
		l = m.GpuOptions.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.AllowSoftPlacement {
		n += 2
	}
	if m.LogDevicePlacement {
		n += 2
	}
	if m.UsePerSessionThreads {
		n += 2
	}
	if m.GraphOptions != nil {
		l = m.GraphOptions.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.OperationTimeoutInMs != 0 {
		n += 1 + sovConfig(uint64(m.OperationTimeoutInMs))
	}
	if len(m.SessionInterOpThreadPool) > 0 {
		for _, e := range m.SessionInterOpThreadPool {
			l = e.Size()
			n += 1 + l + sovConfig(uint64(l))
		}
	}
	if m.RpcOptions != nil {
		l = m.RpcOptions.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.ClusterDef != nil {
		l = m.ClusterDef.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.IsolateSessionState {
		n += 2
	}
	if m.Experimental != nil {
		l = m.Experimental.Size()
		n += 2 + l + sovConfig(uint64(l))
	}
	return n
}

func (m *ConfigProto_Experimental) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectiveGroupLeader)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	l = len(m.ExecutorType)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.RecvBufMaxChunk != 0 {
		n += 1 + sovConfig(uint64(m.RecvBufMaxChunk))
	}
	if m.UseNumaAffinity {
		n += 2
	}
	if m.CollectiveDeterministicSequentialExecution {
		n += 2
	}
	if m.CollectiveNccl {
		n += 2
	}
	if m.ShareSessionStateInClusterspecPropagation {
		n += 2
	}
	if m.DisableThreadSpinning {
		n += 2
	}
	if m.ShareClusterDevicesInSession {
		n += 2
	}
	if m.SessionMetadata != nil {
		l = m.SessionMetadata.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.OptimizeForStaticGraph {
		n += 2
	}
	if m.EnableMlirBridge {
		n += 2
	}
	if m.DisableOutputPartitionGraphs {
		n += 2
	}
	if m.XlaFusionAutotunerThresh != 0 {
		n += 1 + sovConfig(uint64(m.XlaFusionAutotunerThresh))
	}
	return n
}

func (m *RunOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TraceLevel != 0 {
		n += 1 + sovConfig(uint64(m.TraceLevel))
	}
	if m.TimeoutInMs != 0 {
		n += 1 + sovConfig(uint64(m.TimeoutInMs))
	}
	if m.InterOpThreadPool != 0 {
		n += 1 + sovConfig(uint64(m.InterOpThreadPool))
	}
	if m.OutputPartitionGraphs {
		n += 2
	}
	if m.DebugOptions != nil {
		l = m.DebugOptions.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.ReportTensorAllocationsUponOom {
		n += 2
	}
	if m.Experimental != nil {
		l = m.Experimental.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	return n
}

func (m *RunOptions_Experimental) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CollectiveGraphKey != 0 {
		n += 1 + sovConfig(uint64(m.CollectiveGraphKey))
	}
	if m.UseRunHandlerPool {
		n += 2
	}
	return n
}

func (m *RunMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StepStats != nil {
		l = m.StepStats.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.CostGraph != nil {
		l = m.CostGraph.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	if len(m.PartitionGraphs) > 0 {
		for _, e := range m.PartitionGraphs {
			l = e.Size()
			n += 1 + l + sovConfig(uint64(l))
		}
	}
	if len(m.FunctionGraphs) > 0 {
		for _, e := range m.FunctionGraphs {
			l = e.Size()
			n += 1 + l + sovConfig(uint64(l))
		}
	}
	return n
}

func (m *RunMetadata_FunctionGraphs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PartitionGraphs) > 0 {
		for _, e := range m.PartitionGraphs {
			l = e.Size()
			n += 1 + l + sovConfig(uint64(l))
		}
	}
	if m.PreOptimizationGraph != nil {
		l = m.PreOptimizationGraph.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.PostOptimizationGraph != nil {
		l = m.PostOptimizationGraph.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	return n
}

func (m *TensorConnection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FromTensor)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	l = len(m.ToTensor)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	return n
}

func (m *CallableOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Feed) > 0 {
		for _, s := range m.Feed {
			l = len(s)
			n += 1 + l + sovConfig(uint64(l))
		}
	}
	if len(m.Fetch) > 0 {
		for _, s := range m.Fetch {
			l = len(s)
			n += 1 + l + sovConfig(uint64(l))
		}
	}
	if len(m.Target) > 0 {
		for _, s := range m.Target {
			l = len(s)
			n += 1 + l + sovConfig(uint64(l))
		}
	}
	if m.RunOptions != nil {
		l = m.RunOptions.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	if len(m.TensorConnection) > 0 {
		for _, e := range m.TensorConnection {
			l = e.Size()
			n += 1 + l + sovConfig(uint64(l))
		}
	}
	if len(m.FeedDevices) > 0 {
		for k, v := range m.FeedDevices {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovConfig(uint64(len(k))) + 1 + len(v) + sovConfig(uint64(len(v)))
			n += mapEntrySize + 1 + sovConfig(uint64(mapEntrySize))
		}
	}
	if len(m.FetchDevices) > 0 {
		for k, v := range m.FetchDevices {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovConfig(uint64(len(k))) + 1 + len(v) + sovConfig(uint64(len(v)))
			n += mapEntrySize + 1 + sovConfig(uint64(mapEntrySize))
		}
	}
	if m.FetchSkipSync {
		n += 2
	}
	return n
}

func sovConfig(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozConfig(x uint64) (n int) {
	return sovConfig(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GPUOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GPUOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GPUOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerProcessGpuMemoryFraction", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PerProcessGpuMemoryFraction = float64(math.Float64frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocatorType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllocatorType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeferredDeletionBytes", wireType)
			}
			m.DeferredDeletionBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeferredDeletionBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowGrowth", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowGrowth = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VisibleDeviceList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VisibleDeviceList = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PollingActiveDelayUsecs", wireType)
			}
			m.PollingActiveDelayUsecs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PollingActiveDelayUsecs |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PollingInactiveDelayMsecs", wireType)
			}
			m.PollingInactiveDelayMsecs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PollingInactiveDelayMsecs |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceGpuCompatible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceGpuCompatible = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Experimental", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Experimental == nil {
				m.Experimental = &GPUOptions_Experimental{}
			}
			if err := m.Experimental.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GPUOptions_Experimental) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Experimental: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Experimental: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualDevices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualDevices = append(m.VirtualDevices, &GPUOptions_Experimental_VirtualDevices{})
			if err := m.VirtualDevices[len(m.VirtualDevices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseUnifiedMemory", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseUnifiedMemory = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumDevToDevCopyStreams", wireType)
			}
			m.NumDevToDevCopyStreams = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumDevToDevCopyStreams |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectiveRingOrder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectiveRingOrder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampedAllocator", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimestampedAllocator = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelTrackerMaxInterval", wireType)
			}
			m.KernelTrackerMaxInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KernelTrackerMaxInterval |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelTrackerMaxBytes", wireType)
			}
			m.KernelTrackerMaxBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KernelTrackerMaxBytes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelTrackerMaxPending", wireType)
			}
			m.KernelTrackerMaxPending = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KernelTrackerMaxPending |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GPUOptions_Experimental_VirtualDevices) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualDevices: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualDevices: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.MemoryLimitMb = append(m.MemoryLimitMb, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfig
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthConfig
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.MemoryLimitMb) == 0 {
					m.MemoryLimitMb = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.MemoryLimitMb = append(m.MemoryLimitMb, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryLimitMb", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OptimizerOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OptimizerOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OptimizerOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoCommonSubexpressionElimination", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DoCommonSubexpressionElimination = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoConstantFolding", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DoConstantFolding = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptLevel", wireType)
			}
			m.OptLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptLevel |= (OptimizerOptions_Level(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoFunctionInlining", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DoFunctionInlining = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalJitLevel", wireType)
			}
			m.GlobalJitLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlobalJitLevel |= (OptimizerOptions_GlobalJitLevel(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFoldedConstantInBytes", wireType)
			}
			m.MaxFoldedConstantInBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxFoldedConstantInBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GraphOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GraphOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GraphOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableRecvScheduling", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableRecvScheduling = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptimizerOptions == nil {
				m.OptimizerOptions = &OptimizerOptions{}
			}
			if err := m.OptimizerOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildCostModel", wireType)
			}
			m.BuildCostModel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildCostModel |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InferShapes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InferShapes = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlacePrunedGraph", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlacePrunedGraph = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableBfloat16Sendrecv", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableBfloat16Sendrecv = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimelineStep", wireType)
			}
			m.TimelineStep = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimelineStep |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildCostModelAfter", wireType)
			}
			m.BuildCostModelAfter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildCostModelAfter |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewriteOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RewriteOptions == nil {
				m.RewriteOptions = &RewriterConfig{}
			}
			if err := m.RewriteOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThreadPoolOptionProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThreadPoolOptionProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThreadPoolOptionProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumThreads", wireType)
			}
			m.NumThreads = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumThreads |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GlobalName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RPCOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RPCOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RPCOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseRpcForInprocessMaster", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseRpcForInprocessMaster = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionAlgorithm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompressionAlgorithm = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionLevel", wireType)
			}
			m.CompressionLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompressionLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheRpcResponse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CacheRpcResponse = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableSessionConnectionSharing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableSessionConnectionSharing = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceCount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeviceCount == nil {
				m.DeviceCount = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfig
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfig
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthConfig
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfig
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipConfig(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthConfig
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DeviceCount[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntraOpParallelismThreads", wireType)
			}
			m.IntraOpParallelismThreads = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntraOpParallelismThreads |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlacementPeriod", wireType)
			}
			m.PlacementPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlacementPeriod |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceFilters", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceFilters = append(m.DeviceFilters, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterOpParallelismThreads", wireType)
			}
			m.InterOpParallelismThreads = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterOpParallelismThreads |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpuOptions == nil {
				m.GpuOptions = &GPUOptions{}
			}
			if err := m.GpuOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowSoftPlacement", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowSoftPlacement = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogDevicePlacement", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LogDevicePlacement = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsePerSessionThreads", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsePerSessionThreads = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GraphOptions == nil {
				m.GraphOptions = &GraphOptions{}
			}
			if err := m.GraphOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationTimeoutInMs", wireType)
			}
			m.OperationTimeoutInMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationTimeoutInMs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionInterOpThreadPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionInterOpThreadPool = append(m.SessionInterOpThreadPool, &ThreadPoolOptionProto{})
			if err := m.SessionInterOpThreadPool[len(m.SessionInterOpThreadPool)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RpcOptions == nil {
				m.RpcOptions = &RPCOptions{}
			}
			if err := m.RpcOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClusterDef == nil {
				m.ClusterDef = &ClusterDef{}
			}
			if err := m.ClusterDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsolateSessionState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsolateSessionState = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Experimental", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Experimental == nil {
				m.Experimental = &ConfigProto_Experimental{}
			}
			if err := m.Experimental.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigProto_Experimental) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Experimental: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Experimental: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectiveGroupLeader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectiveGroupLeader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutorType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecutorType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecvBufMaxChunk", wireType)
			}
			m.RecvBufMaxChunk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecvBufMaxChunk |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseNumaAffinity", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseNumaAffinity = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectiveDeterministicSequentialExecution", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CollectiveDeterministicSequentialExecution = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectiveNccl", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CollectiveNccl = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShareSessionStateInClusterspecPropagation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ShareSessionStateInClusterspecPropagation = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableThreadSpinning", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableThreadSpinning = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShareClusterDevicesInSession", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ShareClusterDevicesInSession = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SessionMetadata == nil {
				m.SessionMetadata = &SessionMetadata{}
			}
			if err := m.SessionMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizeForStaticGraph", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizeForStaticGraph = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableMlirBridge", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableMlirBridge = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableOutputPartitionGraphs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableOutputPartitionGraphs = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XlaFusionAutotunerThresh", wireType)
			}
			m.XlaFusionAutotunerThresh = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XlaFusionAutotunerThresh |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceLevel", wireType)
			}
			m.TraceLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TraceLevel |= (RunOptions_TraceLevel(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutInMs", wireType)
			}
			m.TimeoutInMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutInMs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterOpThreadPool", wireType)
			}
			m.InterOpThreadPool = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterOpThreadPool |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputPartitionGraphs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutputPartitionGraphs = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DebugOptions == nil {
				m.DebugOptions = &DebugOptions{}
			}
			if err := m.DebugOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportTensorAllocationsUponOom", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReportTensorAllocationsUponOom = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Experimental", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Experimental == nil {
				m.Experimental = &RunOptions_Experimental{}
			}
			if err := m.Experimental.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunOptions_Experimental) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Experimental: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Experimental: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectiveGraphKey", wireType)
			}
			m.CollectiveGraphKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectiveGraphKey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseRunHandlerPool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseRunHandlerPool = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StepStats == nil {
				m.StepStats = &framework.StepStats{}
			}
			if err := m.StepStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostGraph", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CostGraph == nil {
				m.CostGraph = &framework.CostGraphDef{}
			}
			if err := m.CostGraph.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionGraphs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionGraphs = append(m.PartitionGraphs, &framework.GraphDef{})
			if err := m.PartitionGraphs[len(m.PartitionGraphs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionGraphs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FunctionGraphs = append(m.FunctionGraphs, &RunMetadata_FunctionGraphs{})
			if err := m.FunctionGraphs[len(m.FunctionGraphs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunMetadata_FunctionGraphs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FunctionGraphs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FunctionGraphs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionGraphs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionGraphs = append(m.PartitionGraphs, &framework.GraphDef{})
			if err := m.PartitionGraphs[len(m.PartitionGraphs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreOptimizationGraph", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreOptimizationGraph == nil {
				m.PreOptimizationGraph = &framework.GraphDef{}
			}
			if err := m.PreOptimizationGraph.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostOptimizationGraph", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PostOptimizationGraph == nil {
				m.PostOptimizationGraph = &framework.GraphDef{}
			}
			if err := m.PostOptimizationGraph.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TensorConnection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TensorConnection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TensorConnection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromTensor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromTensor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToTensor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToTensor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallableOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallableOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallableOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Feed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Feed = append(m.Feed, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fetch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fetch = append(m.Fetch, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = append(m.Target, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RunOptions == nil {
				m.RunOptions = &RunOptions{}
			}
			if err := m.RunOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TensorConnection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TensorConnection = append(m.TensorConnection, &TensorConnection{})
			if err := m.TensorConnection[len(m.TensorConnection)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeedDevices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FeedDevices == nil {
				m.FeedDevices = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfig
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfig
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthConfig
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfig
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthConfig
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipConfig(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthConfig
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.FeedDevices[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FetchDevices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FetchDevices == nil {
				m.FetchDevices = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfig
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfig
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthConfig
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfig
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthConfig
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipConfig(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthConfig
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.FetchDevices[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FetchSkipSync", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FetchSkipSync = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipConfig(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthConfig
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowConfig
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipConfig(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthConfig = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowConfig   = fmt.Errorf("proto: integer overflow")
)
