// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tensorflow/core/protobuf/saved_object_graph.proto

package protobuf

import (
	fmt "fmt"
	framework "github.com/Applifier/go-tensorflow/types/tensorflow/core/framework"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Whether the function should be compiled by XLA.
//
// The public interface to `tf.function` uses an optional boolean to
// represent three distinct states for this field.  Unfortunately, proto3
// removes the ability to explicitly check for the presence or absence of a
// field, so we instead map to an enum.
//
// See `tf.function` for details.
type FunctionSpec_JitCompile int32

const (
	FunctionSpec_DEFAULT FunctionSpec_JitCompile = 0
	FunctionSpec_ON      FunctionSpec_JitCompile = 1
	FunctionSpec_OFF     FunctionSpec_JitCompile = 2
)

var FunctionSpec_JitCompile_name = map[int32]string{
	0: "DEFAULT",
	1: "ON",
	2: "OFF",
}

var FunctionSpec_JitCompile_value = map[string]int32{
	"DEFAULT": 0,
	"ON":      1,
	"OFF":     2,
}

func (x FunctionSpec_JitCompile) String() string {
	return proto.EnumName(FunctionSpec_JitCompile_name, int32(x))
}

func (FunctionSpec_JitCompile) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4f63c49021beb5aa, []int{9, 0}
}

type SavedObjectGraph struct {
	// Flattened list of objects in the object graph.
	//
	// The position of the object in this list indicates its id.
	// Nodes[0] is considered the root node.
	Nodes []*SavedObject `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty"`
	// Information about captures and output structures in concrete functions.
	// Referenced from SavedBareConcreteFunction and SavedFunction.
	ConcreteFunctions map[string]*SavedConcreteFunction `protobuf:"bytes,2,rep,name=concrete_functions,json=concreteFunctions,proto3" json:"concrete_functions,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SavedObjectGraph) Reset()         { *m = SavedObjectGraph{} }
func (m *SavedObjectGraph) String() string { return proto.CompactTextString(m) }
func (*SavedObjectGraph) ProtoMessage()    {}
func (*SavedObjectGraph) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f63c49021beb5aa, []int{0}
}
func (m *SavedObjectGraph) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SavedObjectGraph) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SavedObjectGraph.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SavedObjectGraph) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SavedObjectGraph.Merge(m, src)
}
func (m *SavedObjectGraph) XXX_Size() int {
	return m.Size()
}
func (m *SavedObjectGraph) XXX_DiscardUnknown() {
	xxx_messageInfo_SavedObjectGraph.DiscardUnknown(m)
}

var xxx_messageInfo_SavedObjectGraph proto.InternalMessageInfo

func (m *SavedObjectGraph) GetNodes() []*SavedObject {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *SavedObjectGraph) GetConcreteFunctions() map[string]*SavedConcreteFunction {
	if m != nil {
		return m.ConcreteFunctions
	}
	return nil
}

type SavedObject struct {
	// Objects which this object depends on: named edges in the dependency
	// graph.
	//
	// Note: currently only valid if kind == "user_object" or "resource".
	Children []*TrackableObjectGraph_TrackableObject_ObjectReference `protobuf:"bytes,1,rep,name=children,proto3" json:"children,omitempty"`
	// Slot variables owned by this object. This describes the three-way
	// (optimizer, variable, slot variable) relationship; none of the three
	// depend on the others directly.
	//
	// Note: currently only valid if kind == "user_object".
	SlotVariables []*TrackableObjectGraph_TrackableObject_SlotVariableReference `protobuf:"bytes,3,rep,name=slot_variables,json=slotVariables,proto3" json:"slot_variables,omitempty"`
	// Types that are valid to be assigned to Kind:
	//	*SavedObject_UserObject
	//	*SavedObject_Asset
	//	*SavedObject_Function
	//	*SavedObject_Variable
	//	*SavedObject_BareConcreteFunction
	//	*SavedObject_Constant
	//	*SavedObject_Resource
	Kind            isSavedObject_Kind         `protobuf_oneof:"kind"`
	SaveableObjects map[string]*SaveableObject `protobuf:"bytes,11,rep,name=saveable_objects,json=saveableObjects,proto3" json:"saveable_objects,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SavedObject) Reset()         { *m = SavedObject{} }
func (m *SavedObject) String() string { return proto.CompactTextString(m) }
func (*SavedObject) ProtoMessage()    {}
func (*SavedObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f63c49021beb5aa, []int{1}
}
func (m *SavedObject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SavedObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SavedObject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SavedObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SavedObject.Merge(m, src)
}
func (m *SavedObject) XXX_Size() int {
	return m.Size()
}
func (m *SavedObject) XXX_DiscardUnknown() {
	xxx_messageInfo_SavedObject.DiscardUnknown(m)
}

var xxx_messageInfo_SavedObject proto.InternalMessageInfo

type isSavedObject_Kind interface {
	isSavedObject_Kind()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SavedObject_UserObject struct {
	UserObject *SavedUserObject `protobuf:"bytes,4,opt,name=user_object,json=userObject,proto3,oneof" json:"user_object,omitempty"`
}
type SavedObject_Asset struct {
	Asset *SavedAsset `protobuf:"bytes,5,opt,name=asset,proto3,oneof" json:"asset,omitempty"`
}
type SavedObject_Function struct {
	Function *SavedFunction `protobuf:"bytes,6,opt,name=function,proto3,oneof" json:"function,omitempty"`
}
type SavedObject_Variable struct {
	Variable *SavedVariable `protobuf:"bytes,7,opt,name=variable,proto3,oneof" json:"variable,omitempty"`
}
type SavedObject_BareConcreteFunction struct {
	BareConcreteFunction *SavedBareConcreteFunction `protobuf:"bytes,8,opt,name=bare_concrete_function,json=bareConcreteFunction,proto3,oneof" json:"bare_concrete_function,omitempty"`
}
type SavedObject_Constant struct {
	Constant *SavedConstant `protobuf:"bytes,9,opt,name=constant,proto3,oneof" json:"constant,omitempty"`
}
type SavedObject_Resource struct {
	Resource *SavedResource `protobuf:"bytes,10,opt,name=resource,proto3,oneof" json:"resource,omitempty"`
}

func (*SavedObject_UserObject) isSavedObject_Kind()           {}
func (*SavedObject_Asset) isSavedObject_Kind()                {}
func (*SavedObject_Function) isSavedObject_Kind()             {}
func (*SavedObject_Variable) isSavedObject_Kind()             {}
func (*SavedObject_BareConcreteFunction) isSavedObject_Kind() {}
func (*SavedObject_Constant) isSavedObject_Kind()             {}
func (*SavedObject_Resource) isSavedObject_Kind()             {}

func (m *SavedObject) GetKind() isSavedObject_Kind {
	if m != nil {
		return m.Kind
	}
	return nil
}

func (m *SavedObject) GetChildren() []*TrackableObjectGraph_TrackableObject_ObjectReference {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *SavedObject) GetSlotVariables() []*TrackableObjectGraph_TrackableObject_SlotVariableReference {
	if m != nil {
		return m.SlotVariables
	}
	return nil
}

func (m *SavedObject) GetUserObject() *SavedUserObject {
	if x, ok := m.GetKind().(*SavedObject_UserObject); ok {
		return x.UserObject
	}
	return nil
}

func (m *SavedObject) GetAsset() *SavedAsset {
	if x, ok := m.GetKind().(*SavedObject_Asset); ok {
		return x.Asset
	}
	return nil
}

func (m *SavedObject) GetFunction() *SavedFunction {
	if x, ok := m.GetKind().(*SavedObject_Function); ok {
		return x.Function
	}
	return nil
}

func (m *SavedObject) GetVariable() *SavedVariable {
	if x, ok := m.GetKind().(*SavedObject_Variable); ok {
		return x.Variable
	}
	return nil
}

func (m *SavedObject) GetBareConcreteFunction() *SavedBareConcreteFunction {
	if x, ok := m.GetKind().(*SavedObject_BareConcreteFunction); ok {
		return x.BareConcreteFunction
	}
	return nil
}

func (m *SavedObject) GetConstant() *SavedConstant {
	if x, ok := m.GetKind().(*SavedObject_Constant); ok {
		return x.Constant
	}
	return nil
}

func (m *SavedObject) GetResource() *SavedResource {
	if x, ok := m.GetKind().(*SavedObject_Resource); ok {
		return x.Resource
	}
	return nil
}

func (m *SavedObject) GetSaveableObjects() map[string]*SaveableObject {
	if m != nil {
		return m.SaveableObjects
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SavedObject) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SavedObject_UserObject)(nil),
		(*SavedObject_Asset)(nil),
		(*SavedObject_Function)(nil),
		(*SavedObject_Variable)(nil),
		(*SavedObject_BareConcreteFunction)(nil),
		(*SavedObject_Constant)(nil),
		(*SavedObject_Resource)(nil),
	}
}

// A SavedUserObject is an object (in the object-oriented language of the
// TensorFlow program) of some user- or framework-defined class other than
// those handled specifically by the other kinds of SavedObjects.
//
// This object cannot be evaluated as a tensor, and therefore cannot be bound
// to an input of a function.
type SavedUserObject struct {
	// Corresponds to a registration of the type to use in the loading program.
	Identifier string `protobuf:"bytes,1,opt,name=identifier,proto3" json:"identifier,omitempty"`
	// Version information from the producer of this SavedUserObject.
	Version *framework.VersionDef `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// Deprecated! At the time of deprecation, Keras was the only user of this
	// field, and its saving and loading code will be updated shortly.
	// Please save your application-specific metadata to separate file
	// Initialization-related metadata.
	Metadata string `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *SavedUserObject) Reset()         { *m = SavedUserObject{} }
func (m *SavedUserObject) String() string { return proto.CompactTextString(m) }
func (*SavedUserObject) ProtoMessage()    {}
func (*SavedUserObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f63c49021beb5aa, []int{2}
}
func (m *SavedUserObject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SavedUserObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SavedUserObject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SavedUserObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SavedUserObject.Merge(m, src)
}
func (m *SavedUserObject) XXX_Size() int {
	return m.Size()
}
func (m *SavedUserObject) XXX_DiscardUnknown() {
	xxx_messageInfo_SavedUserObject.DiscardUnknown(m)
}

var xxx_messageInfo_SavedUserObject proto.InternalMessageInfo

func (m *SavedUserObject) GetIdentifier() string {
	if m != nil {
		return m.Identifier
	}
	return ""
}

func (m *SavedUserObject) GetVersion() *framework.VersionDef {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *SavedUserObject) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

// A SavedAsset points to an asset in the MetaGraph.
//
// When bound to a function this object evaluates to a tensor with the absolute
// filename. Users should not depend on a particular part of the filename to
// remain stable (e.g. basename could be changed).
type SavedAsset struct {
	// Index into `MetaGraphDef.asset_file_def[]` that describes the Asset.
	//
	// Only the field `AssetFileDef.filename` is used. Other fields, such as
	// `AssetFileDef.tensor_info`, MUST be ignored.
	AssetFileDefIndex int32 `protobuf:"varint,1,opt,name=asset_file_def_index,json=assetFileDefIndex,proto3" json:"asset_file_def_index,omitempty"`
}

func (m *SavedAsset) Reset()         { *m = SavedAsset{} }
func (m *SavedAsset) String() string { return proto.CompactTextString(m) }
func (*SavedAsset) ProtoMessage()    {}
func (*SavedAsset) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f63c49021beb5aa, []int{3}
}
func (m *SavedAsset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SavedAsset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SavedAsset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SavedAsset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SavedAsset.Merge(m, src)
}
func (m *SavedAsset) XXX_Size() int {
	return m.Size()
}
func (m *SavedAsset) XXX_DiscardUnknown() {
	xxx_messageInfo_SavedAsset.DiscardUnknown(m)
}

var xxx_messageInfo_SavedAsset proto.InternalMessageInfo

func (m *SavedAsset) GetAssetFileDefIndex() int32 {
	if m != nil {
		return m.AssetFileDefIndex
	}
	return 0
}

// A function with multiple signatures, possibly with non-Tensor arguments.
type SavedFunction struct {
	ConcreteFunctions []string      `protobuf:"bytes,1,rep,name=concrete_functions,json=concreteFunctions,proto3" json:"concrete_functions,omitempty"`
	FunctionSpec      *FunctionSpec `protobuf:"bytes,2,opt,name=function_spec,json=functionSpec,proto3" json:"function_spec,omitempty"`
}

func (m *SavedFunction) Reset()         { *m = SavedFunction{} }
func (m *SavedFunction) String() string { return proto.CompactTextString(m) }
func (*SavedFunction) ProtoMessage()    {}
func (*SavedFunction) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f63c49021beb5aa, []int{4}
}
func (m *SavedFunction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SavedFunction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SavedFunction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SavedFunction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SavedFunction.Merge(m, src)
}
func (m *SavedFunction) XXX_Size() int {
	return m.Size()
}
func (m *SavedFunction) XXX_DiscardUnknown() {
	xxx_messageInfo_SavedFunction.DiscardUnknown(m)
}

var xxx_messageInfo_SavedFunction proto.InternalMessageInfo

func (m *SavedFunction) GetConcreteFunctions() []string {
	if m != nil {
		return m.ConcreteFunctions
	}
	return nil
}

func (m *SavedFunction) GetFunctionSpec() *FunctionSpec {
	if m != nil {
		return m.FunctionSpec
	}
	return nil
}

// Stores low-level information about a concrete function. Referenced in either
// a SavedFunction or a SavedBareConcreteFunction.
type SavedConcreteFunction struct {
	// Bound inputs to the function. The SavedObjects identified by the node ids
	// given here are appended as extra inputs to the caller-supplied inputs.
	// The only types of SavedObjects valid here are SavedVariable, SavedResource
	// and SavedAsset.
	BoundInputs []int32 `protobuf:"varint,2,rep,packed,name=bound_inputs,json=boundInputs,proto3" json:"bound_inputs,omitempty"`
	// Input in canonicalized form that was received to create this concrete
	// function.
	CanonicalizedInputSignature *StructuredValue `protobuf:"bytes,3,opt,name=canonicalized_input_signature,json=canonicalizedInputSignature,proto3" json:"canonicalized_input_signature,omitempty"`
	// Output that was the return value of this function after replacing all
	// Tensors with TensorSpecs. This can be an arbitrary nested function and will
	// be used to reconstruct the full structure from pure tensors.
	OutputSignature *StructuredValue `protobuf:"bytes,4,opt,name=output_signature,json=outputSignature,proto3" json:"output_signature,omitempty"`
}

func (m *SavedConcreteFunction) Reset()         { *m = SavedConcreteFunction{} }
func (m *SavedConcreteFunction) String() string { return proto.CompactTextString(m) }
func (*SavedConcreteFunction) ProtoMessage()    {}
func (*SavedConcreteFunction) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f63c49021beb5aa, []int{5}
}
func (m *SavedConcreteFunction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SavedConcreteFunction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SavedConcreteFunction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SavedConcreteFunction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SavedConcreteFunction.Merge(m, src)
}
func (m *SavedConcreteFunction) XXX_Size() int {
	return m.Size()
}
func (m *SavedConcreteFunction) XXX_DiscardUnknown() {
	xxx_messageInfo_SavedConcreteFunction.DiscardUnknown(m)
}

var xxx_messageInfo_SavedConcreteFunction proto.InternalMessageInfo

func (m *SavedConcreteFunction) GetBoundInputs() []int32 {
	if m != nil {
		return m.BoundInputs
	}
	return nil
}

func (m *SavedConcreteFunction) GetCanonicalizedInputSignature() *StructuredValue {
	if m != nil {
		return m.CanonicalizedInputSignature
	}
	return nil
}

func (m *SavedConcreteFunction) GetOutputSignature() *StructuredValue {
	if m != nil {
		return m.OutputSignature
	}
	return nil
}

type SavedBareConcreteFunction struct {
	// Identifies a SavedConcreteFunction.
	ConcreteFunctionName string `protobuf:"bytes,1,opt,name=concrete_function_name,json=concreteFunctionName,proto3" json:"concrete_function_name,omitempty"`
	// A sequence of unique strings, one per Tensor argument.
	ArgumentKeywords []string `protobuf:"bytes,2,rep,name=argument_keywords,json=argumentKeywords,proto3" json:"argument_keywords,omitempty"`
	// The prefix of `argument_keywords` which may be identified by position.
	AllowedPositionalArguments int64 `protobuf:"varint,3,opt,name=allowed_positional_arguments,json=allowedPositionalArguments,proto3" json:"allowed_positional_arguments,omitempty"`
	// The spec of the function that this ConcreteFunction is traced from. This
	// allows the ConcreteFunction to be called with nest structure inputs. This
	// field may not be populated. If this field is absent, the concrete function
	// can only be called with flat inputs.
	// TODO(b/169361281): support calling saved ConcreteFunction with structured
	// inputs in C++ SavedModel API.
	FunctionSpec *FunctionSpec `protobuf:"bytes,4,opt,name=function_spec,json=functionSpec,proto3" json:"function_spec,omitempty"`
}

func (m *SavedBareConcreteFunction) Reset()         { *m = SavedBareConcreteFunction{} }
func (m *SavedBareConcreteFunction) String() string { return proto.CompactTextString(m) }
func (*SavedBareConcreteFunction) ProtoMessage()    {}
func (*SavedBareConcreteFunction) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f63c49021beb5aa, []int{6}
}
func (m *SavedBareConcreteFunction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SavedBareConcreteFunction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SavedBareConcreteFunction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SavedBareConcreteFunction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SavedBareConcreteFunction.Merge(m, src)
}
func (m *SavedBareConcreteFunction) XXX_Size() int {
	return m.Size()
}
func (m *SavedBareConcreteFunction) XXX_DiscardUnknown() {
	xxx_messageInfo_SavedBareConcreteFunction.DiscardUnknown(m)
}

var xxx_messageInfo_SavedBareConcreteFunction proto.InternalMessageInfo

func (m *SavedBareConcreteFunction) GetConcreteFunctionName() string {
	if m != nil {
		return m.ConcreteFunctionName
	}
	return ""
}

func (m *SavedBareConcreteFunction) GetArgumentKeywords() []string {
	if m != nil {
		return m.ArgumentKeywords
	}
	return nil
}

func (m *SavedBareConcreteFunction) GetAllowedPositionalArguments() int64 {
	if m != nil {
		return m.AllowedPositionalArguments
	}
	return 0
}

func (m *SavedBareConcreteFunction) GetFunctionSpec() *FunctionSpec {
	if m != nil {
		return m.FunctionSpec
	}
	return nil
}

type SavedConstant struct {
	// An Operation name for a ConstantOp in this SavedObjectGraph's MetaGraph.
	Operation string `protobuf:"bytes,1,opt,name=operation,proto3" json:"operation,omitempty"`
}

func (m *SavedConstant) Reset()         { *m = SavedConstant{} }
func (m *SavedConstant) String() string { return proto.CompactTextString(m) }
func (*SavedConstant) ProtoMessage()    {}
func (*SavedConstant) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f63c49021beb5aa, []int{7}
}
func (m *SavedConstant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SavedConstant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SavedConstant.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SavedConstant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SavedConstant.Merge(m, src)
}
func (m *SavedConstant) XXX_Size() int {
	return m.Size()
}
func (m *SavedConstant) XXX_DiscardUnknown() {
	xxx_messageInfo_SavedConstant.DiscardUnknown(m)
}

var xxx_messageInfo_SavedConstant proto.InternalMessageInfo

func (m *SavedConstant) GetOperation() string {
	if m != nil {
		return m.Operation
	}
	return ""
}

// Represents a Variable that is initialized by loading the contents from the
// checkpoint.
type SavedVariable struct {
	Dtype           framework.DataType                `protobuf:"varint,1,opt,name=dtype,proto3,enum=tensorflow.DataType" json:"dtype,omitempty"`
	Shape           *framework.TensorShapeProto       `protobuf:"bytes,2,opt,name=shape,proto3" json:"shape,omitempty"`
	Trainable       bool                              `protobuf:"varint,3,opt,name=trainable,proto3" json:"trainable,omitempty"`
	Synchronization framework.VariableSynchronization `protobuf:"varint,4,opt,name=synchronization,proto3,enum=tensorflow.VariableSynchronization" json:"synchronization,omitempty"`
	Aggregation     framework.VariableAggregation     `protobuf:"varint,5,opt,name=aggregation,proto3,enum=tensorflow.VariableAggregation" json:"aggregation,omitempty"`
	Name            string                            `protobuf:"bytes,6,opt,name=name,proto3" json:"name,omitempty"`
	Device          string                            `protobuf:"bytes,7,opt,name=device,proto3" json:"device,omitempty"`
	// List of component variables for a distributed variable.
	//
	// When this field is non-empty, the SavedVariable will be assumed
	// to be a distributed variable defined by the components listed here.
	//
	// This is only supported by experimental loaders at the moment.
	ExperimentalDistributedVariableComponents []*SavedVariable `protobuf:"bytes,8,rep,name=experimental_distributed_variable_components,json=experimentalDistributedVariableComponents,proto3" json:"experimental_distributed_variable_components,omitempty"`
}

func (m *SavedVariable) Reset()         { *m = SavedVariable{} }
func (m *SavedVariable) String() string { return proto.CompactTextString(m) }
func (*SavedVariable) ProtoMessage()    {}
func (*SavedVariable) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f63c49021beb5aa, []int{8}
}
func (m *SavedVariable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SavedVariable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SavedVariable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SavedVariable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SavedVariable.Merge(m, src)
}
func (m *SavedVariable) XXX_Size() int {
	return m.Size()
}
func (m *SavedVariable) XXX_DiscardUnknown() {
	xxx_messageInfo_SavedVariable.DiscardUnknown(m)
}

var xxx_messageInfo_SavedVariable proto.InternalMessageInfo

func (m *SavedVariable) GetDtype() framework.DataType {
	if m != nil {
		return m.Dtype
	}
	return framework.DataType_DT_INVALID
}

func (m *SavedVariable) GetShape() *framework.TensorShapeProto {
	if m != nil {
		return m.Shape
	}
	return nil
}

func (m *SavedVariable) GetTrainable() bool {
	if m != nil {
		return m.Trainable
	}
	return false
}

func (m *SavedVariable) GetSynchronization() framework.VariableSynchronization {
	if m != nil {
		return m.Synchronization
	}
	return framework.VariableSynchronization_VARIABLE_SYNCHRONIZATION_AUTO
}

func (m *SavedVariable) GetAggregation() framework.VariableAggregation {
	if m != nil {
		return m.Aggregation
	}
	return framework.VariableAggregation_VARIABLE_AGGREGATION_NONE
}

func (m *SavedVariable) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SavedVariable) GetDevice() string {
	if m != nil {
		return m.Device
	}
	return ""
}

func (m *SavedVariable) GetExperimentalDistributedVariableComponents() []*SavedVariable {
	if m != nil {
		return m.ExperimentalDistributedVariableComponents
	}
	return nil
}

// Represents `FunctionSpec` used in `Function`. This represents a
// function that has been wrapped as a TensorFlow `Function`.
type FunctionSpec struct {
	// Full arg spec from inspect.getfullargspec().
	Fullargspec *StructuredValue `protobuf:"bytes,1,opt,name=fullargspec,proto3" json:"fullargspec,omitempty"`
	// Whether this represents a class method.
	IsMethod bool `protobuf:"varint,2,opt,name=is_method,json=isMethod,proto3" json:"is_method,omitempty"`
	// The input signature, if specified.
	InputSignature *StructuredValue        `protobuf:"bytes,5,opt,name=input_signature,json=inputSignature,proto3" json:"input_signature,omitempty"`
	JitCompile     FunctionSpec_JitCompile `protobuf:"varint,6,opt,name=jit_compile,json=jitCompile,proto3,enum=tensorflow.FunctionSpec_JitCompile" json:"jit_compile,omitempty"`
}

func (m *FunctionSpec) Reset()         { *m = FunctionSpec{} }
func (m *FunctionSpec) String() string { return proto.CompactTextString(m) }
func (*FunctionSpec) ProtoMessage()    {}
func (*FunctionSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f63c49021beb5aa, []int{9}
}
func (m *FunctionSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FunctionSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FunctionSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FunctionSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FunctionSpec.Merge(m, src)
}
func (m *FunctionSpec) XXX_Size() int {
	return m.Size()
}
func (m *FunctionSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_FunctionSpec.DiscardUnknown(m)
}

var xxx_messageInfo_FunctionSpec proto.InternalMessageInfo

func (m *FunctionSpec) GetFullargspec() *StructuredValue {
	if m != nil {
		return m.Fullargspec
	}
	return nil
}

func (m *FunctionSpec) GetIsMethod() bool {
	if m != nil {
		return m.IsMethod
	}
	return false
}

func (m *FunctionSpec) GetInputSignature() *StructuredValue {
	if m != nil {
		return m.InputSignature
	}
	return nil
}

func (m *FunctionSpec) GetJitCompile() FunctionSpec_JitCompile {
	if m != nil {
		return m.JitCompile
	}
	return FunctionSpec_DEFAULT
}

// A SavedResource represents a TF object that holds state during its lifetime.
// An object of this type can have a reference to a:
// create_resource() and an initialize() function.
type SavedResource struct {
	// A device specification indicating a required placement for the resource
	// creation function, e.g. "CPU". An empty string allows the user to select a
	// device.
	Device string `protobuf:"bytes,1,opt,name=device,proto3" json:"device,omitempty"`
}

func (m *SavedResource) Reset()         { *m = SavedResource{} }
func (m *SavedResource) String() string { return proto.CompactTextString(m) }
func (*SavedResource) ProtoMessage()    {}
func (*SavedResource) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f63c49021beb5aa, []int{10}
}
func (m *SavedResource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SavedResource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SavedResource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SavedResource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SavedResource.Merge(m, src)
}
func (m *SavedResource) XXX_Size() int {
	return m.Size()
}
func (m *SavedResource) XXX_DiscardUnknown() {
	xxx_messageInfo_SavedResource.DiscardUnknown(m)
}

var xxx_messageInfo_SavedResource proto.InternalMessageInfo

func (m *SavedResource) GetDevice() string {
	if m != nil {
		return m.Device
	}
	return ""
}

type SaveableObject struct {
	// Node ids of concrete functions for saving and loading from a checkpoint.
	SaveFunction    int32 `protobuf:"varint,2,opt,name=save_function,json=saveFunction,proto3" json:"save_function,omitempty"`
	RestoreFunction int32 `protobuf:"varint,3,opt,name=restore_function,json=restoreFunction,proto3" json:"restore_function,omitempty"`
}

func (m *SaveableObject) Reset()         { *m = SaveableObject{} }
func (m *SaveableObject) String() string { return proto.CompactTextString(m) }
func (*SaveableObject) ProtoMessage()    {}
func (*SaveableObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f63c49021beb5aa, []int{11}
}
func (m *SaveableObject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SaveableObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SaveableObject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SaveableObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SaveableObject.Merge(m, src)
}
func (m *SaveableObject) XXX_Size() int {
	return m.Size()
}
func (m *SaveableObject) XXX_DiscardUnknown() {
	xxx_messageInfo_SaveableObject.DiscardUnknown(m)
}

var xxx_messageInfo_SaveableObject proto.InternalMessageInfo

func (m *SaveableObject) GetSaveFunction() int32 {
	if m != nil {
		return m.SaveFunction
	}
	return 0
}

func (m *SaveableObject) GetRestoreFunction() int32 {
	if m != nil {
		return m.RestoreFunction
	}
	return 0
}

func init() {
	proto.RegisterEnum("tensorflow.FunctionSpec_JitCompile", FunctionSpec_JitCompile_name, FunctionSpec_JitCompile_value)
	proto.RegisterType((*SavedObjectGraph)(nil), "tensorflow.SavedObjectGraph")
	proto.RegisterMapType((map[string]*SavedConcreteFunction)(nil), "tensorflow.SavedObjectGraph.ConcreteFunctionsEntry")
	proto.RegisterType((*SavedObject)(nil), "tensorflow.SavedObject")
	proto.RegisterMapType((map[string]*SaveableObject)(nil), "tensorflow.SavedObject.SaveableObjectsEntry")
	proto.RegisterType((*SavedUserObject)(nil), "tensorflow.SavedUserObject")
	proto.RegisterType((*SavedAsset)(nil), "tensorflow.SavedAsset")
	proto.RegisterType((*SavedFunction)(nil), "tensorflow.SavedFunction")
	proto.RegisterType((*SavedConcreteFunction)(nil), "tensorflow.SavedConcreteFunction")
	proto.RegisterType((*SavedBareConcreteFunction)(nil), "tensorflow.SavedBareConcreteFunction")
	proto.RegisterType((*SavedConstant)(nil), "tensorflow.SavedConstant")
	proto.RegisterType((*SavedVariable)(nil), "tensorflow.SavedVariable")
	proto.RegisterType((*FunctionSpec)(nil), "tensorflow.FunctionSpec")
	proto.RegisterType((*SavedResource)(nil), "tensorflow.SavedResource")
	proto.RegisterType((*SaveableObject)(nil), "tensorflow.SaveableObject")
}

func init() {
	proto.RegisterFile("tensorflow/core/protobuf/saved_object_graph.proto", fileDescriptor_4f63c49021beb5aa)
}

var fileDescriptor_4f63c49021beb5aa = []byte{
	// 1320 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x57, 0x5d, 0x6f, 0xdb, 0x36,
	0x17, 0xb6, 0xfc, 0x15, 0xfb, 0x38, 0x1f, 0x2e, 0x91, 0x37, 0xaf, 0xea, 0x76, 0x5e, 0xeb, 0xa2,
	0x58, 0xda, 0x35, 0x76, 0x97, 0x6e, 0xe8, 0x30, 0xa0, 0x43, 0xdd, 0xb8, 0x5e, 0x9a, 0xad, 0x1f,
	0x60, 0xda, 0x0e, 0x18, 0xb6, 0x6a, 0xb4, 0x44, 0x3b, 0x6c, 0x64, 0x51, 0x20, 0xa9, 0xa4, 0x29,
	0x30, 0xec, 0x1f, 0x0c, 0xfb, 0x25, 0xfb, 0x1b, 0xdb, 0x65, 0x2f, 0x77, 0x59, 0x34, 0x7f, 0x62,
	0x77, 0x1b, 0x44, 0x49, 0xb6, 0xfc, 0xb5, 0xac, 0x77, 0xe2, 0xe1, 0xf3, 0x3c, 0x3c, 0x3c, 0x3c,
	0xe7, 0x90, 0x82, 0x4f, 0x14, 0xf5, 0x24, 0x17, 0x7d, 0x97, 0x1f, 0xb7, 0x6c, 0x2e, 0x68, 0xcb,
	0x17, 0x5c, 0xf1, 0x5e, 0xd0, 0x6f, 0x49, 0x72, 0x44, 0x1d, 0x8b, 0xf7, 0x5e, 0x52, 0x5b, 0x59,
	0x03, 0x41, 0xfc, 0x83, 0xa6, 0x9e, 0x43, 0x30, 0xa6, 0xd4, 0x6e, 0x4c, 0xd3, 0xfb, 0x82, 0x0c,
	0xe9, 0x31, 0x17, 0x87, 0xad, 0x68, 0xc6, 0x92, 0x07, 0xc4, 0xa7, 0x11, 0xb3, 0x76, 0xf5, 0x5f,
	0xd0, 0x27, 0x3e, 0x95, 0x31, 0x6c, 0x73, 0x31, 0xec, 0x88, 0x08, 0x46, 0x7a, 0x2e, 0xfd, 0x0f,
	0x48, 0x2a, 0x24, 0xe3, 0x9e, 0x5c, 0xb4, 0xf4, 0x78, 0x9f, 0x4a, 0x04, 0xb6, 0x8a, 0x61, 0x9f,
	0x2d, 0x84, 0x29, 0x41, 0xec, 0xc3, 0x70, 0xe9, 0x39, 0x21, 0x69, 0xfc, 0x92, 0x85, 0xea, 0x7e,
	0x18, 0xaf, 0xc7, 0x7a, 0xee, 0xab, 0x70, 0x0a, 0x6d, 0x41, 0xc1, 0xe3, 0x0e, 0x95, 0xa6, 0x71,
	0x29, 0xb7, 0x59, 0xd9, 0xfe, 0x7f, 0x73, 0xac, 0xdd, 0x4c, 0x81, 0x71, 0x84, 0x42, 0x3d, 0x40,
	0x36, 0xf7, 0x6c, 0x41, 0x15, 0xb5, 0xfa, 0x81, 0x67, 0xab, 0xd0, 0x7b, 0x33, 0xab, 0xb9, 0xb7,
	0x16, 0x70, 0xf5, 0x42, 0xcd, 0x9d, 0x98, 0xd6, 0x4d, 0x58, 0xf7, 0x3d, 0x25, 0x4e, 0xf0, 0x39,
	0x7b, 0xda, 0x5e, 0x1b, 0xc0, 0xc6, 0x7c, 0x30, 0xaa, 0x42, 0xee, 0x90, 0x9e, 0x98, 0xc6, 0x25,
	0x63, 0xb3, 0x8c, 0xc3, 0x4f, 0x74, 0x1b, 0x0a, 0x47, 0xc4, 0x0d, 0xa8, 0x99, 0xbd, 0x64, 0x6c,
	0x56, 0xb6, 0x2f, 0xcf, 0xb8, 0x30, 0xad, 0x84, 0x23, 0xfc, 0x17, 0xd9, 0xcf, 0x8d, 0xc6, 0xdb,
	0x22, 0x54, 0x52, 0x7e, 0xa2, 0xef, 0xa1, 0x64, 0x1f, 0x30, 0xd7, 0x11, 0xd4, 0x8b, 0xc3, 0x71,
	0x37, 0xad, 0xf7, 0x34, 0x09, 0x6e, 0x7a, 0x5b, 0x53, 0xc6, 0x66, 0x1c, 0x2e, 0xda, 0xa7, 0x82,
	0x7a, 0x36, 0xc5, 0x23, 0x45, 0x34, 0x84, 0x55, 0xe9, 0x72, 0x65, 0x25, 0xd9, 0x21, 0xcd, 0x9c,
	0x5e, 0xa3, 0xfb, 0xde, 0x6b, 0xec, 0xbb, 0x5c, 0x3d, 0x8f, 0x55, 0xc6, 0x2b, 0xad, 0xc8, 0x94,
	0x59, 0xa2, 0x2f, 0xa1, 0x12, 0x48, 0x2a, 0xe2, 0x44, 0x30, 0xf3, 0x3a, 0x3e, 0x17, 0x66, 0xe2,
	0xf3, 0x4c, 0x52, 0x11, 0xc9, 0xee, 0x66, 0x30, 0x04, 0xa3, 0x11, 0x6a, 0x42, 0x81, 0x48, 0x49,
	0x95, 0x59, 0xd0, 0xcc, 0x8d, 0x19, 0x66, 0x3b, 0x9c, 0xdd, 0xcd, 0xe0, 0x08, 0x86, 0x6e, 0x43,
	0x29, 0x49, 0x08, 0xb3, 0xa8, 0x29, 0xe7, 0x67, 0x28, 0xc9, 0x21, 0xec, 0x66, 0xf0, 0x08, 0x1c,
	0x12, 0x93, 0x90, 0x98, 0x4b, 0x0b, 0x88, 0xc9, 0xb6, 0x42, 0x62, 0x02, 0x46, 0x3f, 0xc0, 0x46,
	0x8f, 0x08, 0x6a, 0xcd, 0x24, 0xa4, 0x59, 0xd2, 0x32, 0x57, 0x67, 0x64, 0xee, 0x11, 0x41, 0xa7,
	0x13, 0x62, 0x37, 0x83, 0xd7, 0x7b, 0x73, 0xec, 0xa1, 0x5f, 0x36, 0xf7, 0xa4, 0x22, 0x9e, 0x32,
	0xcb, 0x0b, 0xfc, 0xda, 0x89, 0x01, 0xa1, 0x5f, 0x09, 0x38, 0x24, 0x0a, 0x2a, 0x79, 0x20, 0x6c,
	0x6a, 0xc2, 0x02, 0x22, 0x8e, 0x01, 0x21, 0x31, 0x01, 0xa3, 0x6f, 0xa1, 0x1a, 0xf6, 0xb3, 0x54,
	0xfd, 0x4a, 0xb3, 0xa2, 0x73, 0xe4, 0xc6, 0x82, 0xd2, 0xd2, 0xdf, 0xe3, 0xcc, 0x88, 0x6b, 0x6a,
	0x4d, 0x4e, 0x5a, 0x6b, 0x2f, 0x60, 0x7d, 0x1e, 0x70, 0x4e, 0x3d, 0xdd, 0x9c, 0xac, 0xa7, 0xda,
	0xf4, 0xba, 0x63, 0x89, 0x54, 0x21, 0xdd, 0x2b, 0x42, 0xfe, 0x90, 0x79, 0xce, 0x5e, 0xbe, 0x94,
	0xad, 0xe6, 0x30, 0x10, 0xa5, 0x04, 0xeb, 0x05, 0x8a, 0xca, 0xc6, 0xcf, 0xb0, 0x36, 0x95, 0x66,
	0xa8, 0x0e, 0xc0, 0x1c, 0xea, 0x29, 0xd6, 0x67, 0x54, 0xc4, 0x6b, 0xa7, 0x2c, 0xe8, 0x26, 0x2c,
	0xc5, 0x6d, 0x31, 0x76, 0x62, 0x22, 0xf5, 0x9e, 0x47, 0x53, 0x1d, 0xda, 0xc7, 0x09, 0x0c, 0xd5,
	0xa0, 0x34, 0xa4, 0x8a, 0x38, 0x44, 0x11, 0x33, 0xa7, 0xf5, 0x46, 0xe3, 0xc6, 0x1d, 0x80, 0x71,
	0xb6, 0xa2, 0x16, 0xac, 0xeb, 0x6c, 0xb5, 0xfa, 0xcc, 0xa5, 0x96, 0x43, 0xfb, 0x16, 0xf3, 0x1c,
	0xfa, 0x4a, 0x7b, 0x51, 0xc0, 0xe7, 0xf4, 0x5c, 0x97, 0xb9, 0xb4, 0x43, 0xfb, 0x0f, 0xc2, 0x89,
	0xc6, 0x4f, 0xb0, 0x32, 0x91, 0xb9, 0x68, 0x6b, 0x6e, 0x03, 0x0c, 0xbb, 0x45, 0x79, 0x4e, 0x2f,
	0x43, 0x77, 0x60, 0x25, 0x41, 0x59, 0xd2, 0xa7, 0x76, 0xbc, 0x25, 0x33, 0xbd, 0xa5, 0x04, 0xbd,
	0xef, 0x53, 0x1b, 0x2f, 0xf7, 0x53, 0xa3, 0xc6, 0xa9, 0x01, 0xff, 0x9b, 0xdb, 0xc6, 0xd0, 0x65,
	0x58, 0xee, 0xf1, 0xc0, 0x73, 0x2c, 0xe6, 0xf9, 0x81, 0x8a, 0x5a, 0x70, 0x01, 0x57, 0xb4, 0xed,
	0x81, 0x36, 0x21, 0x0b, 0x3e, 0xb0, 0x89, 0xc7, 0x3d, 0x66, 0x13, 0x97, 0xbd, 0xa6, 0x31, 0xd4,
	0x92, 0x6c, 0xe0, 0x11, 0x15, 0x08, 0xaa, 0x63, 0x35, 0xdd, 0x13, 0xf4, 0x3d, 0x13, 0x88, 0xb0,
	0xe4, 0xdc, 0x80, 0xe2, 0x0b, 0x13, 0x0a, 0x5a, 0x78, 0x3f, 0xe1, 0xa3, 0x2e, 0x54, 0x79, 0xa0,
	0x26, 0x35, 0xf3, 0x67, 0x6b, 0xae, 0x45, 0xa4, 0x91, 0x4e, 0xe3, 0x6f, 0x03, 0xce, 0x2f, 0xac,
	0x4f, 0xf4, 0x29, 0x6c, 0xcc, 0x44, 0xdc, 0xf2, 0xc8, 0x90, 0xc6, 0xb9, 0xb3, 0x3e, 0x1d, 0xf5,
	0x47, 0x64, 0x48, 0xd1, 0xc7, 0x70, 0x8e, 0x88, 0x41, 0x30, 0xa4, 0x9e, 0xb2, 0x0e, 0xe9, 0xc9,
	0x31, 0x17, 0x4e, 0x14, 0xa4, 0x32, 0xae, 0x26, 0x13, 0x5f, 0xc7, 0x76, 0x74, 0x17, 0x2e, 0x12,
	0xd7, 0xe5, 0xc7, 0xd4, 0xb1, 0x7c, 0x2e, 0x59, 0x28, 0x42, 0x5c, 0x2b, 0x81, 0x49, 0x1d, 0xa8,
	0x1c, 0xae, 0xc5, 0x98, 0x27, 0x23, 0x48, 0x3b, 0x41, 0xcc, 0x9e, 0x73, 0xfe, 0xbd, 0xce, 0x79,
	0x2b, 0x4e, 0xb3, 0xa4, 0x9f, 0xa0, 0x8b, 0x50, 0xe6, 0x3e, 0x15, 0x44, 0xb7, 0xb3, 0x68, 0x9f,
	0x63, 0x43, 0xe3, 0xf7, 0x5c, 0x8c, 0x4f, 0xfa, 0x22, 0xba, 0x0e, 0x05, 0x27, 0x7c, 0x9d, 0x68,
	0xec, 0xea, 0xf6, 0x7a, 0x7a, 0xdd, 0x0e, 0x51, 0xe4, 0xe9, 0x89, 0x4f, 0x71, 0x04, 0x41, 0xdb,
	0x50, 0xd0, 0xef, 0x9d, 0x38, 0x17, 0x2f, 0x4e, 0xdc, 0x3f, 0xfa, 0x73, 0x3f, 0x9c, 0x7e, 0x12,
	0x3e, 0x1a, 0x70, 0x04, 0x0d, 0xfd, 0x51, 0x82, 0x30, 0x4f, 0x77, 0xe9, 0x30, 0x1c, 0x25, 0x3c,
	0x36, 0xa0, 0x87, 0xb0, 0x26, 0x4f, 0x3c, 0xfb, 0x40, 0x70, 0x8f, 0xbd, 0x8e, 0x7c, 0xce, 0x6b,
	0x3f, 0xae, 0x4c, 0x94, 0x6e, 0xec, 0xec, 0xfe, 0x24, 0x14, 0x4f, 0x73, 0x51, 0x1b, 0x2a, 0x64,
	0x30, 0x10, 0x74, 0x10, 0x49, 0x15, 0xb4, 0xd4, 0x87, 0xf3, 0xa4, 0xda, 0x63, 0x18, 0x4e, 0x73,
	0x10, 0x82, 0xbc, 0x4e, 0x91, 0xa2, 0x0e, 0x9d, 0xfe, 0x46, 0x1b, 0x50, 0x74, 0xe8, 0x11, 0xb3,
	0xa3, 0x6b, 0xa6, 0x8c, 0xe3, 0x11, 0x7a, 0x0d, 0x37, 0xe8, 0x2b, 0x9f, 0x0a, 0x16, 0x1e, 0x25,
	0x71, 0x2d, 0x87, 0xc9, 0xb8, 0x7f, 0x39, 0xa3, 0xcb, 0xda, 0xb2, 0xf9, 0xd0, 0xe7, 0x9e, 0xce,
	0x86, 0x92, 0x6e, 0xc9, 0x8b, 0x2f, 0x29, 0x7c, 0x2d, 0x2d, 0xd7, 0x19, 0xab, 0x25, 0x80, 0x9d,
	0x91, 0x56, 0xe3, 0xb7, 0x2c, 0x2c, 0xa7, 0xf3, 0x02, 0xdd, 0x81, 0x4a, 0x3f, 0x70, 0x5d, 0x22,
	0x06, 0x3a, 0x8d, 0x8c, 0xb3, 0xcb, 0x29, 0x8d, 0x47, 0x17, 0xa0, 0xcc, 0xa4, 0x35, 0xa4, 0xea,
	0x80, 0x3b, 0xfa, 0x7c, 0x4b, 0xb8, 0xc4, 0xe4, 0x43, 0x3d, 0x46, 0x1d, 0x58, 0x9b, 0x6e, 0x01,
	0x85, 0xb3, 0xf5, 0x57, 0xd9, 0x64, 0xd5, 0x77, 0xa0, 0xf2, 0x92, 0x29, 0x1d, 0x10, 0xe6, 0x46,
	0x11, 0x9e, 0x3a, 0xe8, 0xf4, 0x86, 0x9a, 0x7b, 0x4c, 0xed, 0x44, 0x50, 0x0c, 0x2f, 0x47, 0xdf,
	0x8d, 0xeb, 0x00, 0xe3, 0x19, 0x54, 0x81, 0xa5, 0xce, 0xfd, 0x6e, 0xfb, 0xd9, 0x37, 0x4f, 0xab,
	0x19, 0x54, 0x84, 0xec, 0xe3, 0x47, 0x55, 0x03, 0x2d, 0x41, 0xee, 0x71, 0xb7, 0x5b, 0xcd, 0xee,
	0xe5, 0x4b, 0xb9, 0x6a, 0x7e, 0x2f, 0x5f, 0xca, 0x57, 0x0b, 0x8d, 0x8f, 0xe2, 0xcc, 0x4f, 0x2e,
	0xd0, 0xd4, 0xa9, 0x1a, 0xe9, 0x53, 0x6d, 0xfc, 0x08, 0xab, 0x93, 0x17, 0x16, 0xba, 0x02, 0x2b,
	0xe1, 0xc5, 0x38, 0x7e, 0x26, 0x64, 0x75, 0xd7, 0x5f, 0x0e, 0x8d, 0xa3, 0x6e, 0x73, 0x0d, 0xaa,
	0x82, 0x4a, 0xc5, 0x45, 0x0a, 0x97, 0xd3, 0xb8, 0xb5, 0xd8, 0x9e, 0x40, 0xef, 0xbd, 0xf8, 0xe3,
	0x5d, 0xdd, 0x78, 0xf3, 0xae, 0x6e, 0xbc, 0x7d, 0x57, 0x37, 0x7e, 0x3d, 0xad, 0x67, 0xde, 0x9c,
	0xd6, 0x33, 0x7f, 0x9e, 0xd6, 0x33, 0xdf, 0xb5, 0x07, 0x4c, 0x1d, 0x04, 0xbd, 0xa6, 0xcd, 0x87,
	0xad, 0xb6, 0xef, 0xbb, 0xfa, 0x62, 0x6b, 0x0d, 0xf8, 0x56, 0xea, 0xe1, 0xae, 0xff, 0x25, 0x5a,
	0x8b, 0x5e, 0xf2, 0x7f, 0x19, 0x46, 0xaf, 0xa8, 0x07, 0xb7, 0xfe, 0x09, 0x00, 0x00, 0xff, 0xff,
	0x0b, 0x7c, 0x21, 0x57, 0xfe, 0x0c, 0x00, 0x00,
}

func (m *SavedObjectGraph) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SavedObjectGraph) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedObjectGraph) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ConcreteFunctions) > 0 {
		for k := range m.ConcreteFunctions {
			v := m.ConcreteFunctions[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SavedObject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SavedObject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedObject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SaveableObjects) > 0 {
		for k := range m.SaveableObjects {
			v := m.SaveableObjects[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.Kind != nil {
		{
			size := m.Kind.Size()
			i -= size
			if _, err := m.Kind.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.SlotVariables) > 0 {
		for iNdEx := len(m.SlotVariables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SlotVariables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Children) > 0 {
		for iNdEx := len(m.Children) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Children[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SavedObject_UserObject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedObject_UserObject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UserObject != nil {
		{
			size, err := m.UserObject.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *SavedObject_Asset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedObject_Asset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Asset != nil {
		{
			size, err := m.Asset.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *SavedObject_Function) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedObject_Function) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Function != nil {
		{
			size, err := m.Function.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *SavedObject_Variable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedObject_Variable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Variable != nil {
		{
			size, err := m.Variable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *SavedObject_BareConcreteFunction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedObject_BareConcreteFunction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BareConcreteFunction != nil {
		{
			size, err := m.BareConcreteFunction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *SavedObject_Constant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedObject_Constant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Constant != nil {
		{
			size, err := m.Constant.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *SavedObject_Resource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedObject_Resource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Resource != nil {
		{
			size, err := m.Resource.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *SavedUserObject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SavedUserObject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedUserObject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintSavedObjectGraph(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Version != nil {
		{
			size, err := m.Version.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Identifier) > 0 {
		i -= len(m.Identifier)
		copy(dAtA[i:], m.Identifier)
		i = encodeVarintSavedObjectGraph(dAtA, i, uint64(len(m.Identifier)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SavedAsset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SavedAsset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedAsset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AssetFileDefIndex != 0 {
		i = encodeVarintSavedObjectGraph(dAtA, i, uint64(m.AssetFileDefIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SavedFunction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SavedFunction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedFunction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FunctionSpec != nil {
		{
			size, err := m.FunctionSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ConcreteFunctions) > 0 {
		for iNdEx := len(m.ConcreteFunctions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ConcreteFunctions[iNdEx])
			copy(dAtA[i:], m.ConcreteFunctions[iNdEx])
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(len(m.ConcreteFunctions[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SavedConcreteFunction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SavedConcreteFunction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedConcreteFunction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OutputSignature != nil {
		{
			size, err := m.OutputSignature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.CanonicalizedInputSignature != nil {
		{
			size, err := m.CanonicalizedInputSignature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BoundInputs) > 0 {
		dAtA15 := make([]byte, len(m.BoundInputs)*10)
		var j14 int
		for _, num1 := range m.BoundInputs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		i -= j14
		copy(dAtA[i:], dAtA15[:j14])
		i = encodeVarintSavedObjectGraph(dAtA, i, uint64(j14))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *SavedBareConcreteFunction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SavedBareConcreteFunction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedBareConcreteFunction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FunctionSpec != nil {
		{
			size, err := m.FunctionSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.AllowedPositionalArguments != 0 {
		i = encodeVarintSavedObjectGraph(dAtA, i, uint64(m.AllowedPositionalArguments))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ArgumentKeywords) > 0 {
		for iNdEx := len(m.ArgumentKeywords) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ArgumentKeywords[iNdEx])
			copy(dAtA[i:], m.ArgumentKeywords[iNdEx])
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(len(m.ArgumentKeywords[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ConcreteFunctionName) > 0 {
		i -= len(m.ConcreteFunctionName)
		copy(dAtA[i:], m.ConcreteFunctionName)
		i = encodeVarintSavedObjectGraph(dAtA, i, uint64(len(m.ConcreteFunctionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SavedConstant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SavedConstant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedConstant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Operation) > 0 {
		i -= len(m.Operation)
		copy(dAtA[i:], m.Operation)
		i = encodeVarintSavedObjectGraph(dAtA, i, uint64(len(m.Operation)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SavedVariable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SavedVariable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedVariable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExperimentalDistributedVariableComponents) > 0 {
		for iNdEx := len(m.ExperimentalDistributedVariableComponents) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExperimentalDistributedVariableComponents[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Device) > 0 {
		i -= len(m.Device)
		copy(dAtA[i:], m.Device)
		i = encodeVarintSavedObjectGraph(dAtA, i, uint64(len(m.Device)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSavedObjectGraph(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x32
	}
	if m.Aggregation != 0 {
		i = encodeVarintSavedObjectGraph(dAtA, i, uint64(m.Aggregation))
		i--
		dAtA[i] = 0x28
	}
	if m.Synchronization != 0 {
		i = encodeVarintSavedObjectGraph(dAtA, i, uint64(m.Synchronization))
		i--
		dAtA[i] = 0x20
	}
	if m.Trainable {
		i--
		if m.Trainable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Shape != nil {
		{
			size, err := m.Shape.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Dtype != 0 {
		i = encodeVarintSavedObjectGraph(dAtA, i, uint64(m.Dtype))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FunctionSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FunctionSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FunctionSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.JitCompile != 0 {
		i = encodeVarintSavedObjectGraph(dAtA, i, uint64(m.JitCompile))
		i--
		dAtA[i] = 0x30
	}
	if m.InputSignature != nil {
		{
			size, err := m.InputSignature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.IsMethod {
		i--
		if m.IsMethod {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Fullargspec != nil {
		{
			size, err := m.Fullargspec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SavedResource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SavedResource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedResource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Device) > 0 {
		i -= len(m.Device)
		copy(dAtA[i:], m.Device)
		i = encodeVarintSavedObjectGraph(dAtA, i, uint64(len(m.Device)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SaveableObject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SaveableObject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SaveableObject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RestoreFunction != 0 {
		i = encodeVarintSavedObjectGraph(dAtA, i, uint64(m.RestoreFunction))
		i--
		dAtA[i] = 0x18
	}
	if m.SaveFunction != 0 {
		i = encodeVarintSavedObjectGraph(dAtA, i, uint64(m.SaveFunction))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func encodeVarintSavedObjectGraph(dAtA []byte, offset int, v uint64) int {
	offset -= sovSavedObjectGraph(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SavedObjectGraph) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovSavedObjectGraph(uint64(l))
		}
	}
	if len(m.ConcreteFunctions) > 0 {
		for k, v := range m.ConcreteFunctions {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSavedObjectGraph(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSavedObjectGraph(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSavedObjectGraph(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SavedObject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovSavedObjectGraph(uint64(l))
		}
	}
	if len(m.SlotVariables) > 0 {
		for _, e := range m.SlotVariables {
			l = e.Size()
			n += 1 + l + sovSavedObjectGraph(uint64(l))
		}
	}
	if m.Kind != nil {
		n += m.Kind.Size()
	}
	if len(m.SaveableObjects) > 0 {
		for k, v := range m.SaveableObjects {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSavedObjectGraph(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSavedObjectGraph(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSavedObjectGraph(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SavedObject_UserObject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserObject != nil {
		l = m.UserObject.Size()
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	return n
}
func (m *SavedObject_Asset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Asset != nil {
		l = m.Asset.Size()
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	return n
}
func (m *SavedObject_Function) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Function != nil {
		l = m.Function.Size()
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	return n
}
func (m *SavedObject_Variable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Variable != nil {
		l = m.Variable.Size()
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	return n
}
func (m *SavedObject_BareConcreteFunction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BareConcreteFunction != nil {
		l = m.BareConcreteFunction.Size()
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	return n
}
func (m *SavedObject_Constant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constant != nil {
		l = m.Constant.Size()
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	return n
}
func (m *SavedObject_Resource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Resource != nil {
		l = m.Resource.Size()
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	return n
}
func (m *SavedUserObject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Identifier)
	if l > 0 {
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	return n
}

func (m *SavedAsset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AssetFileDefIndex != 0 {
		n += 1 + sovSavedObjectGraph(uint64(m.AssetFileDefIndex))
	}
	return n
}

func (m *SavedFunction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ConcreteFunctions) > 0 {
		for _, s := range m.ConcreteFunctions {
			l = len(s)
			n += 1 + l + sovSavedObjectGraph(uint64(l))
		}
	}
	if m.FunctionSpec != nil {
		l = m.FunctionSpec.Size()
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	return n
}

func (m *SavedConcreteFunction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BoundInputs) > 0 {
		l = 0
		for _, e := range m.BoundInputs {
			l += sovSavedObjectGraph(uint64(e))
		}
		n += 1 + sovSavedObjectGraph(uint64(l)) + l
	}
	if m.CanonicalizedInputSignature != nil {
		l = m.CanonicalizedInputSignature.Size()
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	if m.OutputSignature != nil {
		l = m.OutputSignature.Size()
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	return n
}

func (m *SavedBareConcreteFunction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConcreteFunctionName)
	if l > 0 {
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	if len(m.ArgumentKeywords) > 0 {
		for _, s := range m.ArgumentKeywords {
			l = len(s)
			n += 1 + l + sovSavedObjectGraph(uint64(l))
		}
	}
	if m.AllowedPositionalArguments != 0 {
		n += 1 + sovSavedObjectGraph(uint64(m.AllowedPositionalArguments))
	}
	if m.FunctionSpec != nil {
		l = m.FunctionSpec.Size()
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	return n
}

func (m *SavedConstant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Operation)
	if l > 0 {
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	return n
}

func (m *SavedVariable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dtype != 0 {
		n += 1 + sovSavedObjectGraph(uint64(m.Dtype))
	}
	if m.Shape != nil {
		l = m.Shape.Size()
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	if m.Trainable {
		n += 2
	}
	if m.Synchronization != 0 {
		n += 1 + sovSavedObjectGraph(uint64(m.Synchronization))
	}
	if m.Aggregation != 0 {
		n += 1 + sovSavedObjectGraph(uint64(m.Aggregation))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	l = len(m.Device)
	if l > 0 {
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	if len(m.ExperimentalDistributedVariableComponents) > 0 {
		for _, e := range m.ExperimentalDistributedVariableComponents {
			l = e.Size()
			n += 1 + l + sovSavedObjectGraph(uint64(l))
		}
	}
	return n
}

func (m *FunctionSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Fullargspec != nil {
		l = m.Fullargspec.Size()
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	if m.IsMethod {
		n += 2
	}
	if m.InputSignature != nil {
		l = m.InputSignature.Size()
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	if m.JitCompile != 0 {
		n += 1 + sovSavedObjectGraph(uint64(m.JitCompile))
	}
	return n
}

func (m *SavedResource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Device)
	if l > 0 {
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	return n
}

func (m *SaveableObject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SaveFunction != 0 {
		n += 1 + sovSavedObjectGraph(uint64(m.SaveFunction))
	}
	if m.RestoreFunction != 0 {
		n += 1 + sovSavedObjectGraph(uint64(m.RestoreFunction))
	}
	return n
}

func sovSavedObjectGraph(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSavedObjectGraph(x uint64) (n int) {
	return sovSavedObjectGraph(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SavedObjectGraph) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSavedObjectGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SavedObjectGraph: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SavedObjectGraph: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &SavedObject{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConcreteFunctions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConcreteFunctions == nil {
				m.ConcreteFunctions = make(map[string]*SavedConcreteFunction)
			}
			var mapkey string
			var mapvalue *SavedConcreteFunction
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSavedObjectGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSavedObjectGraph
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSavedObjectGraph
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSavedObjectGraph
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSavedObjectGraph
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSavedObjectGraph
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSavedObjectGraph
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SavedConcreteFunction{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSavedObjectGraph(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSavedObjectGraph
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ConcreteFunctions[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSavedObjectGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SavedObject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSavedObjectGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SavedObject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SavedObject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &TrackableObjectGraph_TrackableObject_ObjectReference{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlotVariables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlotVariables = append(m.SlotVariables, &TrackableObjectGraph_TrackableObject_SlotVariableReference{})
			if err := m.SlotVariables[len(m.SlotVariables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserObject", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SavedUserObject{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &SavedObject_UserObject{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SavedAsset{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &SavedObject_Asset{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Function", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SavedFunction{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &SavedObject_Function{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SavedVariable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &SavedObject_Variable{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BareConcreteFunction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SavedBareConcreteFunction{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &SavedObject_BareConcreteFunction{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constant", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SavedConstant{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &SavedObject_Constant{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SavedResource{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &SavedObject_Resource{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaveableObjects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SaveableObjects == nil {
				m.SaveableObjects = make(map[string]*SaveableObject)
			}
			var mapkey string
			var mapvalue *SaveableObject
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSavedObjectGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSavedObjectGraph
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSavedObjectGraph
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSavedObjectGraph
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSavedObjectGraph
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSavedObjectGraph
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSavedObjectGraph
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SaveableObject{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSavedObjectGraph(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSavedObjectGraph
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SaveableObjects[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSavedObjectGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SavedUserObject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSavedObjectGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SavedUserObject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SavedUserObject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identifier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &framework.VersionDef{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSavedObjectGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SavedAsset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSavedObjectGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SavedAsset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SavedAsset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetFileDefIndex", wireType)
			}
			m.AssetFileDefIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssetFileDefIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSavedObjectGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SavedFunction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSavedObjectGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SavedFunction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SavedFunction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConcreteFunctions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConcreteFunctions = append(m.ConcreteFunctions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FunctionSpec == nil {
				m.FunctionSpec = &FunctionSpec{}
			}
			if err := m.FunctionSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSavedObjectGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SavedConcreteFunction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSavedObjectGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SavedConcreteFunction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SavedConcreteFunction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSavedObjectGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BoundInputs = append(m.BoundInputs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSavedObjectGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSavedObjectGraph
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSavedObjectGraph
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BoundInputs) == 0 {
					m.BoundInputs = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSavedObjectGraph
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BoundInputs = append(m.BoundInputs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BoundInputs", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanonicalizedInputSignature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CanonicalizedInputSignature == nil {
				m.CanonicalizedInputSignature = &StructuredValue{}
			}
			if err := m.CanonicalizedInputSignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputSignature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputSignature == nil {
				m.OutputSignature = &StructuredValue{}
			}
			if err := m.OutputSignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSavedObjectGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SavedBareConcreteFunction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSavedObjectGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SavedBareConcreteFunction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SavedBareConcreteFunction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConcreteFunctionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConcreteFunctionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgumentKeywords", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArgumentKeywords = append(m.ArgumentKeywords, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedPositionalArguments", wireType)
			}
			m.AllowedPositionalArguments = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllowedPositionalArguments |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FunctionSpec == nil {
				m.FunctionSpec = &FunctionSpec{}
			}
			if err := m.FunctionSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSavedObjectGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SavedConstant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSavedObjectGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SavedConstant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SavedConstant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSavedObjectGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SavedVariable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSavedObjectGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SavedVariable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SavedVariable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dtype", wireType)
			}
			m.Dtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dtype |= framework.DataType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shape", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shape == nil {
				m.Shape = &framework.TensorShapeProto{}
			}
			if err := m.Shape.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trainable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Trainable = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Synchronization", wireType)
			}
			m.Synchronization = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Synchronization |= framework.VariableSynchronization(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggregation", wireType)
			}
			m.Aggregation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aggregation |= framework.VariableAggregation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Device = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExperimentalDistributedVariableComponents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExperimentalDistributedVariableComponents = append(m.ExperimentalDistributedVariableComponents, &SavedVariable{})
			if err := m.ExperimentalDistributedVariableComponents[len(m.ExperimentalDistributedVariableComponents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSavedObjectGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FunctionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSavedObjectGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FunctionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FunctionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fullargspec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fullargspec == nil {
				m.Fullargspec = &StructuredValue{}
			}
			if err := m.Fullargspec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMethod", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMethod = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputSignature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputSignature == nil {
				m.InputSignature = &StructuredValue{}
			}
			if err := m.InputSignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JitCompile", wireType)
			}
			m.JitCompile = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JitCompile |= FunctionSpec_JitCompile(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSavedObjectGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SavedResource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSavedObjectGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SavedResource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SavedResource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Device = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSavedObjectGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SaveableObject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSavedObjectGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SaveableObject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SaveableObject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaveFunction", wireType)
			}
			m.SaveFunction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SaveFunction |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestoreFunction", wireType)
			}
			m.RestoreFunction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RestoreFunction |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSavedObjectGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSavedObjectGraph(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSavedObjectGraph
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSavedObjectGraph
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSavedObjectGraph
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSavedObjectGraph
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSavedObjectGraph        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSavedObjectGraph          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSavedObjectGraph = fmt.Errorf("proto: unexpected end of group")
)
