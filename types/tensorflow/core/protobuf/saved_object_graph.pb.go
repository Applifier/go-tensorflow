// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tensorflow/core/protobuf/saved_object_graph.proto

package core

import (
	fmt "fmt"
	framework "github.com/Applifier/go-tensorflow/types/tensorflow/core/framework"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type SavedObjectGraph struct {
	// Flattened list of objects in the object graph.
	//
	// The position of the object in this list indicates its id.
	// Nodes[0] is considered the root node.
	Nodes []*SavedObject `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty"`
	// Information about captures and output structures in concrete functions.
	// Referenced from SavedBareConcreteFunction and SavedFunction.
	ConcreteFunctions map[string]*SavedConcreteFunction `protobuf:"bytes,2,rep,name=concrete_functions,json=concreteFunctions,proto3" json:"concrete_functions,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SavedObjectGraph) Reset()         { *m = SavedObjectGraph{} }
func (m *SavedObjectGraph) String() string { return proto.CompactTextString(m) }
func (*SavedObjectGraph) ProtoMessage()    {}
func (*SavedObjectGraph) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f63c49021beb5aa, []int{0}
}
func (m *SavedObjectGraph) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SavedObjectGraph) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SavedObjectGraph.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SavedObjectGraph) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SavedObjectGraph.Merge(m, src)
}
func (m *SavedObjectGraph) XXX_Size() int {
	return m.Size()
}
func (m *SavedObjectGraph) XXX_DiscardUnknown() {
	xxx_messageInfo_SavedObjectGraph.DiscardUnknown(m)
}

var xxx_messageInfo_SavedObjectGraph proto.InternalMessageInfo

func (m *SavedObjectGraph) GetNodes() []*SavedObject {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *SavedObjectGraph) GetConcreteFunctions() map[string]*SavedConcreteFunction {
	if m != nil {
		return m.ConcreteFunctions
	}
	return nil
}

type SavedObject struct {
	// Objects which this object depends on: named edges in the dependency
	// graph.
	//
	// Note: currently only valid if kind == "user_object".
	Children []*TrackableObjectGraph_TrackableObject_ObjectReference `protobuf:"bytes,1,rep,name=children,proto3" json:"children,omitempty"`
	// Slot variables owned by this object. This describes the three-way
	// (optimizer, variable, slot variable) relationship; none of the three
	// depend on the others directly.
	//
	// Note: currently only valid if kind == "user_object".
	SlotVariables []*TrackableObjectGraph_TrackableObject_SlotVariableReference `protobuf:"bytes,3,rep,name=slot_variables,json=slotVariables,proto3" json:"slot_variables,omitempty"`
	// Types that are valid to be assigned to Kind:
	//	*SavedObject_UserObject
	//	*SavedObject_Asset
	//	*SavedObject_Function
	//	*SavedObject_Variable
	//	*SavedObject_BareConcreteFunction
	//	*SavedObject_Constant
	//	*SavedObject_Resource
	Kind isSavedObject_Kind `protobuf_oneof:"kind"`
}

func (m *SavedObject) Reset()         { *m = SavedObject{} }
func (m *SavedObject) String() string { return proto.CompactTextString(m) }
func (*SavedObject) ProtoMessage()    {}
func (*SavedObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f63c49021beb5aa, []int{1}
}
func (m *SavedObject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SavedObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SavedObject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SavedObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SavedObject.Merge(m, src)
}
func (m *SavedObject) XXX_Size() int {
	return m.Size()
}
func (m *SavedObject) XXX_DiscardUnknown() {
	xxx_messageInfo_SavedObject.DiscardUnknown(m)
}

var xxx_messageInfo_SavedObject proto.InternalMessageInfo

type isSavedObject_Kind interface {
	isSavedObject_Kind()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SavedObject_UserObject struct {
	UserObject *SavedUserObject `protobuf:"bytes,4,opt,name=user_object,json=userObject,proto3,oneof" json:"user_object,omitempty"`
}
type SavedObject_Asset struct {
	Asset *SavedAsset `protobuf:"bytes,5,opt,name=asset,proto3,oneof" json:"asset,omitempty"`
}
type SavedObject_Function struct {
	Function *SavedFunction `protobuf:"bytes,6,opt,name=function,proto3,oneof" json:"function,omitempty"`
}
type SavedObject_Variable struct {
	Variable *SavedVariable `protobuf:"bytes,7,opt,name=variable,proto3,oneof" json:"variable,omitempty"`
}
type SavedObject_BareConcreteFunction struct {
	BareConcreteFunction *SavedBareConcreteFunction `protobuf:"bytes,8,opt,name=bare_concrete_function,json=bareConcreteFunction,proto3,oneof" json:"bare_concrete_function,omitempty"`
}
type SavedObject_Constant struct {
	Constant *SavedConstant `protobuf:"bytes,9,opt,name=constant,proto3,oneof" json:"constant,omitempty"`
}
type SavedObject_Resource struct {
	Resource *SavedResource `protobuf:"bytes,10,opt,name=resource,proto3,oneof" json:"resource,omitempty"`
}

func (*SavedObject_UserObject) isSavedObject_Kind()           {}
func (*SavedObject_Asset) isSavedObject_Kind()                {}
func (*SavedObject_Function) isSavedObject_Kind()             {}
func (*SavedObject_Variable) isSavedObject_Kind()             {}
func (*SavedObject_BareConcreteFunction) isSavedObject_Kind() {}
func (*SavedObject_Constant) isSavedObject_Kind()             {}
func (*SavedObject_Resource) isSavedObject_Kind()             {}

func (m *SavedObject) GetKind() isSavedObject_Kind {
	if m != nil {
		return m.Kind
	}
	return nil
}

func (m *SavedObject) GetChildren() []*TrackableObjectGraph_TrackableObject_ObjectReference {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *SavedObject) GetSlotVariables() []*TrackableObjectGraph_TrackableObject_SlotVariableReference {
	if m != nil {
		return m.SlotVariables
	}
	return nil
}

func (m *SavedObject) GetUserObject() *SavedUserObject {
	if x, ok := m.GetKind().(*SavedObject_UserObject); ok {
		return x.UserObject
	}
	return nil
}

func (m *SavedObject) GetAsset() *SavedAsset {
	if x, ok := m.GetKind().(*SavedObject_Asset); ok {
		return x.Asset
	}
	return nil
}

func (m *SavedObject) GetFunction() *SavedFunction {
	if x, ok := m.GetKind().(*SavedObject_Function); ok {
		return x.Function
	}
	return nil
}

func (m *SavedObject) GetVariable() *SavedVariable {
	if x, ok := m.GetKind().(*SavedObject_Variable); ok {
		return x.Variable
	}
	return nil
}

func (m *SavedObject) GetBareConcreteFunction() *SavedBareConcreteFunction {
	if x, ok := m.GetKind().(*SavedObject_BareConcreteFunction); ok {
		return x.BareConcreteFunction
	}
	return nil
}

func (m *SavedObject) GetConstant() *SavedConstant {
	if x, ok := m.GetKind().(*SavedObject_Constant); ok {
		return x.Constant
	}
	return nil
}

func (m *SavedObject) GetResource() *SavedResource {
	if x, ok := m.GetKind().(*SavedObject_Resource); ok {
		return x.Resource
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SavedObject) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SavedObject_UserObject)(nil),
		(*SavedObject_Asset)(nil),
		(*SavedObject_Function)(nil),
		(*SavedObject_Variable)(nil),
		(*SavedObject_BareConcreteFunction)(nil),
		(*SavedObject_Constant)(nil),
		(*SavedObject_Resource)(nil),
	}
}

// A SavedUserObject is an object (in the object-oriented language of the
// TensorFlow program) of some user- or framework-defined class other than
// those handled specifically by the other kinds of SavedObjects.
//
// This object cannot be evaluated as a tensor, and therefore cannot be bound
// to an input of a function.
type SavedUserObject struct {
	// Corresponds to a registration of the type to use in the loading program.
	Identifier string `protobuf:"bytes,1,opt,name=identifier,proto3" json:"identifier,omitempty"`
	// Version information from the producer of this SavedUserObject.
	Version *framework.VersionDef `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// Initialization-related metadata.
	Metadata string `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *SavedUserObject) Reset()         { *m = SavedUserObject{} }
func (m *SavedUserObject) String() string { return proto.CompactTextString(m) }
func (*SavedUserObject) ProtoMessage()    {}
func (*SavedUserObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f63c49021beb5aa, []int{2}
}
func (m *SavedUserObject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SavedUserObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SavedUserObject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SavedUserObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SavedUserObject.Merge(m, src)
}
func (m *SavedUserObject) XXX_Size() int {
	return m.Size()
}
func (m *SavedUserObject) XXX_DiscardUnknown() {
	xxx_messageInfo_SavedUserObject.DiscardUnknown(m)
}

var xxx_messageInfo_SavedUserObject proto.InternalMessageInfo

func (m *SavedUserObject) GetIdentifier() string {
	if m != nil {
		return m.Identifier
	}
	return ""
}

func (m *SavedUserObject) GetVersion() *framework.VersionDef {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *SavedUserObject) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

// A SavedAsset points to an asset in the MetaGraph.
//
// When bound to a function this object evaluates to a tensor with the absolute
// filename. Users should not depend on a particular part of the filename to
// remain stable (e.g. basename could be changed).
type SavedAsset struct {
	// Index into `MetaGraphDef.asset_file_def[]` that describes the Asset.
	//
	// Only the field `AssetFileDef.filename` is used. Other fields, such as
	// `AssetFileDef.tensor_info`, MUST be ignored.
	AssetFileDefIndex int32 `protobuf:"varint,1,opt,name=asset_file_def_index,json=assetFileDefIndex,proto3" json:"asset_file_def_index,omitempty"`
}

func (m *SavedAsset) Reset()         { *m = SavedAsset{} }
func (m *SavedAsset) String() string { return proto.CompactTextString(m) }
func (*SavedAsset) ProtoMessage()    {}
func (*SavedAsset) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f63c49021beb5aa, []int{3}
}
func (m *SavedAsset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SavedAsset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SavedAsset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SavedAsset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SavedAsset.Merge(m, src)
}
func (m *SavedAsset) XXX_Size() int {
	return m.Size()
}
func (m *SavedAsset) XXX_DiscardUnknown() {
	xxx_messageInfo_SavedAsset.DiscardUnknown(m)
}

var xxx_messageInfo_SavedAsset proto.InternalMessageInfo

func (m *SavedAsset) GetAssetFileDefIndex() int32 {
	if m != nil {
		return m.AssetFileDefIndex
	}
	return 0
}

// A function with multiple signatures, possibly with non-Tensor arguments.
type SavedFunction struct {
	ConcreteFunctions []string      `protobuf:"bytes,1,rep,name=concrete_functions,json=concreteFunctions,proto3" json:"concrete_functions,omitempty"`
	FunctionSpec      *FunctionSpec `protobuf:"bytes,2,opt,name=function_spec,json=functionSpec,proto3" json:"function_spec,omitempty"`
}

func (m *SavedFunction) Reset()         { *m = SavedFunction{} }
func (m *SavedFunction) String() string { return proto.CompactTextString(m) }
func (*SavedFunction) ProtoMessage()    {}
func (*SavedFunction) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f63c49021beb5aa, []int{4}
}
func (m *SavedFunction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SavedFunction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SavedFunction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SavedFunction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SavedFunction.Merge(m, src)
}
func (m *SavedFunction) XXX_Size() int {
	return m.Size()
}
func (m *SavedFunction) XXX_DiscardUnknown() {
	xxx_messageInfo_SavedFunction.DiscardUnknown(m)
}

var xxx_messageInfo_SavedFunction proto.InternalMessageInfo

func (m *SavedFunction) GetConcreteFunctions() []string {
	if m != nil {
		return m.ConcreteFunctions
	}
	return nil
}

func (m *SavedFunction) GetFunctionSpec() *FunctionSpec {
	if m != nil {
		return m.FunctionSpec
	}
	return nil
}

// Stores low-level information about a concrete function. Referenced in either
// a SavedFunction or a SavedBareConcreteFunction.
type SavedConcreteFunction struct {
	// Bound inputs to the function. The SavedObjects identified by the node ids
	// given here are appended as extra inputs to the caller-supplied inputs.
	// The only types of SavedObjects valid here are SavedVariable, SavedResource
	// and SavedAsset.
	BoundInputs []int32 `protobuf:"varint,2,rep,packed,name=bound_inputs,json=boundInputs,proto3" json:"bound_inputs,omitempty"`
	// Input in canonicalized form that was received to create this concrete
	// function.
	CanonicalizedInputSignature *StructuredValue `protobuf:"bytes,3,opt,name=canonicalized_input_signature,json=canonicalizedInputSignature,proto3" json:"canonicalized_input_signature,omitempty"`
	// Output that was the return value of this function after replacing all
	// Tensors with TensorSpecs. This can be an arbitrary nested function and will
	// be used to reconstruct the full structure from pure tensors.
	OutputSignature *StructuredValue `protobuf:"bytes,4,opt,name=output_signature,json=outputSignature,proto3" json:"output_signature,omitempty"`
}

func (m *SavedConcreteFunction) Reset()         { *m = SavedConcreteFunction{} }
func (m *SavedConcreteFunction) String() string { return proto.CompactTextString(m) }
func (*SavedConcreteFunction) ProtoMessage()    {}
func (*SavedConcreteFunction) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f63c49021beb5aa, []int{5}
}
func (m *SavedConcreteFunction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SavedConcreteFunction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SavedConcreteFunction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SavedConcreteFunction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SavedConcreteFunction.Merge(m, src)
}
func (m *SavedConcreteFunction) XXX_Size() int {
	return m.Size()
}
func (m *SavedConcreteFunction) XXX_DiscardUnknown() {
	xxx_messageInfo_SavedConcreteFunction.DiscardUnknown(m)
}

var xxx_messageInfo_SavedConcreteFunction proto.InternalMessageInfo

func (m *SavedConcreteFunction) GetBoundInputs() []int32 {
	if m != nil {
		return m.BoundInputs
	}
	return nil
}

func (m *SavedConcreteFunction) GetCanonicalizedInputSignature() *StructuredValue {
	if m != nil {
		return m.CanonicalizedInputSignature
	}
	return nil
}

func (m *SavedConcreteFunction) GetOutputSignature() *StructuredValue {
	if m != nil {
		return m.OutputSignature
	}
	return nil
}

type SavedBareConcreteFunction struct {
	// Identifies a SavedConcreteFunction.
	ConcreteFunctionName string `protobuf:"bytes,1,opt,name=concrete_function_name,json=concreteFunctionName,proto3" json:"concrete_function_name,omitempty"`
	// A sequence of unique strings, one per Tensor argument.
	ArgumentKeywords []string `protobuf:"bytes,2,rep,name=argument_keywords,json=argumentKeywords,proto3" json:"argument_keywords,omitempty"`
	// The prefix of `argument_keywords` which may be identified by position.
	AllowedPositionalArguments int64 `protobuf:"varint,3,opt,name=allowed_positional_arguments,json=allowedPositionalArguments,proto3" json:"allowed_positional_arguments,omitempty"`
}

func (m *SavedBareConcreteFunction) Reset()         { *m = SavedBareConcreteFunction{} }
func (m *SavedBareConcreteFunction) String() string { return proto.CompactTextString(m) }
func (*SavedBareConcreteFunction) ProtoMessage()    {}
func (*SavedBareConcreteFunction) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f63c49021beb5aa, []int{6}
}
func (m *SavedBareConcreteFunction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SavedBareConcreteFunction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SavedBareConcreteFunction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SavedBareConcreteFunction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SavedBareConcreteFunction.Merge(m, src)
}
func (m *SavedBareConcreteFunction) XXX_Size() int {
	return m.Size()
}
func (m *SavedBareConcreteFunction) XXX_DiscardUnknown() {
	xxx_messageInfo_SavedBareConcreteFunction.DiscardUnknown(m)
}

var xxx_messageInfo_SavedBareConcreteFunction proto.InternalMessageInfo

func (m *SavedBareConcreteFunction) GetConcreteFunctionName() string {
	if m != nil {
		return m.ConcreteFunctionName
	}
	return ""
}

func (m *SavedBareConcreteFunction) GetArgumentKeywords() []string {
	if m != nil {
		return m.ArgumentKeywords
	}
	return nil
}

func (m *SavedBareConcreteFunction) GetAllowedPositionalArguments() int64 {
	if m != nil {
		return m.AllowedPositionalArguments
	}
	return 0
}

type SavedConstant struct {
	// An Operation name for a ConstantOp in this SavedObjectGraph's MetaGraph.
	Operation string `protobuf:"bytes,1,opt,name=operation,proto3" json:"operation,omitempty"`
}

func (m *SavedConstant) Reset()         { *m = SavedConstant{} }
func (m *SavedConstant) String() string { return proto.CompactTextString(m) }
func (*SavedConstant) ProtoMessage()    {}
func (*SavedConstant) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f63c49021beb5aa, []int{7}
}
func (m *SavedConstant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SavedConstant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SavedConstant.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SavedConstant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SavedConstant.Merge(m, src)
}
func (m *SavedConstant) XXX_Size() int {
	return m.Size()
}
func (m *SavedConstant) XXX_DiscardUnknown() {
	xxx_messageInfo_SavedConstant.DiscardUnknown(m)
}

var xxx_messageInfo_SavedConstant proto.InternalMessageInfo

func (m *SavedConstant) GetOperation() string {
	if m != nil {
		return m.Operation
	}
	return ""
}

// Represents a Variable that is initialized by loading the contents from the
// checkpoint.
type SavedVariable struct {
	Dtype           framework.DataType                `protobuf:"varint,1,opt,name=dtype,proto3,enum=tensorflow.DataType" json:"dtype,omitempty"`
	Shape           *framework.TensorShapeProto       `protobuf:"bytes,2,opt,name=shape,proto3" json:"shape,omitempty"`
	Trainable       bool                              `protobuf:"varint,3,opt,name=trainable,proto3" json:"trainable,omitempty"`
	Synchronization framework.VariableSynchronization `protobuf:"varint,4,opt,name=synchronization,proto3,enum=tensorflow.VariableSynchronization" json:"synchronization,omitempty"`
	Aggregation     framework.VariableAggregation     `protobuf:"varint,5,opt,name=aggregation,proto3,enum=tensorflow.VariableAggregation" json:"aggregation,omitempty"`
	Name            string                            `protobuf:"bytes,6,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *SavedVariable) Reset()         { *m = SavedVariable{} }
func (m *SavedVariable) String() string { return proto.CompactTextString(m) }
func (*SavedVariable) ProtoMessage()    {}
func (*SavedVariable) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f63c49021beb5aa, []int{8}
}
func (m *SavedVariable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SavedVariable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SavedVariable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SavedVariable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SavedVariable.Merge(m, src)
}
func (m *SavedVariable) XXX_Size() int {
	return m.Size()
}
func (m *SavedVariable) XXX_DiscardUnknown() {
	xxx_messageInfo_SavedVariable.DiscardUnknown(m)
}

var xxx_messageInfo_SavedVariable proto.InternalMessageInfo

func (m *SavedVariable) GetDtype() framework.DataType {
	if m != nil {
		return m.Dtype
	}
	return framework.DataType_DT_INVALID
}

func (m *SavedVariable) GetShape() *framework.TensorShapeProto {
	if m != nil {
		return m.Shape
	}
	return nil
}

func (m *SavedVariable) GetTrainable() bool {
	if m != nil {
		return m.Trainable
	}
	return false
}

func (m *SavedVariable) GetSynchronization() framework.VariableSynchronization {
	if m != nil {
		return m.Synchronization
	}
	return framework.VariableSynchronization_VARIABLE_SYNCHRONIZATION_AUTO
}

func (m *SavedVariable) GetAggregation() framework.VariableAggregation {
	if m != nil {
		return m.Aggregation
	}
	return framework.VariableAggregation_VARIABLE_AGGREGATION_NONE
}

func (m *SavedVariable) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Represents `FunctionSpec` used in `Function`. This represents a
// function that has been wrapped as a TensorFlow `Function`.
type FunctionSpec struct {
	// Full arg spec from inspect.getfullargspec().
	Fullargspec *StructuredValue `protobuf:"bytes,1,opt,name=fullargspec,proto3" json:"fullargspec,omitempty"`
	// Whether this represents a class method.
	IsMethod bool `protobuf:"varint,2,opt,name=is_method,json=isMethod,proto3" json:"is_method,omitempty"`
	// The input signature, if specified.
	InputSignature *StructuredValue `protobuf:"bytes,5,opt,name=input_signature,json=inputSignature,proto3" json:"input_signature,omitempty"`
}

func (m *FunctionSpec) Reset()         { *m = FunctionSpec{} }
func (m *FunctionSpec) String() string { return proto.CompactTextString(m) }
func (*FunctionSpec) ProtoMessage()    {}
func (*FunctionSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f63c49021beb5aa, []int{9}
}
func (m *FunctionSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FunctionSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FunctionSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FunctionSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FunctionSpec.Merge(m, src)
}
func (m *FunctionSpec) XXX_Size() int {
	return m.Size()
}
func (m *FunctionSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_FunctionSpec.DiscardUnknown(m)
}

var xxx_messageInfo_FunctionSpec proto.InternalMessageInfo

func (m *FunctionSpec) GetFullargspec() *StructuredValue {
	if m != nil {
		return m.Fullargspec
	}
	return nil
}

func (m *FunctionSpec) GetIsMethod() bool {
	if m != nil {
		return m.IsMethod
	}
	return false
}

func (m *FunctionSpec) GetInputSignature() *StructuredValue {
	if m != nil {
		return m.InputSignature
	}
	return nil
}

// A SavedResource represents a TF object that holds state during its lifetime.
// An object of this type can have a reference to a:
// create_resource() and an initialize() function.
type SavedResource struct {
	// A device specification indicating a required placement for the resource
	// creation function, e.g. "CPU". An empty string allows the user to select a
	// device.
	Device string `protobuf:"bytes,1,opt,name=device,proto3" json:"device,omitempty"`
}

func (m *SavedResource) Reset()         { *m = SavedResource{} }
func (m *SavedResource) String() string { return proto.CompactTextString(m) }
func (*SavedResource) ProtoMessage()    {}
func (*SavedResource) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f63c49021beb5aa, []int{10}
}
func (m *SavedResource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SavedResource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SavedResource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SavedResource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SavedResource.Merge(m, src)
}
func (m *SavedResource) XXX_Size() int {
	return m.Size()
}
func (m *SavedResource) XXX_DiscardUnknown() {
	xxx_messageInfo_SavedResource.DiscardUnknown(m)
}

var xxx_messageInfo_SavedResource proto.InternalMessageInfo

func (m *SavedResource) GetDevice() string {
	if m != nil {
		return m.Device
	}
	return ""
}

func init() {
	proto.RegisterType((*SavedObjectGraph)(nil), "tensorflow.SavedObjectGraph")
	proto.RegisterMapType((map[string]*SavedConcreteFunction)(nil), "tensorflow.SavedObjectGraph.ConcreteFunctionsEntry")
	proto.RegisterType((*SavedObject)(nil), "tensorflow.SavedObject")
	proto.RegisterType((*SavedUserObject)(nil), "tensorflow.SavedUserObject")
	proto.RegisterType((*SavedAsset)(nil), "tensorflow.SavedAsset")
	proto.RegisterType((*SavedFunction)(nil), "tensorflow.SavedFunction")
	proto.RegisterType((*SavedConcreteFunction)(nil), "tensorflow.SavedConcreteFunction")
	proto.RegisterType((*SavedBareConcreteFunction)(nil), "tensorflow.SavedBareConcreteFunction")
	proto.RegisterType((*SavedConstant)(nil), "tensorflow.SavedConstant")
	proto.RegisterType((*SavedVariable)(nil), "tensorflow.SavedVariable")
	proto.RegisterType((*FunctionSpec)(nil), "tensorflow.FunctionSpec")
	proto.RegisterType((*SavedResource)(nil), "tensorflow.SavedResource")
}

func init() {
	proto.RegisterFile("tensorflow/core/protobuf/saved_object_graph.proto", fileDescriptor_4f63c49021beb5aa)
}

var fileDescriptor_4f63c49021beb5aa = []byte{
	// 1123 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0xdf, 0x6e, 0x1b, 0xc5,
	0x17, 0xf6, 0xda, 0xde, 0xd4, 0x3e, 0x6e, 0x1b, 0x77, 0x94, 0x5f, 0x7e, 0xdb, 0xb4, 0x98, 0xd6,
	0xa8, 0x22, 0x02, 0x62, 0x43, 0x0a, 0x6a, 0x85, 0x54, 0xd4, 0xb4, 0x21, 0xa4, 0x41, 0x85, 0x6a,
	0xdc, 0xf6, 0x02, 0x81, 0x56, 0xe3, 0xdd, 0xb3, 0xf6, 0x92, 0xf5, 0xce, 0x6a, 0x66, 0x36, 0xc1,
	0x95, 0x10, 0x6f, 0x80, 0x78, 0x0b, 0x1e, 0x80, 0x5b, 0x2e, 0xb8, 0xe4, 0xb2, 0x97, 0x5c, 0xa2,
	0xe4, 0x25, 0xb8, 0x44, 0x3b, 0xbb, 0x6b, 0xaf, 0xff, 0x11, 0xb8, 0xdb, 0x39, 0xe7, 0xfb, 0xbe,
	0x39, 0x73, 0xe6, 0x9c, 0xb3, 0x03, 0x1f, 0x28, 0x0c, 0x25, 0x17, 0x5e, 0xc0, 0x4f, 0xbb, 0x0e,
	0x17, 0xd8, 0x8d, 0x04, 0x57, 0xbc, 0x1f, 0x7b, 0x5d, 0xc9, 0x4e, 0xd0, 0xb5, 0x79, 0xff, 0x5b,
	0x74, 0x94, 0x3d, 0x10, 0x2c, 0x1a, 0x76, 0xb4, 0x8f, 0xc0, 0x94, 0xb2, 0xf5, 0xde, 0x3c, 0xdd,
	0x13, 0x6c, 0x84, 0xa7, 0x5c, 0x1c, 0x77, 0x53, 0x8f, 0x2d, 0x87, 0x2c, 0xc2, 0x94, 0xb9, 0x75,
	0xe7, 0x1f, 0xd0, 0xe3, 0x08, 0x65, 0x06, 0xdb, 0x5e, 0x0d, 0x3b, 0x61, 0xc2, 0x67, 0xfd, 0x00,
	0xff, 0x05, 0x12, 0x85, 0xf4, 0x79, 0x28, 0x57, 0x6d, 0x3d, 0x3d, 0xa7, 0x12, 0xb1, 0xa3, 0x32,
	0xd8, 0x47, 0x2b, 0x61, 0x4a, 0x30, 0xe7, 0x38, 0xd9, 0x7a, 0x49, 0x4a, 0xda, 0x3f, 0x96, 0xa1,
	0xd9, 0x4b, 0xf2, 0xf5, 0xa5, 0xf6, 0x7d, 0x96, 0xb8, 0xc8, 0x0e, 0x98, 0x21, 0x77, 0x51, 0x5a,
	0xc6, 0xad, 0xca, 0x76, 0x63, 0xf7, 0xff, 0x9d, 0xa9, 0x76, 0xa7, 0x00, 0xa6, 0x29, 0x8a, 0xf4,
	0x81, 0x38, 0x3c, 0x74, 0x04, 0x2a, 0xb4, 0xbd, 0x38, 0x74, 0x54, 0x12, 0xbd, 0x55, 0xd6, 0xdc,
	0xbb, 0x2b, 0xb8, 0x7a, 0xa3, 0xce, 0xe3, 0x8c, 0x76, 0x90, 0xb3, 0x3e, 0x0d, 0x95, 0x18, 0xd3,
	0x6b, 0xce, 0xbc, 0x7d, 0x6b, 0x00, 0x9b, 0xcb, 0xc1, 0xa4, 0x09, 0x95, 0x63, 0x1c, 0x5b, 0xc6,
	0x2d, 0x63, 0xbb, 0x4e, 0x93, 0x4f, 0x72, 0x0f, 0xcc, 0x13, 0x16, 0xc4, 0x68, 0x95, 0x6f, 0x19,
	0xdb, 0x8d, 0xdd, 0xdb, 0x0b, 0x21, 0xcc, 0x2b, 0xd1, 0x14, 0xff, 0x71, 0xf9, 0xbe, 0xd1, 0xfe,
	0xd9, 0x84, 0x46, 0x21, 0x4e, 0xf2, 0x35, 0xd4, 0x9c, 0xa1, 0x1f, 0xb8, 0x02, 0xc3, 0x2c, 0x1d,
	0x0f, 0x8b, 0x7a, 0xcf, 0xf3, 0xe4, 0x16, 0x8f, 0x35, 0x67, 0xec, 0x64, 0xe9, 0x42, 0x0f, 0x05,
	0x86, 0x0e, 0xd2, 0x89, 0x22, 0x19, 0xc1, 0x55, 0x19, 0x70, 0x65, 0xe7, 0xd5, 0x21, 0xad, 0x8a,
	0xde, 0xe3, 0xe0, 0x3f, 0xef, 0xd1, 0x0b, 0xb8, 0x7a, 0x99, 0xa9, 0x4c, 0x77, 0xba, 0x22, 0x0b,
	0x66, 0x49, 0x3e, 0x81, 0x46, 0x2c, 0x51, 0x64, 0x85, 0x60, 0x55, 0x75, 0x7e, 0x6e, 0x2c, 0xe4,
	0xe7, 0x85, 0x44, 0x91, 0xca, 0x1e, 0x96, 0x28, 0xc4, 0x93, 0x15, 0xe9, 0x80, 0xc9, 0xa4, 0x44,
	0x65, 0x99, 0x9a, 0xb9, 0xb9, 0xc0, 0xdc, 0x4b, 0xbc, 0x87, 0x25, 0x9a, 0xc2, 0xc8, 0x3d, 0xa8,
	0xe5, 0x05, 0x61, 0xad, 0x69, 0xca, 0xf5, 0x05, 0x4a, 0x7e, 0x09, 0x87, 0x25, 0x3a, 0x01, 0x27,
	0xc4, 0x3c, 0x25, 0xd6, 0xa5, 0x15, 0xc4, 0xfc, 0x58, 0x09, 0x31, 0x07, 0x93, 0x6f, 0x60, 0xb3,
	0xcf, 0x04, 0xda, 0x0b, 0x05, 0x69, 0xd5, 0xb4, 0xcc, 0x9d, 0x05, 0x99, 0x47, 0x4c, 0xe0, 0x7c,
	0x41, 0x1c, 0x96, 0xe8, 0x46, 0x7f, 0x89, 0x3d, 0x89, 0xcb, 0xe1, 0xa1, 0x54, 0x2c, 0x54, 0x56,
	0x7d, 0x45, 0x5c, 0x8f, 0x33, 0x40, 0x12, 0x57, 0x0e, 0x4e, 0x88, 0x02, 0x25, 0x8f, 0x85, 0x83,
	0x16, 0xac, 0x20, 0xd2, 0x0c, 0x90, 0x10, 0x73, 0xf0, 0xa3, 0x35, 0xa8, 0x1e, 0xfb, 0xa1, 0x7b,
	0x54, 0xad, 0x95, 0x9b, 0x15, 0x0a, 0x4c, 0x29, 0xe1, 0xf7, 0x63, 0x85, 0xb2, 0xfd, 0x03, 0xac,
	0xcf, 0xdd, 0x16, 0x69, 0x01, 0xf8, 0x2e, 0x86, 0xca, 0xf7, 0x7c, 0x14, 0x59, 0x4b, 0x14, 0x2c,
	0xe4, 0x7d, 0xb8, 0x94, 0x4d, 0x97, 0xac, 0x37, 0x66, 0x6e, 0xf0, 0x65, 0xea, 0xda, 0x47, 0x8f,
	0xe6, 0x30, 0xb2, 0x05, 0xb5, 0x11, 0x2a, 0xe6, 0x32, 0xc5, 0xac, 0x8a, 0xd6, 0x9b, 0xac, 0xdb,
	0x0f, 0x00, 0xa6, 0x97, 0x4e, 0xba, 0xb0, 0xa1, 0x2f, 0xdd, 0xf6, 0xfc, 0x00, 0x6d, 0x17, 0x3d,
	0xdb, 0x0f, 0x5d, 0xfc, 0x4e, 0x47, 0x61, 0xd2, 0x6b, 0xda, 0x77, 0xe0, 0x07, 0xb8, 0x8f, 0xde,
	0x93, 0xc4, 0xd1, 0xfe, 0x1e, 0xae, 0xcc, 0x14, 0x00, 0xd9, 0x59, 0x3a, 0x47, 0x92, 0xa6, 0xab,
	0x2f, 0x19, 0x09, 0xe4, 0x01, 0x5c, 0xc9, 0x51, 0xb6, 0x8c, 0xd0, 0xc9, 0x8e, 0x64, 0x15, 0x8f,
	0x94, 0xa3, 0x7b, 0x11, 0x3a, 0xf4, 0xb2, 0x57, 0x58, 0xb5, 0xcf, 0x0d, 0xf8, 0xdf, 0xd2, 0x69,
	0x40, 0x6e, 0xc3, 0xe5, 0x3e, 0x8f, 0x43, 0xd7, 0xf6, 0xc3, 0x28, 0x56, 0xe9, 0x24, 0x33, 0x69,
	0x43, 0xdb, 0x9e, 0x68, 0x13, 0xb1, 0xe1, 0x0d, 0x87, 0x85, 0x3c, 0xf4, 0x1d, 0x16, 0xf8, 0xaf,
	0x30, 0x83, 0xda, 0xd2, 0x1f, 0x84, 0x4c, 0xc5, 0x02, 0x75, 0xae, 0xe6, 0x5b, 0x4b, 0x8f, 0xeb,
	0x58, 0x24, 0x95, 0x1b, 0xc4, 0x48, 0x6f, 0xcc, 0x28, 0x68, 0xe1, 0x5e, 0xce, 0x27, 0x07, 0xd0,
	0xe4, 0xb1, 0x9a, 0xd5, 0xac, 0x5e, 0xac, 0xb9, 0x9e, 0x92, 0x26, 0x3a, 0xed, 0xdf, 0x0c, 0xb8,
	0xbe, 0xb2, 0xcc, 0xc9, 0x87, 0xb0, 0xb9, 0x90, 0x71, 0x3b, 0x64, 0x23, 0xcc, 0x6a, 0x67, 0x63,
	0x3e, 0xeb, 0x5f, 0xb0, 0x11, 0x92, 0x77, 0xe1, 0x1a, 0x13, 0x83, 0x78, 0x84, 0xa1, 0xb2, 0x8f,
	0x71, 0x7c, 0xca, 0x85, 0x9b, 0x26, 0xa9, 0x4e, 0x9b, 0xb9, 0xe3, 0xf3, 0xcc, 0x4e, 0x1e, 0xc2,
	0x4d, 0x16, 0x04, 0xfc, 0x14, 0x5d, 0x3b, 0xe2, 0xd2, 0x4f, 0x44, 0x58, 0x60, 0xe7, 0x30, 0xa9,
	0x13, 0x55, 0xa1, 0x5b, 0x19, 0xe6, 0xd9, 0x04, 0xb2, 0x97, 0x23, 0xda, 0x3b, 0x59, 0x9d, 0xe4,
	0x7d, 0x45, 0x6e, 0x42, 0x9d, 0x47, 0x28, 0x98, 0x6e, 0xeb, 0x34, 0xd0, 0xa9, 0xa1, 0xfd, 0x4b,
	0x39, 0xc3, 0xe7, 0xf3, 0x81, 0xbc, 0x03, 0xa6, 0x9b, 0xfc, 0xa5, 0x35, 0xf6, 0xea, 0xee, 0x46,
	0x31, 0x81, 0xfb, 0x4c, 0xb1, 0xe7, 0xe3, 0x08, 0x69, 0x0a, 0x21, 0xbb, 0x60, 0xea, 0xff, 0x7e,
	0x56, 0x4c, 0x37, 0x67, 0xe6, 0xb0, 0xfe, 0xec, 0x25, 0xee, 0x67, 0xc9, 0xcf, 0x93, 0xa6, 0xd0,
	0x24, 0x1e, 0x25, 0x98, 0x1f, 0xea, 0x69, 0x95, 0x9c, 0xa7, 0x46, 0xa7, 0x06, 0xf2, 0x14, 0xd6,
	0xe5, 0x38, 0x74, 0x86, 0x82, 0x87, 0xfe, 0xab, 0x34, 0xe6, 0xaa, 0x8e, 0xe3, 0xad, 0x99, 0xde,
	0xcb, 0x82, 0xed, 0xcd, 0x42, 0xe9, 0x3c, 0x97, 0xec, 0x41, 0x83, 0x0d, 0x06, 0x02, 0x07, 0xa9,
	0x94, 0xa9, 0xa5, 0xde, 0x5c, 0x26, 0xb5, 0x37, 0x85, 0xd1, 0x22, 0x87, 0x10, 0xa8, 0xea, 0x3b,
	0x5e, 0xd3, 0xa9, 0xd3, 0xdf, 0xed, 0x5f, 0x0d, 0xb8, 0x5c, 0x6c, 0x16, 0xf2, 0x00, 0x1a, 0x5e,
	0x1c, 0x04, 0x4c, 0x0c, 0x74, 0x6f, 0x19, 0x17, 0xd7, 0x5e, 0x11, 0x4f, 0x6e, 0x40, 0xdd, 0x97,
	0xf6, 0x08, 0xd5, 0x90, 0xbb, 0x3a, 0x97, 0x35, 0x5a, 0xf3, 0xe5, 0x53, 0xbd, 0x26, 0xfb, 0xb0,
	0x3e, 0xdf, 0x2f, 0xe6, 0xc5, 0xfa, 0x57, 0xfd, 0x99, 0x16, 0x39, 0xaa, 0xd6, 0x2a, 0xcd, 0xea,
	0x51, 0xb5, 0x56, 0x6d, 0x9a, 0xed, 0xb7, 0xb3, 0x3b, 0xcf, 0x47, 0x28, 0xd9, 0x84, 0x35, 0x17,
	0x4f, 0x7c, 0x27, 0xaf, 0xe4, 0x6c, 0xf5, 0xe8, 0xc5, 0xef, 0x67, 0x2d, 0xe3, 0xf5, 0x59, 0xcb,
	0xf8, 0xf3, 0xac, 0x65, 0xfc, 0x74, 0xde, 0x2a, 0xbd, 0x3e, 0x6f, 0x95, 0xfe, 0x38, 0x6f, 0x95,
	0xbe, 0xba, 0x3f, 0xf0, 0xd5, 0x30, 0xee, 0x77, 0x1c, 0x3e, 0xea, 0xee, 0x45, 0x51, 0xa0, 0x27,
	0x66, 0x77, 0xc0, 0x77, 0x0a, 0x0f, 0x2b, 0xfd, 0xd6, 0xeb, 0xce, 0xbd, 0xb4, 0xfe, 0x32, 0x8c,
	0xfe, 0x9a, 0x7e, 0x4d, 0xdd, 0xfd, 0x3b, 0x00, 0x00, 0xff, 0xff, 0xc8, 0xda, 0x0f, 0x2c, 0x95,
	0x0a, 0x00, 0x00,
}

func (m *SavedObjectGraph) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SavedObjectGraph) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedObjectGraph) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ConcreteFunctions) > 0 {
		for k := range m.ConcreteFunctions {
			v := m.ConcreteFunctions[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SavedObject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SavedObject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedObject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Kind != nil {
		{
			size := m.Kind.Size()
			i -= size
			if _, err := m.Kind.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.SlotVariables) > 0 {
		for iNdEx := len(m.SlotVariables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SlotVariables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Children) > 0 {
		for iNdEx := len(m.Children) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Children[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SavedObject_UserObject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedObject_UserObject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UserObject != nil {
		{
			size, err := m.UserObject.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *SavedObject_Asset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedObject_Asset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Asset != nil {
		{
			size, err := m.Asset.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *SavedObject_Function) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedObject_Function) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Function != nil {
		{
			size, err := m.Function.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *SavedObject_Variable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedObject_Variable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Variable != nil {
		{
			size, err := m.Variable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *SavedObject_BareConcreteFunction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedObject_BareConcreteFunction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BareConcreteFunction != nil {
		{
			size, err := m.BareConcreteFunction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *SavedObject_Constant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedObject_Constant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Constant != nil {
		{
			size, err := m.Constant.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *SavedObject_Resource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedObject_Resource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Resource != nil {
		{
			size, err := m.Resource.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *SavedUserObject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SavedUserObject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedUserObject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintSavedObjectGraph(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Version != nil {
		{
			size, err := m.Version.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Identifier) > 0 {
		i -= len(m.Identifier)
		copy(dAtA[i:], m.Identifier)
		i = encodeVarintSavedObjectGraph(dAtA, i, uint64(len(m.Identifier)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SavedAsset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SavedAsset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedAsset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AssetFileDefIndex != 0 {
		i = encodeVarintSavedObjectGraph(dAtA, i, uint64(m.AssetFileDefIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SavedFunction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SavedFunction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedFunction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FunctionSpec != nil {
		{
			size, err := m.FunctionSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ConcreteFunctions) > 0 {
		for iNdEx := len(m.ConcreteFunctions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ConcreteFunctions[iNdEx])
			copy(dAtA[i:], m.ConcreteFunctions[iNdEx])
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(len(m.ConcreteFunctions[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SavedConcreteFunction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SavedConcreteFunction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedConcreteFunction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OutputSignature != nil {
		{
			size, err := m.OutputSignature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.CanonicalizedInputSignature != nil {
		{
			size, err := m.CanonicalizedInputSignature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BoundInputs) > 0 {
		dAtA14 := make([]byte, len(m.BoundInputs)*10)
		var j13 int
		for _, num1 := range m.BoundInputs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA14[:j13])
		i = encodeVarintSavedObjectGraph(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *SavedBareConcreteFunction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SavedBareConcreteFunction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedBareConcreteFunction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AllowedPositionalArguments != 0 {
		i = encodeVarintSavedObjectGraph(dAtA, i, uint64(m.AllowedPositionalArguments))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ArgumentKeywords) > 0 {
		for iNdEx := len(m.ArgumentKeywords) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ArgumentKeywords[iNdEx])
			copy(dAtA[i:], m.ArgumentKeywords[iNdEx])
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(len(m.ArgumentKeywords[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ConcreteFunctionName) > 0 {
		i -= len(m.ConcreteFunctionName)
		copy(dAtA[i:], m.ConcreteFunctionName)
		i = encodeVarintSavedObjectGraph(dAtA, i, uint64(len(m.ConcreteFunctionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SavedConstant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SavedConstant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedConstant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Operation) > 0 {
		i -= len(m.Operation)
		copy(dAtA[i:], m.Operation)
		i = encodeVarintSavedObjectGraph(dAtA, i, uint64(len(m.Operation)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SavedVariable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SavedVariable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedVariable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSavedObjectGraph(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x32
	}
	if m.Aggregation != 0 {
		i = encodeVarintSavedObjectGraph(dAtA, i, uint64(m.Aggregation))
		i--
		dAtA[i] = 0x28
	}
	if m.Synchronization != 0 {
		i = encodeVarintSavedObjectGraph(dAtA, i, uint64(m.Synchronization))
		i--
		dAtA[i] = 0x20
	}
	if m.Trainable {
		i--
		if m.Trainable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Shape != nil {
		{
			size, err := m.Shape.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Dtype != 0 {
		i = encodeVarintSavedObjectGraph(dAtA, i, uint64(m.Dtype))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FunctionSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FunctionSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FunctionSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InputSignature != nil {
		{
			size, err := m.InputSignature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.IsMethod {
		i--
		if m.IsMethod {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Fullargspec != nil {
		{
			size, err := m.Fullargspec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSavedObjectGraph(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SavedResource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SavedResource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SavedResource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Device) > 0 {
		i -= len(m.Device)
		copy(dAtA[i:], m.Device)
		i = encodeVarintSavedObjectGraph(dAtA, i, uint64(len(m.Device)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintSavedObjectGraph(dAtA []byte, offset int, v uint64) int {
	offset -= sovSavedObjectGraph(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SavedObjectGraph) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovSavedObjectGraph(uint64(l))
		}
	}
	if len(m.ConcreteFunctions) > 0 {
		for k, v := range m.ConcreteFunctions {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSavedObjectGraph(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSavedObjectGraph(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSavedObjectGraph(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SavedObject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovSavedObjectGraph(uint64(l))
		}
	}
	if len(m.SlotVariables) > 0 {
		for _, e := range m.SlotVariables {
			l = e.Size()
			n += 1 + l + sovSavedObjectGraph(uint64(l))
		}
	}
	if m.Kind != nil {
		n += m.Kind.Size()
	}
	return n
}

func (m *SavedObject_UserObject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserObject != nil {
		l = m.UserObject.Size()
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	return n
}
func (m *SavedObject_Asset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Asset != nil {
		l = m.Asset.Size()
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	return n
}
func (m *SavedObject_Function) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Function != nil {
		l = m.Function.Size()
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	return n
}
func (m *SavedObject_Variable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Variable != nil {
		l = m.Variable.Size()
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	return n
}
func (m *SavedObject_BareConcreteFunction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BareConcreteFunction != nil {
		l = m.BareConcreteFunction.Size()
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	return n
}
func (m *SavedObject_Constant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constant != nil {
		l = m.Constant.Size()
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	return n
}
func (m *SavedObject_Resource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Resource != nil {
		l = m.Resource.Size()
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	return n
}
func (m *SavedUserObject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Identifier)
	if l > 0 {
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	return n
}

func (m *SavedAsset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AssetFileDefIndex != 0 {
		n += 1 + sovSavedObjectGraph(uint64(m.AssetFileDefIndex))
	}
	return n
}

func (m *SavedFunction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ConcreteFunctions) > 0 {
		for _, s := range m.ConcreteFunctions {
			l = len(s)
			n += 1 + l + sovSavedObjectGraph(uint64(l))
		}
	}
	if m.FunctionSpec != nil {
		l = m.FunctionSpec.Size()
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	return n
}

func (m *SavedConcreteFunction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BoundInputs) > 0 {
		l = 0
		for _, e := range m.BoundInputs {
			l += sovSavedObjectGraph(uint64(e))
		}
		n += 1 + sovSavedObjectGraph(uint64(l)) + l
	}
	if m.CanonicalizedInputSignature != nil {
		l = m.CanonicalizedInputSignature.Size()
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	if m.OutputSignature != nil {
		l = m.OutputSignature.Size()
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	return n
}

func (m *SavedBareConcreteFunction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConcreteFunctionName)
	if l > 0 {
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	if len(m.ArgumentKeywords) > 0 {
		for _, s := range m.ArgumentKeywords {
			l = len(s)
			n += 1 + l + sovSavedObjectGraph(uint64(l))
		}
	}
	if m.AllowedPositionalArguments != 0 {
		n += 1 + sovSavedObjectGraph(uint64(m.AllowedPositionalArguments))
	}
	return n
}

func (m *SavedConstant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Operation)
	if l > 0 {
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	return n
}

func (m *SavedVariable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dtype != 0 {
		n += 1 + sovSavedObjectGraph(uint64(m.Dtype))
	}
	if m.Shape != nil {
		l = m.Shape.Size()
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	if m.Trainable {
		n += 2
	}
	if m.Synchronization != 0 {
		n += 1 + sovSavedObjectGraph(uint64(m.Synchronization))
	}
	if m.Aggregation != 0 {
		n += 1 + sovSavedObjectGraph(uint64(m.Aggregation))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	return n
}

func (m *FunctionSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Fullargspec != nil {
		l = m.Fullargspec.Size()
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	if m.IsMethod {
		n += 2
	}
	if m.InputSignature != nil {
		l = m.InputSignature.Size()
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	return n
}

func (m *SavedResource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Device)
	if l > 0 {
		n += 1 + l + sovSavedObjectGraph(uint64(l))
	}
	return n
}

func sovSavedObjectGraph(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSavedObjectGraph(x uint64) (n int) {
	return sovSavedObjectGraph(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SavedObjectGraph) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSavedObjectGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SavedObjectGraph: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SavedObjectGraph: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &SavedObject{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConcreteFunctions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConcreteFunctions == nil {
				m.ConcreteFunctions = make(map[string]*SavedConcreteFunction)
			}
			var mapkey string
			var mapvalue *SavedConcreteFunction
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSavedObjectGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSavedObjectGraph
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSavedObjectGraph
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSavedObjectGraph
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSavedObjectGraph
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSavedObjectGraph
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSavedObjectGraph
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SavedConcreteFunction{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSavedObjectGraph(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSavedObjectGraph
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ConcreteFunctions[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSavedObjectGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SavedObject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSavedObjectGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SavedObject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SavedObject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &TrackableObjectGraph_TrackableObject_ObjectReference{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlotVariables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlotVariables = append(m.SlotVariables, &TrackableObjectGraph_TrackableObject_SlotVariableReference{})
			if err := m.SlotVariables[len(m.SlotVariables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserObject", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SavedUserObject{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &SavedObject_UserObject{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SavedAsset{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &SavedObject_Asset{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Function", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SavedFunction{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &SavedObject_Function{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SavedVariable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &SavedObject_Variable{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BareConcreteFunction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SavedBareConcreteFunction{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &SavedObject_BareConcreteFunction{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constant", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SavedConstant{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &SavedObject_Constant{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SavedResource{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &SavedObject_Resource{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSavedObjectGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SavedUserObject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSavedObjectGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SavedUserObject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SavedUserObject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identifier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &framework.VersionDef{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSavedObjectGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SavedAsset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSavedObjectGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SavedAsset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SavedAsset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetFileDefIndex", wireType)
			}
			m.AssetFileDefIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssetFileDefIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSavedObjectGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SavedFunction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSavedObjectGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SavedFunction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SavedFunction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConcreteFunctions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConcreteFunctions = append(m.ConcreteFunctions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FunctionSpec == nil {
				m.FunctionSpec = &FunctionSpec{}
			}
			if err := m.FunctionSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSavedObjectGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SavedConcreteFunction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSavedObjectGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SavedConcreteFunction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SavedConcreteFunction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSavedObjectGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BoundInputs = append(m.BoundInputs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSavedObjectGraph
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSavedObjectGraph
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSavedObjectGraph
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BoundInputs) == 0 {
					m.BoundInputs = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSavedObjectGraph
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BoundInputs = append(m.BoundInputs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BoundInputs", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanonicalizedInputSignature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CanonicalizedInputSignature == nil {
				m.CanonicalizedInputSignature = &StructuredValue{}
			}
			if err := m.CanonicalizedInputSignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputSignature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputSignature == nil {
				m.OutputSignature = &StructuredValue{}
			}
			if err := m.OutputSignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSavedObjectGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SavedBareConcreteFunction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSavedObjectGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SavedBareConcreteFunction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SavedBareConcreteFunction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConcreteFunctionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConcreteFunctionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgumentKeywords", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArgumentKeywords = append(m.ArgumentKeywords, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedPositionalArguments", wireType)
			}
			m.AllowedPositionalArguments = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllowedPositionalArguments |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSavedObjectGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SavedConstant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSavedObjectGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SavedConstant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SavedConstant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSavedObjectGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SavedVariable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSavedObjectGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SavedVariable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SavedVariable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dtype", wireType)
			}
			m.Dtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dtype |= framework.DataType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shape", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shape == nil {
				m.Shape = &framework.TensorShapeProto{}
			}
			if err := m.Shape.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trainable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Trainable = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Synchronization", wireType)
			}
			m.Synchronization = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Synchronization |= framework.VariableSynchronization(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggregation", wireType)
			}
			m.Aggregation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aggregation |= framework.VariableAggregation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSavedObjectGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FunctionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSavedObjectGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FunctionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FunctionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fullargspec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fullargspec == nil {
				m.Fullargspec = &StructuredValue{}
			}
			if err := m.Fullargspec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMethod", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMethod = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputSignature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputSignature == nil {
				m.InputSignature = &StructuredValue{}
			}
			if err := m.InputSignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSavedObjectGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SavedResource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSavedObjectGraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SavedResource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SavedResource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Device = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSavedObjectGraph(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSavedObjectGraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSavedObjectGraph(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSavedObjectGraph
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSavedObjectGraph
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSavedObjectGraph
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSavedObjectGraph
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSavedObjectGraph
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSavedObjectGraph        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSavedObjectGraph          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSavedObjectGraph = fmt.Errorf("proto: unexpected end of group")
)
