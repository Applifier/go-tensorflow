// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tensorflow/core/framework/dataset_options.proto

package framework

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Represents the type of auto-sharding we enable.
type AutoShardPolicy int32

const (
	// AUTO: Attempts FILE-based sharding, falling back to DATA-based sharding.
	AutoShardPolicy_AUTO AutoShardPolicy = 0
	// FILE: Shards by input files (i.e. each worker will get a set of files to
	// process). When this option is selected, make sure that there is at least as
	// many files as workers. If there are fewer input files than workers, a
	// runtime error will be raised.
	AutoShardPolicy_FILE AutoShardPolicy = 1
	// DATA: Shards by elements produced by the dataset. Each worker will process
	// the whole dataset and discard the portion that is not for itself. Note that
	// for this mode to correctly partitions the dataset elements, the dataset
	// needs to produce elements in a deterministic order.
	AutoShardPolicy_DATA AutoShardPolicy = 2
	// HINT: Looks for the presence of `shard(SHARD_HINT, ...)` which is treated
	// as a placeholder to replace with `shard(num_workers, worker_index)`.
	AutoShardPolicy_HINT AutoShardPolicy = 3
	// OFF: No sharding will be performed.
	AutoShardPolicy_OFF AutoShardPolicy = -1
)

var AutoShardPolicy_name = map[int32]string{
	0:  "AUTO",
	1:  "FILE",
	2:  "DATA",
	3:  "HINT",
	-1: "OFF",
}

var AutoShardPolicy_value = map[string]int32{
	"AUTO": 0,
	"FILE": 1,
	"DATA": 2,
	"HINT": 3,
	"OFF":  -1,
}

func (x AutoShardPolicy) String() string {
	return proto.EnumName(AutoShardPolicy_name, int32(x))
}

func (AutoShardPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f68b0ecf4288c4dc, []int{0}
}

// Represents how to handle external state during serialization.
type ExternalStatePolicy int32

const (
	ExternalStatePolicy_POLICY_WARN   ExternalStatePolicy = 0
	ExternalStatePolicy_POLICY_IGNORE ExternalStatePolicy = 1
	ExternalStatePolicy_POLICY_FAIL   ExternalStatePolicy = 2
)

var ExternalStatePolicy_name = map[int32]string{
	0: "POLICY_WARN",
	1: "POLICY_IGNORE",
	2: "POLICY_FAIL",
}

var ExternalStatePolicy_value = map[string]int32{
	"POLICY_WARN":   0,
	"POLICY_IGNORE": 1,
	"POLICY_FAIL":   2,
}

func (x ExternalStatePolicy) String() string {
	return proto.EnumName(ExternalStatePolicy_name, int32(x))
}

func (ExternalStatePolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f68b0ecf4288c4dc, []int{1}
}

type DistributeOptions struct {
	AutoShardPolicy AutoShardPolicy `protobuf:"varint,1,opt,name=auto_shard_policy,json=autoShardPolicy,proto3,enum=tensorflow.data.AutoShardPolicy" json:"auto_shard_policy,omitempty"`
	// The number of devices attached to this input pipeline.
	//
	// Types that are valid to be assigned to OptionalNumDevices:
	//	*DistributeOptions_NumDevices
	OptionalNumDevices isDistributeOptions_OptionalNumDevices `protobuf_oneof:"optional_num_devices"`
}

func (m *DistributeOptions) Reset()         { *m = DistributeOptions{} }
func (m *DistributeOptions) String() string { return proto.CompactTextString(m) }
func (*DistributeOptions) ProtoMessage()    {}
func (*DistributeOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_f68b0ecf4288c4dc, []int{0}
}
func (m *DistributeOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DistributeOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DistributeOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DistributeOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DistributeOptions.Merge(m, src)
}
func (m *DistributeOptions) XXX_Size() int {
	return m.Size()
}
func (m *DistributeOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_DistributeOptions.DiscardUnknown(m)
}

var xxx_messageInfo_DistributeOptions proto.InternalMessageInfo

type isDistributeOptions_OptionalNumDevices interface {
	isDistributeOptions_OptionalNumDevices()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DistributeOptions_NumDevices struct {
	NumDevices int32 `protobuf:"varint,2,opt,name=num_devices,json=numDevices,proto3,oneof" json:"num_devices,omitempty"`
}

func (*DistributeOptions_NumDevices) isDistributeOptions_OptionalNumDevices() {}

func (m *DistributeOptions) GetOptionalNumDevices() isDistributeOptions_OptionalNumDevices {
	if m != nil {
		return m.OptionalNumDevices
	}
	return nil
}

func (m *DistributeOptions) GetAutoShardPolicy() AutoShardPolicy {
	if m != nil {
		return m.AutoShardPolicy
	}
	return AutoShardPolicy_AUTO
}

func (m *DistributeOptions) GetNumDevices() int32 {
	if x, ok := m.GetOptionalNumDevices().(*DistributeOptions_NumDevices); ok {
		return x.NumDevices
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DistributeOptions) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DistributeOptions_NumDevices)(nil),
	}
}

type MapVectorization struct {
	// Whether to vectorize map transformations.
	//
	// Types that are valid to be assigned to OptionalEnabled:
	//	*MapVectorization_Enabled
	OptionalEnabled isMapVectorization_OptionalEnabled `protobuf_oneof:"optional_enabled"`
	// Whether to use ChooseFastestBranchDataset with this transformation. If
	// True, the pipeline picks between the vectorized and original segment at
	// runtime based on their iterations speed.
	//
	// Types that are valid to be assigned to OptionalUseChooseFastest:
	//	*MapVectorization_UseChooseFastest
	OptionalUseChooseFastest isMapVectorization_OptionalUseChooseFastest `protobuf_oneof:"optional_use_choose_fastest"`
}

func (m *MapVectorization) Reset()         { *m = MapVectorization{} }
func (m *MapVectorization) String() string { return proto.CompactTextString(m) }
func (*MapVectorization) ProtoMessage()    {}
func (*MapVectorization) Descriptor() ([]byte, []int) {
	return fileDescriptor_f68b0ecf4288c4dc, []int{1}
}
func (m *MapVectorization) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MapVectorization) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MapVectorization.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MapVectorization) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MapVectorization.Merge(m, src)
}
func (m *MapVectorization) XXX_Size() int {
	return m.Size()
}
func (m *MapVectorization) XXX_DiscardUnknown() {
	xxx_messageInfo_MapVectorization.DiscardUnknown(m)
}

var xxx_messageInfo_MapVectorization proto.InternalMessageInfo

type isMapVectorization_OptionalEnabled interface {
	isMapVectorization_OptionalEnabled()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isMapVectorization_OptionalUseChooseFastest interface {
	isMapVectorization_OptionalUseChooseFastest()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MapVectorization_Enabled struct {
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3,oneof" json:"enabled,omitempty"`
}
type MapVectorization_UseChooseFastest struct {
	UseChooseFastest bool `protobuf:"varint,2,opt,name=use_choose_fastest,json=useChooseFastest,proto3,oneof" json:"use_choose_fastest,omitempty"`
}

func (*MapVectorization_Enabled) isMapVectorization_OptionalEnabled()                   {}
func (*MapVectorization_UseChooseFastest) isMapVectorization_OptionalUseChooseFastest() {}

func (m *MapVectorization) GetOptionalEnabled() isMapVectorization_OptionalEnabled {
	if m != nil {
		return m.OptionalEnabled
	}
	return nil
}
func (m *MapVectorization) GetOptionalUseChooseFastest() isMapVectorization_OptionalUseChooseFastest {
	if m != nil {
		return m.OptionalUseChooseFastest
	}
	return nil
}

func (m *MapVectorization) GetEnabled() bool {
	if x, ok := m.GetOptionalEnabled().(*MapVectorization_Enabled); ok {
		return x.Enabled
	}
	return false
}

func (m *MapVectorization) GetUseChooseFastest() bool {
	if x, ok := m.GetOptionalUseChooseFastest().(*MapVectorization_UseChooseFastest); ok {
		return x.UseChooseFastest
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MapVectorization) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MapVectorization_Enabled)(nil),
		(*MapVectorization_UseChooseFastest)(nil),
	}
}

type OptimizationOptions struct {
	// Whether to apply default graph optimizations. If False, only graph
	// optimizations that have been explicitly enabled will be applied.
	//
	// Types that are valid to be assigned to OptionalApplyDefaultOptimizations:
	//	*OptimizationOptions_ApplyDefaultOptimizations
	OptionalApplyDefaultOptimizations isOptimizationOptions_OptionalApplyDefaultOptimizations `protobuf_oneof:"optional_apply_default_optimizations"`
	// Whether to automatically tune performance knobs.
	//
	// Types that are valid to be assigned to OptionalAutotune:
	//	*OptimizationOptions_Autotune
	OptionalAutotune isOptimizationOptions_OptionalAutotune `protobuf_oneof:"optional_autotune"`
	// When autotuning is enabled (through autotune), determines whether to also
	// autotune buffer sizes for datasets with parallelism.
	//
	// Types that are valid to be assigned to OptionalAutotuneBuffers:
	//	*OptimizationOptions_AutotuneBuffers
	OptionalAutotuneBuffers isOptimizationOptions_OptionalAutotuneBuffers `protobuf_oneof:"optional_autotune_buffers"`
	// When autotuning is enabled (through autotune), determines the CPU budget to
	// use. Values greater than the number of schedulable CPU cores are allowed
	// but may result in CPU contention.
	//
	// Types that are valid to be assigned to OptionalAutotuneCpuBudget:
	//	*OptimizationOptions_AutotuneCpuBudget
	OptionalAutotuneCpuBudget isOptimizationOptions_OptionalAutotuneCpuBudget `protobuf_oneof:"optional_autotune_cpu_budget"`
	// When autotuning is enabled (through autotune), determines the RAM budget to
	// use. Values greater than the available RAM in bytes may result in OOM. If
	// 0, defaults to half of the available RAM in bytes.
	//
	// Types that are valid to be assigned to OptionalAutotuneRamBudget:
	//	*OptimizationOptions_AutotuneRamBudget
	OptionalAutotuneRamBudget isOptimizationOptions_OptionalAutotuneRamBudget `protobuf_oneof:"optional_autotune_ram_budget"`
	// Whether to fuse filter transformations.
	//
	// Types that are valid to be assigned to OptionalFilterFusion:
	//	*OptimizationOptions_FilterFusion
	OptionalFilterFusion isOptimizationOptions_OptionalFilterFusion `protobuf_oneof:"optional_filter_fusion"`
	// Whether to fuse filter dataset that predicts random_uniform < rate into a
	// sampling dataset.
	//
	// Types that are valid to be assigned to OptionalFilterWithRandomUniformFusion:
	//	*OptimizationOptions_FilterWithRandomUniformFusion
	OptionalFilterWithRandomUniformFusion isOptimizationOptions_OptionalFilterWithRandomUniformFusion `protobuf_oneof:"optional_filter_with_random_uniform_fusion"`
	// Whether to hoist tf.random_uniform() ops out of map transformations.
	//
	// Types that are valid to be assigned to OptionalHoistRandomUniform:
	//	*OptimizationOptions_HoistRandomUniform
	OptionalHoistRandomUniform isOptimizationOptions_OptionalHoistRandomUniform `protobuf_oneof:"optional_hoist_random_uniform"`
	// Whether to fuse map and batch transformations.
	//
	// Types that are valid to be assigned to OptionalMapAndBatchFusion:
	//	*OptimizationOptions_MapAndBatchFusion
	OptionalMapAndBatchFusion isOptimizationOptions_OptionalMapAndBatchFusion `protobuf_oneof:"optional_map_and_batch_fusion"`
	// Whether to fuse map and filter transformations.
	//
	// Types that are valid to be assigned to OptionalMapAndFilterFusion:
	//	*OptimizationOptions_MapAndFilterFusion
	OptionalMapAndFilterFusion isOptimizationOptions_OptionalMapAndFilterFusion `protobuf_oneof:"optional_map_and_filter_fusion"`
	// Whether to fuse map transformations.
	//
	// Types that are valid to be assigned to OptionalMapFusion:
	//	*OptimizationOptions_MapFusion
	OptionalMapFusion isOptimizationOptions_OptionalMapFusion `protobuf_oneof:"optional_map_fusion"`
	// Whether to parallelize stateless map transformations.
	//
	// Types that are valid to be assigned to OptionalMapParallelization:
	//	*OptimizationOptions_MapParallelization
	OptionalMapParallelization isOptimizationOptions_OptionalMapParallelization `protobuf_oneof:"optional_map_parallelization"`
	// The map vectorization options associated with the dataset.
	MapVectorization *MapVectorization `protobuf:"bytes,13,opt,name=map_vectorization,json=mapVectorization,proto3" json:"map_vectorization,omitempty"`
	// Whether to eliminate no-op transformations.
	//
	// Types that are valid to be assigned to OptionalNoopElimination:
	//	*OptimizationOptions_NoopElimination
	OptionalNoopElimination isOptimizationOptions_OptionalNoopElimination `protobuf_oneof:"optional_noop_elimination"`
	// Whether to parallelize copying of batch elements. This optimization is
	// highly experimental and can cause performance degradation (e.g. when the
	// parallelization overhead exceeds the benefits of performing the data copies
	// in parallel). You should only enable this optimization if a) your input
	// pipeline is bottlenecked on batching and b) you have validated that this
	// optimization improves performance.
	//
	// Types that are valid to be assigned to OptionalParallelBatch:
	//	*OptimizationOptions_ParallelBatch
	OptionalParallelBatch isOptimizationOptions_OptionalParallelBatch `protobuf_oneof:"optional_parallel_batch"`
	// Whether to reorder ops that will discard data to the front of unary
	// cardinality preserving transformations, e.g. dataset.map(...).take(3) will
	// be optimized to dataset.take(3).map(...). For now this optimization will
	// move `skip`, `shard` and `take` to the front of `map` and `prefetch`. This
	// optimization is only for performance; it will not affect the output of the
	// dataset.
	//
	// Types that are valid to be assigned to OptionalReorderDataDiscardingOps:
	//	*OptimizationOptions_ReorderDataDiscardingOps
	OptionalReorderDataDiscardingOps isOptimizationOptions_OptionalReorderDataDiscardingOps `protobuf_oneof:"optional_reorder_data_discarding_ops"`
	// Whether to fuse shuffle and repeat transformations.
	//
	// Types that are valid to be assigned to OptionalShuffleAndRepeatFusion:
	//	*OptimizationOptions_ShuffleAndRepeatFusion
	OptionalShuffleAndRepeatFusion isOptimizationOptions_OptionalShuffleAndRepeatFusion `protobuf_oneof:"optional_shuffle_and_repeat_fusion"`
}

func (m *OptimizationOptions) Reset()         { *m = OptimizationOptions{} }
func (m *OptimizationOptions) String() string { return proto.CompactTextString(m) }
func (*OptimizationOptions) ProtoMessage()    {}
func (*OptimizationOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_f68b0ecf4288c4dc, []int{2}
}
func (m *OptimizationOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OptimizationOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OptimizationOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OptimizationOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OptimizationOptions.Merge(m, src)
}
func (m *OptimizationOptions) XXX_Size() int {
	return m.Size()
}
func (m *OptimizationOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_OptimizationOptions.DiscardUnknown(m)
}

var xxx_messageInfo_OptimizationOptions proto.InternalMessageInfo

type isOptimizationOptions_OptionalApplyDefaultOptimizations interface {
	isOptimizationOptions_OptionalApplyDefaultOptimizations()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isOptimizationOptions_OptionalAutotune interface {
	isOptimizationOptions_OptionalAutotune()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isOptimizationOptions_OptionalAutotuneBuffers interface {
	isOptimizationOptions_OptionalAutotuneBuffers()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isOptimizationOptions_OptionalAutotuneCpuBudget interface {
	isOptimizationOptions_OptionalAutotuneCpuBudget()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isOptimizationOptions_OptionalAutotuneRamBudget interface {
	isOptimizationOptions_OptionalAutotuneRamBudget()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isOptimizationOptions_OptionalFilterFusion interface {
	isOptimizationOptions_OptionalFilterFusion()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isOptimizationOptions_OptionalFilterWithRandomUniformFusion interface {
	isOptimizationOptions_OptionalFilterWithRandomUniformFusion()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isOptimizationOptions_OptionalHoistRandomUniform interface {
	isOptimizationOptions_OptionalHoistRandomUniform()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isOptimizationOptions_OptionalMapAndBatchFusion interface {
	isOptimizationOptions_OptionalMapAndBatchFusion()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isOptimizationOptions_OptionalMapAndFilterFusion interface {
	isOptimizationOptions_OptionalMapAndFilterFusion()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isOptimizationOptions_OptionalMapFusion interface {
	isOptimizationOptions_OptionalMapFusion()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isOptimizationOptions_OptionalMapParallelization interface {
	isOptimizationOptions_OptionalMapParallelization()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isOptimizationOptions_OptionalNoopElimination interface {
	isOptimizationOptions_OptionalNoopElimination()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isOptimizationOptions_OptionalParallelBatch interface {
	isOptimizationOptions_OptionalParallelBatch()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isOptimizationOptions_OptionalReorderDataDiscardingOps interface {
	isOptimizationOptions_OptionalReorderDataDiscardingOps()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isOptimizationOptions_OptionalShuffleAndRepeatFusion interface {
	isOptimizationOptions_OptionalShuffleAndRepeatFusion()
	MarshalTo([]byte) (int, error)
	Size() int
}

type OptimizationOptions_ApplyDefaultOptimizations struct {
	ApplyDefaultOptimizations bool `protobuf:"varint,1,opt,name=apply_default_optimizations,json=applyDefaultOptimizations,proto3,oneof" json:"apply_default_optimizations,omitempty"`
}
type OptimizationOptions_Autotune struct {
	Autotune bool `protobuf:"varint,2,opt,name=autotune,proto3,oneof" json:"autotune,omitempty"`
}
type OptimizationOptions_AutotuneBuffers struct {
	AutotuneBuffers bool `protobuf:"varint,3,opt,name=autotune_buffers,json=autotuneBuffers,proto3,oneof" json:"autotune_buffers,omitempty"`
}
type OptimizationOptions_AutotuneCpuBudget struct {
	AutotuneCpuBudget int32 `protobuf:"varint,4,opt,name=autotune_cpu_budget,json=autotuneCpuBudget,proto3,oneof" json:"autotune_cpu_budget,omitempty"`
}
type OptimizationOptions_AutotuneRamBudget struct {
	AutotuneRamBudget int32 `protobuf:"varint,5,opt,name=autotune_ram_budget,json=autotuneRamBudget,proto3,oneof" json:"autotune_ram_budget,omitempty"`
}
type OptimizationOptions_FilterFusion struct {
	FilterFusion bool `protobuf:"varint,6,opt,name=filter_fusion,json=filterFusion,proto3,oneof" json:"filter_fusion,omitempty"`
}
type OptimizationOptions_FilterWithRandomUniformFusion struct {
	FilterWithRandomUniformFusion bool `protobuf:"varint,7,opt,name=filter_with_random_uniform_fusion,json=filterWithRandomUniformFusion,proto3,oneof" json:"filter_with_random_uniform_fusion,omitempty"`
}
type OptimizationOptions_HoistRandomUniform struct {
	HoistRandomUniform bool `protobuf:"varint,8,opt,name=hoist_random_uniform,json=hoistRandomUniform,proto3,oneof" json:"hoist_random_uniform,omitempty"`
}
type OptimizationOptions_MapAndBatchFusion struct {
	MapAndBatchFusion bool `protobuf:"varint,9,opt,name=map_and_batch_fusion,json=mapAndBatchFusion,proto3,oneof" json:"map_and_batch_fusion,omitempty"`
}
type OptimizationOptions_MapAndFilterFusion struct {
	MapAndFilterFusion bool `protobuf:"varint,10,opt,name=map_and_filter_fusion,json=mapAndFilterFusion,proto3,oneof" json:"map_and_filter_fusion,omitempty"`
}
type OptimizationOptions_MapFusion struct {
	MapFusion bool `protobuf:"varint,11,opt,name=map_fusion,json=mapFusion,proto3,oneof" json:"map_fusion,omitempty"`
}
type OptimizationOptions_MapParallelization struct {
	MapParallelization bool `protobuf:"varint,12,opt,name=map_parallelization,json=mapParallelization,proto3,oneof" json:"map_parallelization,omitempty"`
}
type OptimizationOptions_NoopElimination struct {
	NoopElimination bool `protobuf:"varint,14,opt,name=noop_elimination,json=noopElimination,proto3,oneof" json:"noop_elimination,omitempty"`
}
type OptimizationOptions_ParallelBatch struct {
	ParallelBatch bool `protobuf:"varint,15,opt,name=parallel_batch,json=parallelBatch,proto3,oneof" json:"parallel_batch,omitempty"`
}
type OptimizationOptions_ReorderDataDiscardingOps struct {
	ReorderDataDiscardingOps bool `protobuf:"varint,16,opt,name=reorder_data_discarding_ops,json=reorderDataDiscardingOps,proto3,oneof" json:"reorder_data_discarding_ops,omitempty"`
}
type OptimizationOptions_ShuffleAndRepeatFusion struct {
	ShuffleAndRepeatFusion bool `protobuf:"varint,17,opt,name=shuffle_and_repeat_fusion,json=shuffleAndRepeatFusion,proto3,oneof" json:"shuffle_and_repeat_fusion,omitempty"`
}

func (*OptimizationOptions_ApplyDefaultOptimizations) isOptimizationOptions_OptionalApplyDefaultOptimizations() {
}
func (*OptimizationOptions_Autotune) isOptimizationOptions_OptionalAutotune()                   {}
func (*OptimizationOptions_AutotuneBuffers) isOptimizationOptions_OptionalAutotuneBuffers()     {}
func (*OptimizationOptions_AutotuneCpuBudget) isOptimizationOptions_OptionalAutotuneCpuBudget() {}
func (*OptimizationOptions_AutotuneRamBudget) isOptimizationOptions_OptionalAutotuneRamBudget() {}
func (*OptimizationOptions_FilterFusion) isOptimizationOptions_OptionalFilterFusion()           {}
func (*OptimizationOptions_FilterWithRandomUniformFusion) isOptimizationOptions_OptionalFilterWithRandomUniformFusion() {
}
func (*OptimizationOptions_HoistRandomUniform) isOptimizationOptions_OptionalHoistRandomUniform() {}
func (*OptimizationOptions_MapAndBatchFusion) isOptimizationOptions_OptionalMapAndBatchFusion()   {}
func (*OptimizationOptions_MapAndFilterFusion) isOptimizationOptions_OptionalMapAndFilterFusion() {}
func (*OptimizationOptions_MapFusion) isOptimizationOptions_OptionalMapFusion()                   {}
func (*OptimizationOptions_MapParallelization) isOptimizationOptions_OptionalMapParallelization() {}
func (*OptimizationOptions_NoopElimination) isOptimizationOptions_OptionalNoopElimination()       {}
func (*OptimizationOptions_ParallelBatch) isOptimizationOptions_OptionalParallelBatch()           {}
func (*OptimizationOptions_ReorderDataDiscardingOps) isOptimizationOptions_OptionalReorderDataDiscardingOps() {
}
func (*OptimizationOptions_ShuffleAndRepeatFusion) isOptimizationOptions_OptionalShuffleAndRepeatFusion() {
}

func (m *OptimizationOptions) GetOptionalApplyDefaultOptimizations() isOptimizationOptions_OptionalApplyDefaultOptimizations {
	if m != nil {
		return m.OptionalApplyDefaultOptimizations
	}
	return nil
}
func (m *OptimizationOptions) GetOptionalAutotune() isOptimizationOptions_OptionalAutotune {
	if m != nil {
		return m.OptionalAutotune
	}
	return nil
}
func (m *OptimizationOptions) GetOptionalAutotuneBuffers() isOptimizationOptions_OptionalAutotuneBuffers {
	if m != nil {
		return m.OptionalAutotuneBuffers
	}
	return nil
}
func (m *OptimizationOptions) GetOptionalAutotuneCpuBudget() isOptimizationOptions_OptionalAutotuneCpuBudget {
	if m != nil {
		return m.OptionalAutotuneCpuBudget
	}
	return nil
}
func (m *OptimizationOptions) GetOptionalAutotuneRamBudget() isOptimizationOptions_OptionalAutotuneRamBudget {
	if m != nil {
		return m.OptionalAutotuneRamBudget
	}
	return nil
}
func (m *OptimizationOptions) GetOptionalFilterFusion() isOptimizationOptions_OptionalFilterFusion {
	if m != nil {
		return m.OptionalFilterFusion
	}
	return nil
}
func (m *OptimizationOptions) GetOptionalFilterWithRandomUniformFusion() isOptimizationOptions_OptionalFilterWithRandomUniformFusion {
	if m != nil {
		return m.OptionalFilterWithRandomUniformFusion
	}
	return nil
}
func (m *OptimizationOptions) GetOptionalHoistRandomUniform() isOptimizationOptions_OptionalHoistRandomUniform {
	if m != nil {
		return m.OptionalHoistRandomUniform
	}
	return nil
}
func (m *OptimizationOptions) GetOptionalMapAndBatchFusion() isOptimizationOptions_OptionalMapAndBatchFusion {
	if m != nil {
		return m.OptionalMapAndBatchFusion
	}
	return nil
}
func (m *OptimizationOptions) GetOptionalMapAndFilterFusion() isOptimizationOptions_OptionalMapAndFilterFusion {
	if m != nil {
		return m.OptionalMapAndFilterFusion
	}
	return nil
}
func (m *OptimizationOptions) GetOptionalMapFusion() isOptimizationOptions_OptionalMapFusion {
	if m != nil {
		return m.OptionalMapFusion
	}
	return nil
}
func (m *OptimizationOptions) GetOptionalMapParallelization() isOptimizationOptions_OptionalMapParallelization {
	if m != nil {
		return m.OptionalMapParallelization
	}
	return nil
}
func (m *OptimizationOptions) GetOptionalNoopElimination() isOptimizationOptions_OptionalNoopElimination {
	if m != nil {
		return m.OptionalNoopElimination
	}
	return nil
}
func (m *OptimizationOptions) GetOptionalParallelBatch() isOptimizationOptions_OptionalParallelBatch {
	if m != nil {
		return m.OptionalParallelBatch
	}
	return nil
}
func (m *OptimizationOptions) GetOptionalReorderDataDiscardingOps() isOptimizationOptions_OptionalReorderDataDiscardingOps {
	if m != nil {
		return m.OptionalReorderDataDiscardingOps
	}
	return nil
}
func (m *OptimizationOptions) GetOptionalShuffleAndRepeatFusion() isOptimizationOptions_OptionalShuffleAndRepeatFusion {
	if m != nil {
		return m.OptionalShuffleAndRepeatFusion
	}
	return nil
}

func (m *OptimizationOptions) GetApplyDefaultOptimizations() bool {
	if x, ok := m.GetOptionalApplyDefaultOptimizations().(*OptimizationOptions_ApplyDefaultOptimizations); ok {
		return x.ApplyDefaultOptimizations
	}
	return false
}

func (m *OptimizationOptions) GetAutotune() bool {
	if x, ok := m.GetOptionalAutotune().(*OptimizationOptions_Autotune); ok {
		return x.Autotune
	}
	return false
}

func (m *OptimizationOptions) GetAutotuneBuffers() bool {
	if x, ok := m.GetOptionalAutotuneBuffers().(*OptimizationOptions_AutotuneBuffers); ok {
		return x.AutotuneBuffers
	}
	return false
}

func (m *OptimizationOptions) GetAutotuneCpuBudget() int32 {
	if x, ok := m.GetOptionalAutotuneCpuBudget().(*OptimizationOptions_AutotuneCpuBudget); ok {
		return x.AutotuneCpuBudget
	}
	return 0
}

func (m *OptimizationOptions) GetAutotuneRamBudget() int32 {
	if x, ok := m.GetOptionalAutotuneRamBudget().(*OptimizationOptions_AutotuneRamBudget); ok {
		return x.AutotuneRamBudget
	}
	return 0
}

func (m *OptimizationOptions) GetFilterFusion() bool {
	if x, ok := m.GetOptionalFilterFusion().(*OptimizationOptions_FilterFusion); ok {
		return x.FilterFusion
	}
	return false
}

func (m *OptimizationOptions) GetFilterWithRandomUniformFusion() bool {
	if x, ok := m.GetOptionalFilterWithRandomUniformFusion().(*OptimizationOptions_FilterWithRandomUniformFusion); ok {
		return x.FilterWithRandomUniformFusion
	}
	return false
}

func (m *OptimizationOptions) GetHoistRandomUniform() bool {
	if x, ok := m.GetOptionalHoistRandomUniform().(*OptimizationOptions_HoistRandomUniform); ok {
		return x.HoistRandomUniform
	}
	return false
}

func (m *OptimizationOptions) GetMapAndBatchFusion() bool {
	if x, ok := m.GetOptionalMapAndBatchFusion().(*OptimizationOptions_MapAndBatchFusion); ok {
		return x.MapAndBatchFusion
	}
	return false
}

func (m *OptimizationOptions) GetMapAndFilterFusion() bool {
	if x, ok := m.GetOptionalMapAndFilterFusion().(*OptimizationOptions_MapAndFilterFusion); ok {
		return x.MapAndFilterFusion
	}
	return false
}

func (m *OptimizationOptions) GetMapFusion() bool {
	if x, ok := m.GetOptionalMapFusion().(*OptimizationOptions_MapFusion); ok {
		return x.MapFusion
	}
	return false
}

func (m *OptimizationOptions) GetMapParallelization() bool {
	if x, ok := m.GetOptionalMapParallelization().(*OptimizationOptions_MapParallelization); ok {
		return x.MapParallelization
	}
	return false
}

func (m *OptimizationOptions) GetMapVectorization() *MapVectorization {
	if m != nil {
		return m.MapVectorization
	}
	return nil
}

func (m *OptimizationOptions) GetNoopElimination() bool {
	if x, ok := m.GetOptionalNoopElimination().(*OptimizationOptions_NoopElimination); ok {
		return x.NoopElimination
	}
	return false
}

func (m *OptimizationOptions) GetParallelBatch() bool {
	if x, ok := m.GetOptionalParallelBatch().(*OptimizationOptions_ParallelBatch); ok {
		return x.ParallelBatch
	}
	return false
}

func (m *OptimizationOptions) GetReorderDataDiscardingOps() bool {
	if x, ok := m.GetOptionalReorderDataDiscardingOps().(*OptimizationOptions_ReorderDataDiscardingOps); ok {
		return x.ReorderDataDiscardingOps
	}
	return false
}

func (m *OptimizationOptions) GetShuffleAndRepeatFusion() bool {
	if x, ok := m.GetOptionalShuffleAndRepeatFusion().(*OptimizationOptions_ShuffleAndRepeatFusion); ok {
		return x.ShuffleAndRepeatFusion
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*OptimizationOptions) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*OptimizationOptions_ApplyDefaultOptimizations)(nil),
		(*OptimizationOptions_Autotune)(nil),
		(*OptimizationOptions_AutotuneBuffers)(nil),
		(*OptimizationOptions_AutotuneCpuBudget)(nil),
		(*OptimizationOptions_AutotuneRamBudget)(nil),
		(*OptimizationOptions_FilterFusion)(nil),
		(*OptimizationOptions_FilterWithRandomUniformFusion)(nil),
		(*OptimizationOptions_HoistRandomUniform)(nil),
		(*OptimizationOptions_MapAndBatchFusion)(nil),
		(*OptimizationOptions_MapAndFilterFusion)(nil),
		(*OptimizationOptions_MapFusion)(nil),
		(*OptimizationOptions_MapParallelization)(nil),
		(*OptimizationOptions_NoopElimination)(nil),
		(*OptimizationOptions_ParallelBatch)(nil),
		(*OptimizationOptions_ReorderDataDiscardingOps)(nil),
		(*OptimizationOptions_ShuffleAndRepeatFusion)(nil),
	}
}

type ThreadingOptions struct {
	// If set, it overrides the maximum degree of intra-op parallelism.
	//
	// Types that are valid to be assigned to OptionalMaxIntraOpParallelism:
	//	*ThreadingOptions_MaxIntraOpParallelism
	OptionalMaxIntraOpParallelism isThreadingOptions_OptionalMaxIntraOpParallelism `protobuf_oneof:"optional_max_intra_op_parallelism"`
	// If set, the dataset will use a private threadpool of the given size.
	//
	// Types that are valid to be assigned to OptionalPrivateThreadpoolSize:
	//	*ThreadingOptions_PrivateThreadpoolSize
	OptionalPrivateThreadpoolSize isThreadingOptions_OptionalPrivateThreadpoolSize `protobuf_oneof:"optional_private_threadpool_size"`
}

func (m *ThreadingOptions) Reset()         { *m = ThreadingOptions{} }
func (m *ThreadingOptions) String() string { return proto.CompactTextString(m) }
func (*ThreadingOptions) ProtoMessage()    {}
func (*ThreadingOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_f68b0ecf4288c4dc, []int{3}
}
func (m *ThreadingOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ThreadingOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ThreadingOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ThreadingOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThreadingOptions.Merge(m, src)
}
func (m *ThreadingOptions) XXX_Size() int {
	return m.Size()
}
func (m *ThreadingOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_ThreadingOptions.DiscardUnknown(m)
}

var xxx_messageInfo_ThreadingOptions proto.InternalMessageInfo

type isThreadingOptions_OptionalMaxIntraOpParallelism interface {
	isThreadingOptions_OptionalMaxIntraOpParallelism()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isThreadingOptions_OptionalPrivateThreadpoolSize interface {
	isThreadingOptions_OptionalPrivateThreadpoolSize()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ThreadingOptions_MaxIntraOpParallelism struct {
	MaxIntraOpParallelism int32 `protobuf:"varint,1,opt,name=max_intra_op_parallelism,json=maxIntraOpParallelism,proto3,oneof" json:"max_intra_op_parallelism,omitempty"`
}
type ThreadingOptions_PrivateThreadpoolSize struct {
	PrivateThreadpoolSize int32 `protobuf:"varint,2,opt,name=private_threadpool_size,json=privateThreadpoolSize,proto3,oneof" json:"private_threadpool_size,omitempty"`
}

func (*ThreadingOptions_MaxIntraOpParallelism) isThreadingOptions_OptionalMaxIntraOpParallelism() {}
func (*ThreadingOptions_PrivateThreadpoolSize) isThreadingOptions_OptionalPrivateThreadpoolSize() {}

func (m *ThreadingOptions) GetOptionalMaxIntraOpParallelism() isThreadingOptions_OptionalMaxIntraOpParallelism {
	if m != nil {
		return m.OptionalMaxIntraOpParallelism
	}
	return nil
}
func (m *ThreadingOptions) GetOptionalPrivateThreadpoolSize() isThreadingOptions_OptionalPrivateThreadpoolSize {
	if m != nil {
		return m.OptionalPrivateThreadpoolSize
	}
	return nil
}

func (m *ThreadingOptions) GetMaxIntraOpParallelism() int32 {
	if x, ok := m.GetOptionalMaxIntraOpParallelism().(*ThreadingOptions_MaxIntraOpParallelism); ok {
		return x.MaxIntraOpParallelism
	}
	return 0
}

func (m *ThreadingOptions) GetPrivateThreadpoolSize() int32 {
	if x, ok := m.GetOptionalPrivateThreadpoolSize().(*ThreadingOptions_PrivateThreadpoolSize); ok {
		return x.PrivateThreadpoolSize
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ThreadingOptions) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ThreadingOptions_MaxIntraOpParallelism)(nil),
		(*ThreadingOptions_PrivateThreadpoolSize)(nil),
	}
}

// Message stored with Dataset objects to control how datasets are processed and
// optimized.
type Options struct {
	// Whether the outputs need to be produced in deterministic order.
	//
	// Types that are valid to be assigned to OptionalDeterministic:
	//	*Options_Deterministic
	OptionalDeterministic isOptions_OptionalDeterministic `protobuf_oneof:"optional_deterministic"`
	// The distribution strategy options associated with the dataset.
	DistributeOptions *DistributeOptions `protobuf:"bytes,2,opt,name=distribute_options,json=distributeOptions,proto3" json:"distribute_options,omitempty"`
	// The optimization options associated with the dataset.
	OptimizationOptions *OptimizationOptions `protobuf:"bytes,3,opt,name=optimization_options,json=optimizationOptions,proto3" json:"optimization_options,omitempty"`
	// Whether to introduce 'slack' in the last `prefetch` of the input pipeline,
	// if it exists. This may reduce CPU contention with accelerator host-side
	// activity at the start of a step. The slack frequency is determined by the
	// number of devices attached to this input pipeline.
	//
	// Types that are valid to be assigned to OptionalSlack:
	//	*Options_Slack
	OptionalSlack isOptions_OptionalSlack `protobuf_oneof:"optional_slack"`
	// The threading options associated with the dataset.
	ThreadingOptions *ThreadingOptions `protobuf:"bytes,5,opt,name=threading_options,json=threadingOptions,proto3" json:"threading_options,omitempty"`
	// This option can be used to override the default policy for how to handle
	// external state when serializing a dataset or checkpointing its iterator.
	// There are three settings available - IGNORE: External state is ignored
	// without a warning; WARN: External state is ignored and a warning is logged;
	// FAIL: External state results in an error.
	//
	// Types that are valid to be assigned to OptionalExternalStatePolicy:
	//	*Options_ExternalStatePolicy
	OptionalExternalStatePolicy isOptions_OptionalExternalStatePolicy `protobuf_oneof:"optional_external_state_policy"`
}

func (m *Options) Reset()         { *m = Options{} }
func (m *Options) String() string { return proto.CompactTextString(m) }
func (*Options) ProtoMessage()    {}
func (*Options) Descriptor() ([]byte, []int) {
	return fileDescriptor_f68b0ecf4288c4dc, []int{4}
}
func (m *Options) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Options) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Options.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Options) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Options.Merge(m, src)
}
func (m *Options) XXX_Size() int {
	return m.Size()
}
func (m *Options) XXX_DiscardUnknown() {
	xxx_messageInfo_Options.DiscardUnknown(m)
}

var xxx_messageInfo_Options proto.InternalMessageInfo

type isOptions_OptionalDeterministic interface {
	isOptions_OptionalDeterministic()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isOptions_OptionalSlack interface {
	isOptions_OptionalSlack()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isOptions_OptionalExternalStatePolicy interface {
	isOptions_OptionalExternalStatePolicy()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Options_Deterministic struct {
	Deterministic bool `protobuf:"varint,1,opt,name=deterministic,proto3,oneof" json:"deterministic,omitempty"`
}
type Options_Slack struct {
	Slack bool `protobuf:"varint,4,opt,name=slack,proto3,oneof" json:"slack,omitempty"`
}
type Options_ExternalStatePolicy struct {
	ExternalStatePolicy ExternalStatePolicy `protobuf:"varint,6,opt,name=external_state_policy,json=externalStatePolicy,proto3,enum=tensorflow.data.ExternalStatePolicy,oneof" json:"external_state_policy,omitempty"`
}

func (*Options_Deterministic) isOptions_OptionalDeterministic()             {}
func (*Options_Slack) isOptions_OptionalSlack()                             {}
func (*Options_ExternalStatePolicy) isOptions_OptionalExternalStatePolicy() {}

func (m *Options) GetOptionalDeterministic() isOptions_OptionalDeterministic {
	if m != nil {
		return m.OptionalDeterministic
	}
	return nil
}
func (m *Options) GetOptionalSlack() isOptions_OptionalSlack {
	if m != nil {
		return m.OptionalSlack
	}
	return nil
}
func (m *Options) GetOptionalExternalStatePolicy() isOptions_OptionalExternalStatePolicy {
	if m != nil {
		return m.OptionalExternalStatePolicy
	}
	return nil
}

func (m *Options) GetDeterministic() bool {
	if x, ok := m.GetOptionalDeterministic().(*Options_Deterministic); ok {
		return x.Deterministic
	}
	return false
}

func (m *Options) GetDistributeOptions() *DistributeOptions {
	if m != nil {
		return m.DistributeOptions
	}
	return nil
}

func (m *Options) GetOptimizationOptions() *OptimizationOptions {
	if m != nil {
		return m.OptimizationOptions
	}
	return nil
}

func (m *Options) GetSlack() bool {
	if x, ok := m.GetOptionalSlack().(*Options_Slack); ok {
		return x.Slack
	}
	return false
}

func (m *Options) GetThreadingOptions() *ThreadingOptions {
	if m != nil {
		return m.ThreadingOptions
	}
	return nil
}

func (m *Options) GetExternalStatePolicy() ExternalStatePolicy {
	if x, ok := m.GetOptionalExternalStatePolicy().(*Options_ExternalStatePolicy); ok {
		return x.ExternalStatePolicy
	}
	return ExternalStatePolicy_POLICY_WARN
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Options) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Options_Deterministic)(nil),
		(*Options_Slack)(nil),
		(*Options_ExternalStatePolicy)(nil),
	}
}

func init() {
	proto.RegisterEnum("tensorflow.data.AutoShardPolicy", AutoShardPolicy_name, AutoShardPolicy_value)
	proto.RegisterEnum("tensorflow.data.ExternalStatePolicy", ExternalStatePolicy_name, ExternalStatePolicy_value)
	proto.RegisterType((*DistributeOptions)(nil), "tensorflow.data.DistributeOptions")
	proto.RegisterType((*MapVectorization)(nil), "tensorflow.data.MapVectorization")
	proto.RegisterType((*OptimizationOptions)(nil), "tensorflow.data.OptimizationOptions")
	proto.RegisterType((*ThreadingOptions)(nil), "tensorflow.data.ThreadingOptions")
	proto.RegisterType((*Options)(nil), "tensorflow.data.Options")
}

func init() {
	proto.RegisterFile("tensorflow/core/framework/dataset_options.proto", fileDescriptor_f68b0ecf4288c4dc)
}

var fileDescriptor_f68b0ecf4288c4dc = []byte{
	// 1191 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x96, 0xcd, 0x72, 0xdb, 0xb6,
	0x13, 0xc0, 0x45, 0x3b, 0xfe, 0xc8, 0x2a, 0xb6, 0x28, 0x28, 0x76, 0xe8, 0xbf, 0x13, 0xc5, 0xd6,
	0x3f, 0x4d, 0x33, 0x49, 0x6b, 0x37, 0xce, 0xa5, 0x9d, 0x1e, 0x5a, 0x31, 0x8e, 0x6a, 0xa5, 0xae,
	0x95, 0x22, 0x4e, 0x33, 0xcd, 0x74, 0x06, 0x03, 0x89, 0x90, 0x85, 0x09, 0x49, 0x70, 0x00, 0x30,
	0x5f, 0x4f, 0x91, 0xde, 0xfb, 0x40, 0x3d, 0xe6, 0xd8, 0x63, 0x27, 0x7e, 0x80, 0x3e, 0x42, 0x3b,
	0x04, 0x3f, 0x24, 0x4a, 0x72, 0x74, 0xa2, 0x76, 0x7f, 0xbb, 0x58, 0x2c, 0x76, 0xb1, 0x80, 0x7d,
	0xcd, 0x42, 0x25, 0xe4, 0xd0, 0x17, 0xaf, 0xf7, 0x07, 0x42, 0xb2, 0xfd, 0xa1, 0xa4, 0x01, 0x7b,
	0x2d, 0xe4, 0xcb, 0x7d, 0x8f, 0x6a, 0xaa, 0x98, 0x26, 0x22, 0xd2, 0x5c, 0x84, 0x6a, 0x2f, 0x92,
	0x42, 0x0b, 0x54, 0x1b, 0x1b, 0xec, 0x25, 0x44, 0xeb, 0x0f, 0x0b, 0xea, 0x87, 0x5c, 0x69, 0xc9,
	0xfb, 0xb1, 0x66, 0xbd, 0x14, 0x46, 0xc7, 0x50, 0xa7, 0xb1, 0x16, 0x44, 0x8d, 0xa8, 0xf4, 0x48,
	0x24, 0x7c, 0x3e, 0x78, 0xeb, 0x58, 0x3b, 0xd6, 0x9d, 0xf5, 0x83, 0x9d, 0xbd, 0x29, 0x17, 0x7b,
	0xed, 0x58, 0x8b, 0xa7, 0x09, 0xf8, 0xc4, 0x70, 0xb8, 0x46, 0xcb, 0x02, 0xb4, 0x0b, 0xd5, 0x30,
	0x0e, 0x88, 0xc7, 0x5e, 0xf1, 0x01, 0x53, 0xce, 0xc2, 0x8e, 0x75, 0x67, 0xe9, 0xa8, 0x82, 0x21,
	0x8c, 0x83, 0xc3, 0x54, 0xe6, 0x6e, 0xc2, 0xd5, 0x34, 0x50, 0xea, 0x93, 0x09, 0xb6, 0xf5, 0xbb,
	0x05, 0xf6, 0x4f, 0x34, 0xfa, 0x85, 0x0d, 0xb4, 0x90, 0xfc, 0x1d, 0x4d, 0x10, 0xf4, 0x3f, 0x58,
	0x61, 0x21, 0xed, 0xfb, 0xcc, 0x33, 0x31, 0xad, 0x1e, 0x55, 0x70, 0x2e, 0x40, 0x7b, 0x80, 0x62,
	0xc5, 0xc8, 0x60, 0x24, 0x84, 0x62, 0x64, 0x48, 0x95, 0x66, 0x4a, 0x9b, 0x25, 0x57, 0x8f, 0x2c,
	0x6c, 0xc7, 0x8a, 0x3d, 0x34, 0xaa, 0x4e, 0xaa, 0x71, 0x11, 0xd8, 0xc5, 0xc2, 0x99, 0x0f, 0xf7,
	0x06, 0x6c, 0x17, 0xb2, 0x59, 0x67, 0xad, 0xf7, 0x55, 0x68, 0x24, 0x89, 0x0a, 0xb2, 0x78, 0xf2,
	0xa4, 0x7d, 0x0f, 0xdb, 0x34, 0x8a, 0xfc, 0xb7, 0xc4, 0x63, 0x43, 0x1a, 0xfb, 0x69, 0xea, 0x73,
	0x48, 0x15, 0xa1, 0x6e, 0x19, 0xe8, 0x30, 0x65, 0x26, 0xfd, 0x28, 0x74, 0x1d, 0x56, 0x93, 0xdc,
	0xe9, 0x38, 0x64, 0x45, 0xc8, 0x85, 0x04, 0xdd, 0x03, 0x3b, 0xff, 0x26, 0xfd, 0x78, 0x38, 0x64,
	0x52, 0x39, 0x8b, 0x86, 0x5a, 0x48, 0x73, 0x9e, 0x68, 0xdc, 0x54, 0x81, 0xbe, 0x82, 0x46, 0x01,
	0x0f, 0xa2, 0x98, 0xf4, 0x63, 0xef, 0x8c, 0x69, 0xe7, 0x92, 0xc9, 0xfd, 0x22, 0xae, 0xe7, 0xca,
	0x87, 0x51, 0xec, 0x1a, 0x55, 0xc9, 0x42, 0xd2, 0x20, 0xb7, 0x58, 0x32, 0x16, 0x97, 0xc6, 0x16,
	0x98, 0x06, 0x99, 0xc5, 0x67, 0xb0, 0x36, 0xe4, 0xbe, 0x66, 0x92, 0x0c, 0x63, 0xc5, 0x45, 0xe8,
	0x2c, 0x9b, 0x68, 0x96, 0xf0, 0x95, 0x54, 0xdc, 0x31, 0x52, 0xf4, 0x18, 0x76, 0x33, 0xec, 0x35,
	0xd7, 0x23, 0x22, 0x69, 0xe8, 0x89, 0x80, 0xc4, 0x21, 0x1f, 0x0a, 0x19, 0xe4, 0xa6, 0x2b, 0xc6,
	0x74, 0x19, 0xdf, 0x48, 0xd1, 0xe7, 0x5c, 0x8f, 0xb0, 0x01, 0x9f, 0xa5, 0x5c, 0xe6, 0xeb, 0x00,
	0xae, 0x8e, 0x04, 0x57, 0x7a, 0xca, 0x8b, 0xb3, 0x6a, 0xcc, 0x57, 0x30, 0x32, 0xda, 0x92, 0x25,
	0xba, 0x0f, 0x57, 0x03, 0x1a, 0x11, 0x1a, 0x7a, 0xa4, 0x4f, 0xf5, 0x60, 0x94, 0x2f, 0x79, 0xd9,
	0xd8, 0xac, 0xe2, 0x7a, 0x40, 0xa3, 0x76, 0xe8, 0xb9, 0x89, 0x2e, 0x5b, 0xe6, 0x01, 0x6c, 0xe4,
	0x26, 0xe5, 0x1d, 0x82, 0xb1, 0xb9, 0x8c, 0x51, 0x6a, 0xd3, 0x99, 0xdc, 0xe7, 0x4d, 0x80, 0xc4,
	0x28, 0x23, 0xab, 0x86, 0x04, 0x7c, 0x39, 0xa0, 0x51, 0x06, 0xdc, 0x87, 0x46, 0x02, 0x44, 0x54,
	0x52, 0xdf, 0x67, 0x7e, 0x76, 0xec, 0xce, 0x15, 0x43, 0x56, 0x8d, 0xcf, 0x27, 0x65, 0x1d, 0x3a,
	0x81, 0x24, 0x3a, 0xf2, 0x6a, 0xb2, 0xfe, 0x9d, 0xb5, 0x1d, 0xeb, 0x4e, 0xf5, 0x60, 0x77, 0xa6,
	0x11, 0xa7, 0x1b, 0x05, 0xdb, 0xc1, 0x74, 0xeb, 0xdc, 0x03, 0x3b, 0x14, 0x22, 0x22, 0xcc, 0xe7,
	0x01, 0x0f, 0x53, 0x77, 0xeb, 0x66, 0xfd, 0x2b, 0xb8, 0x96, 0x68, 0x1e, 0x8d, 0x15, 0xe8, 0x73,
	0x58, 0xcf, 0x63, 0x4d, 0x33, 0xe7, 0xd4, 0x0c, 0xba, 0x86, 0xd7, 0x72, 0xb9, 0x49, 0x1a, 0xfa,
	0x0e, 0xb6, 0x25, 0x13, 0xd2, 0x63, 0x92, 0x24, 0x81, 0x10, 0x8f, 0xab, 0x01, 0x95, 0x1e, 0x0f,
	0xcf, 0x88, 0x88, 0x94, 0x63, 0x1b, 0xab, 0x75, 0xec, 0x64, 0xd0, 0x21, 0xd5, 0xf4, 0xb0, 0x40,
	0x7a, 0x91, 0x42, 0xdf, 0xc2, 0x96, 0x1a, 0xc5, 0xc3, 0xa1, 0xcf, 0x4c, 0xce, 0x25, 0x8b, 0x18,
	0xd5, 0x79, 0x26, 0xeb, 0xc6, 0xbc, 0x86, 0x37, 0x33, 0xa4, 0x1d, 0x7a, 0xd8, 0x00, 0x69, 0x5a,
	0xdd, 0xdb, 0x70, 0xab, 0x68, 0xd7, 0x4f, 0x34, 0xa0, 0xdb, 0x80, 0xfa, 0x98, 0xcb, 0xdb, 0x65,
	0x1b, 0xb6, 0x66, 0x84, 0x79, 0x77, 0xb9, 0x4d, 0xb8, 0x3e, 0xab, 0x1c, 0x77, 0xd3, 0x7c, 0xfd,
	0xb8, 0x77, 0x5c, 0x07, 0x36, 0x0b, 0x7d, 0xa9, 0x8e, 0xdc, 0x2f, 0xe0, 0xee, 0xb4, 0xe6, 0xe2,
	0xe6, 0x70, 0x6f, 0xc2, 0x8d, 0x82, 0x9e, 0x57, 0xfe, 0x25, 0x60, 0x5e, 0xad, 0xbb, 0x3b, 0xd0,
	0x9c, 0x01, 0xca, 0x11, 0x6d, 0x40, 0xa3, 0x44, 0x64, 0xe2, 0xc9, 0x2d, 0xce, 0x29, 0xde, 0x52,
	0xfe, 0xa6, 0x2b, 0xcb, 0xdd, 0x82, 0x6b, 0x85, 0xb2, 0x5c, 0x49, 0xa5, 0x43, 0xfb, 0x44, 0xed,
	0xb8, 0xb7, 0xa0, 0x55, 0x70, 0x17, 0x96, 0x48, 0xeb, 0x83, 0x05, 0xf6, 0xe9, 0x48, 0x32, 0x9a,
	0x16, 0x54, 0x7a, 0x9b, 0x7e, 0x03, 0x4e, 0x40, 0xdf, 0x10, 0x1e, 0x6a, 0x49, 0x89, 0x98, 0x08,
	0x5d, 0x05, 0xe6, 0x32, 0x4e, 0x66, 0xd0, 0x46, 0x40, 0xdf, 0x74, 0x13, 0xa0, 0x37, 0x6e, 0x3d,
	0x15, 0xa0, 0xaf, 0xe1, 0x5a, 0x24, 0xf9, 0x2b, 0xaa, 0x19, 0xd1, 0xc6, 0x6d, 0x24, 0x84, 0x4f,
	0x14, 0x7f, 0xc7, 0xb2, 0xe9, 0x65, 0xe1, 0x8d, 0x0c, 0x38, 0x2d, 0xf4, 0x4f, 0xf9, 0x3b, 0xe6,
	0xfe, 0x1f, 0x76, 0x27, 0xf2, 0x35, 0x7f, 0x75, 0xb7, 0x05, 0x3b, 0xe3, 0xbc, 0xcc, 0x5f, 0xa7,
	0xf5, 0xcf, 0x22, 0xac, 0xe4, 0x3b, 0xb9, 0x0d, 0x6b, 0x1e, 0xd3, 0x4c, 0x06, 0x3c, 0xe4, 0x4a,
	0xf3, 0x41, 0x31, 0x4b, 0xca, 0x62, 0xf4, 0x33, 0x20, 0xaf, 0x98, 0xe5, 0xf9, 0xe4, 0x37, 0x11,
	0x57, 0x0f, 0x5a, 0x33, 0xd7, 0xc5, 0xcc, 0xd8, 0xc7, 0x75, 0x6f, 0xe6, 0x25, 0xf0, 0x3c, 0x1d,
	0xcc, 0x79, 0x17, 0x15, 0x4e, 0x17, 0x8d, 0xd3, 0x5b, 0x33, 0x4e, 0xe7, 0x0c, 0x46, 0xdc, 0x10,
	0x73, 0xa6, 0xe5, 0x26, 0x2c, 0x29, 0x9f, 0x0e, 0x5e, 0x9a, 0x91, 0x94, 0x0c, 0xba, 0xf4, 0x6f,
	0x72, 0xe3, 0xe9, 0xfc, 0x24, 0x8b, 0xd5, 0x96, 0x2e, 0xb8, 0xf1, 0xa6, 0xcf, 0x1c, 0xdb, 0x7a,
	0xba, 0x0a, 0x5e, 0xc0, 0x06, 0x7b, 0xa3, 0x99, 0x34, 0x05, 0xa4, 0x93, 0x4c, 0x67, 0xcf, 0x99,
	0x65, 0xf3, 0x9c, 0x99, 0xdd, 0xc1, 0xa3, 0x8c, 0x7e, 0x9a, 0xc0, 0xe9, 0x0b, 0xe6, 0x68, 0x01,
	0x37, 0xd8, 0xac, 0xb8, 0xd4, 0xdf, 0xa5, 0x93, 0x70, 0x6d, 0x58, 0x1f, 0x97, 0x6d, 0xb2, 0xaf,
	0x52, 0x07, 0xce, 0x0d, 0xe8, 0xee, 0x8f, 0x50, 0x9b, 0x7a, 0x4a, 0xa1, 0x55, 0xb8, 0xd4, 0x7e,
	0x76, 0xda, 0xb3, 0x2b, 0xc9, 0x57, 0xa7, 0x7b, 0xfc, 0xc8, 0xb6, 0x92, 0xaf, 0xc3, 0xf6, 0x69,
	0xdb, 0x5e, 0x48, 0xbe, 0x8e, 0xba, 0x27, 0xa7, 0xf6, 0x22, 0xb2, 0x61, 0xb1, 0xd7, 0xe9, 0xd8,
	0xff, 0xe6, 0x3f, 0xeb, 0xee, 0x63, 0x68, 0xcc, 0xd9, 0x08, 0xaa, 0x41, 0xf5, 0x49, 0xef, 0xb8,
	0xfb, 0xf0, 0x57, 0xf2, 0xbc, 0x8d, 0x4f, 0xec, 0x0a, 0xaa, 0xc3, 0x5a, 0x26, 0xe8, 0xfe, 0x70,
	0xd2, 0xc3, 0xc9, 0x02, 0x63, 0xa6, 0xd3, 0xee, 0x1e, 0xdb, 0x0b, 0xee, 0x6f, 0x7f, 0x7e, 0x6c,
	0x5a, 0x1f, 0x3e, 0x36, 0xad, 0xbf, 0x3f, 0x36, 0xad, 0xf7, 0xe7, 0xcd, 0xca, 0x87, 0xf3, 0x66,
	0xe5, 0xaf, 0xf3, 0x66, 0xe5, 0x85, 0x7b, 0xc6, 0xf5, 0x28, 0xee, 0xef, 0x0d, 0x44, 0xb0, 0xdf,
	0x8e, 0x22, 0x9f, 0x0f, 0x39, 0x93, 0xfb, 0x67, 0xe2, 0xcb, 0x89, 0x77, 0xa9, 0x7e, 0x1b, 0x31,
	0x75, 0xf1, 0x43, 0xb5, 0xbf, 0x6c, 0x5e, 0xa6, 0x0f, 0xfe, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x37,
	0xc1, 0x0b, 0x81, 0xcc, 0x0a, 0x00, 0x00,
}

func (m *DistributeOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DistributeOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DistributeOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OptionalNumDevices != nil {
		{
			size := m.OptionalNumDevices.Size()
			i -= size
			if _, err := m.OptionalNumDevices.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.AutoShardPolicy != 0 {
		i = encodeVarintDatasetOptions(dAtA, i, uint64(m.AutoShardPolicy))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DistributeOptions_NumDevices) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DistributeOptions_NumDevices) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintDatasetOptions(dAtA, i, uint64(m.NumDevices))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *MapVectorization) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MapVectorization) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MapVectorization) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OptionalUseChooseFastest != nil {
		{
			size := m.OptionalUseChooseFastest.Size()
			i -= size
			if _, err := m.OptionalUseChooseFastest.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.OptionalEnabled != nil {
		{
			size := m.OptionalEnabled.Size()
			i -= size
			if _, err := m.OptionalEnabled.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *MapVectorization_Enabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MapVectorization_Enabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Enabled {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *MapVectorization_UseChooseFastest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MapVectorization_UseChooseFastest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.UseChooseFastest {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *OptimizationOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OptimizationOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptimizationOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OptionalShuffleAndRepeatFusion != nil {
		{
			size := m.OptionalShuffleAndRepeatFusion.Size()
			i -= size
			if _, err := m.OptionalShuffleAndRepeatFusion.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.OptionalReorderDataDiscardingOps != nil {
		{
			size := m.OptionalReorderDataDiscardingOps.Size()
			i -= size
			if _, err := m.OptionalReorderDataDiscardingOps.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.OptionalParallelBatch != nil {
		{
			size := m.OptionalParallelBatch.Size()
			i -= size
			if _, err := m.OptionalParallelBatch.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.OptionalNoopElimination != nil {
		{
			size := m.OptionalNoopElimination.Size()
			i -= size
			if _, err := m.OptionalNoopElimination.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.MapVectorization != nil {
		{
			size, err := m.MapVectorization.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDatasetOptions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.OptionalMapParallelization != nil {
		{
			size := m.OptionalMapParallelization.Size()
			i -= size
			if _, err := m.OptionalMapParallelization.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.OptionalMapFusion != nil {
		{
			size := m.OptionalMapFusion.Size()
			i -= size
			if _, err := m.OptionalMapFusion.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.OptionalMapAndFilterFusion != nil {
		{
			size := m.OptionalMapAndFilterFusion.Size()
			i -= size
			if _, err := m.OptionalMapAndFilterFusion.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.OptionalMapAndBatchFusion != nil {
		{
			size := m.OptionalMapAndBatchFusion.Size()
			i -= size
			if _, err := m.OptionalMapAndBatchFusion.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.OptionalHoistRandomUniform != nil {
		{
			size := m.OptionalHoistRandomUniform.Size()
			i -= size
			if _, err := m.OptionalHoistRandomUniform.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.OptionalFilterWithRandomUniformFusion != nil {
		{
			size := m.OptionalFilterWithRandomUniformFusion.Size()
			i -= size
			if _, err := m.OptionalFilterWithRandomUniformFusion.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.OptionalFilterFusion != nil {
		{
			size := m.OptionalFilterFusion.Size()
			i -= size
			if _, err := m.OptionalFilterFusion.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.OptionalAutotuneRamBudget != nil {
		{
			size := m.OptionalAutotuneRamBudget.Size()
			i -= size
			if _, err := m.OptionalAutotuneRamBudget.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.OptionalAutotuneCpuBudget != nil {
		{
			size := m.OptionalAutotuneCpuBudget.Size()
			i -= size
			if _, err := m.OptionalAutotuneCpuBudget.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.OptionalAutotuneBuffers != nil {
		{
			size := m.OptionalAutotuneBuffers.Size()
			i -= size
			if _, err := m.OptionalAutotuneBuffers.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.OptionalAutotune != nil {
		{
			size := m.OptionalAutotune.Size()
			i -= size
			if _, err := m.OptionalAutotune.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.OptionalApplyDefaultOptimizations != nil {
		{
			size := m.OptionalApplyDefaultOptimizations.Size()
			i -= size
			if _, err := m.OptionalApplyDefaultOptimizations.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *OptimizationOptions_ApplyDefaultOptimizations) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptimizationOptions_ApplyDefaultOptimizations) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.ApplyDefaultOptimizations {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *OptimizationOptions_Autotune) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptimizationOptions_Autotune) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Autotune {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *OptimizationOptions_AutotuneBuffers) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptimizationOptions_AutotuneBuffers) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.AutotuneBuffers {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *OptimizationOptions_AutotuneCpuBudget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptimizationOptions_AutotuneCpuBudget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintDatasetOptions(dAtA, i, uint64(m.AutotuneCpuBudget))
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func (m *OptimizationOptions_AutotuneRamBudget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptimizationOptions_AutotuneRamBudget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintDatasetOptions(dAtA, i, uint64(m.AutotuneRamBudget))
	i--
	dAtA[i] = 0x28
	return len(dAtA) - i, nil
}
func (m *OptimizationOptions_FilterFusion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptimizationOptions_FilterFusion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.FilterFusion {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x30
	return len(dAtA) - i, nil
}
func (m *OptimizationOptions_FilterWithRandomUniformFusion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptimizationOptions_FilterWithRandomUniformFusion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.FilterWithRandomUniformFusion {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x38
	return len(dAtA) - i, nil
}
func (m *OptimizationOptions_HoistRandomUniform) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptimizationOptions_HoistRandomUniform) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.HoistRandomUniform {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x40
	return len(dAtA) - i, nil
}
func (m *OptimizationOptions_MapAndBatchFusion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptimizationOptions_MapAndBatchFusion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.MapAndBatchFusion {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x48
	return len(dAtA) - i, nil
}
func (m *OptimizationOptions_MapAndFilterFusion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptimizationOptions_MapAndFilterFusion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.MapAndFilterFusion {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x50
	return len(dAtA) - i, nil
}
func (m *OptimizationOptions_MapFusion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptimizationOptions_MapFusion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.MapFusion {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x58
	return len(dAtA) - i, nil
}
func (m *OptimizationOptions_MapParallelization) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptimizationOptions_MapParallelization) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.MapParallelization {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x60
	return len(dAtA) - i, nil
}
func (m *OptimizationOptions_NoopElimination) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptimizationOptions_NoopElimination) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.NoopElimination {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x70
	return len(dAtA) - i, nil
}
func (m *OptimizationOptions_ParallelBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptimizationOptions_ParallelBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.ParallelBatch {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x78
	return len(dAtA) - i, nil
}
func (m *OptimizationOptions_ReorderDataDiscardingOps) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptimizationOptions_ReorderDataDiscardingOps) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.ReorderDataDiscardingOps {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x80
	return len(dAtA) - i, nil
}
func (m *OptimizationOptions_ShuffleAndRepeatFusion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptimizationOptions_ShuffleAndRepeatFusion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.ShuffleAndRepeatFusion {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x88
	return len(dAtA) - i, nil
}
func (m *ThreadingOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThreadingOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThreadingOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OptionalPrivateThreadpoolSize != nil {
		{
			size := m.OptionalPrivateThreadpoolSize.Size()
			i -= size
			if _, err := m.OptionalPrivateThreadpoolSize.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.OptionalMaxIntraOpParallelism != nil {
		{
			size := m.OptionalMaxIntraOpParallelism.Size()
			i -= size
			if _, err := m.OptionalMaxIntraOpParallelism.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ThreadingOptions_MaxIntraOpParallelism) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThreadingOptions_MaxIntraOpParallelism) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintDatasetOptions(dAtA, i, uint64(m.MaxIntraOpParallelism))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *ThreadingOptions_PrivateThreadpoolSize) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThreadingOptions_PrivateThreadpoolSize) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintDatasetOptions(dAtA, i, uint64(m.PrivateThreadpoolSize))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *Options) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Options) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Options) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OptionalExternalStatePolicy != nil {
		{
			size := m.OptionalExternalStatePolicy.Size()
			i -= size
			if _, err := m.OptionalExternalStatePolicy.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ThreadingOptions != nil {
		{
			size, err := m.ThreadingOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDatasetOptions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.OptionalSlack != nil {
		{
			size := m.OptionalSlack.Size()
			i -= size
			if _, err := m.OptionalSlack.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.OptimizationOptions != nil {
		{
			size, err := m.OptimizationOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDatasetOptions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.DistributeOptions != nil {
		{
			size, err := m.DistributeOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDatasetOptions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.OptionalDeterministic != nil {
		{
			size := m.OptionalDeterministic.Size()
			i -= size
			if _, err := m.OptionalDeterministic.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Options_Deterministic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Options_Deterministic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Deterministic {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *Options_Slack) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Options_Slack) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Slack {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func (m *Options_ExternalStatePolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Options_ExternalStatePolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintDatasetOptions(dAtA, i, uint64(m.ExternalStatePolicy))
	i--
	dAtA[i] = 0x30
	return len(dAtA) - i, nil
}
func encodeVarintDatasetOptions(dAtA []byte, offset int, v uint64) int {
	offset -= sovDatasetOptions(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DistributeOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AutoShardPolicy != 0 {
		n += 1 + sovDatasetOptions(uint64(m.AutoShardPolicy))
	}
	if m.OptionalNumDevices != nil {
		n += m.OptionalNumDevices.Size()
	}
	return n
}

func (m *DistributeOptions_NumDevices) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovDatasetOptions(uint64(m.NumDevices))
	return n
}
func (m *MapVectorization) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OptionalEnabled != nil {
		n += m.OptionalEnabled.Size()
	}
	if m.OptionalUseChooseFastest != nil {
		n += m.OptionalUseChooseFastest.Size()
	}
	return n
}

func (m *MapVectorization_Enabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *MapVectorization_UseChooseFastest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *OptimizationOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OptionalApplyDefaultOptimizations != nil {
		n += m.OptionalApplyDefaultOptimizations.Size()
	}
	if m.OptionalAutotune != nil {
		n += m.OptionalAutotune.Size()
	}
	if m.OptionalAutotuneBuffers != nil {
		n += m.OptionalAutotuneBuffers.Size()
	}
	if m.OptionalAutotuneCpuBudget != nil {
		n += m.OptionalAutotuneCpuBudget.Size()
	}
	if m.OptionalAutotuneRamBudget != nil {
		n += m.OptionalAutotuneRamBudget.Size()
	}
	if m.OptionalFilterFusion != nil {
		n += m.OptionalFilterFusion.Size()
	}
	if m.OptionalFilterWithRandomUniformFusion != nil {
		n += m.OptionalFilterWithRandomUniformFusion.Size()
	}
	if m.OptionalHoistRandomUniform != nil {
		n += m.OptionalHoistRandomUniform.Size()
	}
	if m.OptionalMapAndBatchFusion != nil {
		n += m.OptionalMapAndBatchFusion.Size()
	}
	if m.OptionalMapAndFilterFusion != nil {
		n += m.OptionalMapAndFilterFusion.Size()
	}
	if m.OptionalMapFusion != nil {
		n += m.OptionalMapFusion.Size()
	}
	if m.OptionalMapParallelization != nil {
		n += m.OptionalMapParallelization.Size()
	}
	if m.MapVectorization != nil {
		l = m.MapVectorization.Size()
		n += 1 + l + sovDatasetOptions(uint64(l))
	}
	if m.OptionalNoopElimination != nil {
		n += m.OptionalNoopElimination.Size()
	}
	if m.OptionalParallelBatch != nil {
		n += m.OptionalParallelBatch.Size()
	}
	if m.OptionalReorderDataDiscardingOps != nil {
		n += m.OptionalReorderDataDiscardingOps.Size()
	}
	if m.OptionalShuffleAndRepeatFusion != nil {
		n += m.OptionalShuffleAndRepeatFusion.Size()
	}
	return n
}

func (m *OptimizationOptions_ApplyDefaultOptimizations) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *OptimizationOptions_Autotune) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *OptimizationOptions_AutotuneBuffers) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *OptimizationOptions_AutotuneCpuBudget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovDatasetOptions(uint64(m.AutotuneCpuBudget))
	return n
}
func (m *OptimizationOptions_AutotuneRamBudget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovDatasetOptions(uint64(m.AutotuneRamBudget))
	return n
}
func (m *OptimizationOptions_FilterFusion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *OptimizationOptions_FilterWithRandomUniformFusion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *OptimizationOptions_HoistRandomUniform) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *OptimizationOptions_MapAndBatchFusion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *OptimizationOptions_MapAndFilterFusion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *OptimizationOptions_MapFusion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *OptimizationOptions_MapParallelization) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *OptimizationOptions_NoopElimination) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *OptimizationOptions_ParallelBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *OptimizationOptions_ReorderDataDiscardingOps) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 3
	return n
}
func (m *OptimizationOptions_ShuffleAndRepeatFusion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 3
	return n
}
func (m *ThreadingOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OptionalMaxIntraOpParallelism != nil {
		n += m.OptionalMaxIntraOpParallelism.Size()
	}
	if m.OptionalPrivateThreadpoolSize != nil {
		n += m.OptionalPrivateThreadpoolSize.Size()
	}
	return n
}

func (m *ThreadingOptions_MaxIntraOpParallelism) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovDatasetOptions(uint64(m.MaxIntraOpParallelism))
	return n
}
func (m *ThreadingOptions_PrivateThreadpoolSize) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovDatasetOptions(uint64(m.PrivateThreadpoolSize))
	return n
}
func (m *Options) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OptionalDeterministic != nil {
		n += m.OptionalDeterministic.Size()
	}
	if m.DistributeOptions != nil {
		l = m.DistributeOptions.Size()
		n += 1 + l + sovDatasetOptions(uint64(l))
	}
	if m.OptimizationOptions != nil {
		l = m.OptimizationOptions.Size()
		n += 1 + l + sovDatasetOptions(uint64(l))
	}
	if m.OptionalSlack != nil {
		n += m.OptionalSlack.Size()
	}
	if m.ThreadingOptions != nil {
		l = m.ThreadingOptions.Size()
		n += 1 + l + sovDatasetOptions(uint64(l))
	}
	if m.OptionalExternalStatePolicy != nil {
		n += m.OptionalExternalStatePolicy.Size()
	}
	return n
}

func (m *Options_Deterministic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *Options_Slack) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *Options_ExternalStatePolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovDatasetOptions(uint64(m.ExternalStatePolicy))
	return n
}

func sovDatasetOptions(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDatasetOptions(x uint64) (n int) {
	return sovDatasetOptions(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DistributeOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDatasetOptions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DistributeOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DistributeOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoShardPolicy", wireType)
			}
			m.AutoShardPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDatasetOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoShardPolicy |= AutoShardPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumDevices", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDatasetOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptionalNumDevices = &DistributeOptions_NumDevices{v}
		default:
			iNdEx = preIndex
			skippy, err := skipDatasetOptions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDatasetOptions
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDatasetOptions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MapVectorization) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDatasetOptions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MapVectorization: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MapVectorization: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDatasetOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OptionalEnabled = &MapVectorization_Enabled{b}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseChooseFastest", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDatasetOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OptionalUseChooseFastest = &MapVectorization_UseChooseFastest{b}
		default:
			iNdEx = preIndex
			skippy, err := skipDatasetOptions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDatasetOptions
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDatasetOptions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OptimizationOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDatasetOptions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OptimizationOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OptimizationOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyDefaultOptimizations", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDatasetOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OptionalApplyDefaultOptimizations = &OptimizationOptions_ApplyDefaultOptimizations{b}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Autotune", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDatasetOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OptionalAutotune = &OptimizationOptions_Autotune{b}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutotuneBuffers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDatasetOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OptionalAutotuneBuffers = &OptimizationOptions_AutotuneBuffers{b}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutotuneCpuBudget", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDatasetOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptionalAutotuneCpuBudget = &OptimizationOptions_AutotuneCpuBudget{v}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutotuneRamBudget", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDatasetOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptionalAutotuneRamBudget = &OptimizationOptions_AutotuneRamBudget{v}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterFusion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDatasetOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OptionalFilterFusion = &OptimizationOptions_FilterFusion{b}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterWithRandomUniformFusion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDatasetOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OptionalFilterWithRandomUniformFusion = &OptimizationOptions_FilterWithRandomUniformFusion{b}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoistRandomUniform", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDatasetOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OptionalHoistRandomUniform = &OptimizationOptions_HoistRandomUniform{b}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapAndBatchFusion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDatasetOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OptionalMapAndBatchFusion = &OptimizationOptions_MapAndBatchFusion{b}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapAndFilterFusion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDatasetOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OptionalMapAndFilterFusion = &OptimizationOptions_MapAndFilterFusion{b}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapFusion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDatasetOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OptionalMapFusion = &OptimizationOptions_MapFusion{b}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapParallelization", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDatasetOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OptionalMapParallelization = &OptimizationOptions_MapParallelization{b}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapVectorization", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDatasetOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDatasetOptions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDatasetOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapVectorization == nil {
				m.MapVectorization = &MapVectorization{}
			}
			if err := m.MapVectorization.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoopElimination", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDatasetOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OptionalNoopElimination = &OptimizationOptions_NoopElimination{b}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParallelBatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDatasetOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OptionalParallelBatch = &OptimizationOptions_ParallelBatch{b}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReorderDataDiscardingOps", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDatasetOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OptionalReorderDataDiscardingOps = &OptimizationOptions_ReorderDataDiscardingOps{b}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleAndRepeatFusion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDatasetOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OptionalShuffleAndRepeatFusion = &OptimizationOptions_ShuffleAndRepeatFusion{b}
		default:
			iNdEx = preIndex
			skippy, err := skipDatasetOptions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDatasetOptions
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDatasetOptions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThreadingOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDatasetOptions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThreadingOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThreadingOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxIntraOpParallelism", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDatasetOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptionalMaxIntraOpParallelism = &ThreadingOptions_MaxIntraOpParallelism{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateThreadpoolSize", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDatasetOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptionalPrivateThreadpoolSize = &ThreadingOptions_PrivateThreadpoolSize{v}
		default:
			iNdEx = preIndex
			skippy, err := skipDatasetOptions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDatasetOptions
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDatasetOptions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Options) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDatasetOptions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Options: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Options: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deterministic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDatasetOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OptionalDeterministic = &Options_Deterministic{b}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistributeOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDatasetOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDatasetOptions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDatasetOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DistributeOptions == nil {
				m.DistributeOptions = &DistributeOptions{}
			}
			if err := m.DistributeOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizationOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDatasetOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDatasetOptions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDatasetOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptimizationOptions == nil {
				m.OptimizationOptions = &OptimizationOptions{}
			}
			if err := m.OptimizationOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slack", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDatasetOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OptionalSlack = &Options_Slack{b}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThreadingOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDatasetOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDatasetOptions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDatasetOptions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ThreadingOptions == nil {
				m.ThreadingOptions = &ThreadingOptions{}
			}
			if err := m.ThreadingOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalStatePolicy", wireType)
			}
			var v ExternalStatePolicy
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDatasetOptions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= ExternalStatePolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptionalExternalStatePolicy = &Options_ExternalStatePolicy{v}
		default:
			iNdEx = preIndex
			skippy, err := skipDatasetOptions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDatasetOptions
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDatasetOptions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDatasetOptions(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDatasetOptions
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDatasetOptions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDatasetOptions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDatasetOptions
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDatasetOptions
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDatasetOptions
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDatasetOptions        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDatasetOptions          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDatasetOptions = fmt.Errorf("proto: unexpected end of group")
)
