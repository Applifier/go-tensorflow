// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tensorflow/core/framework/graph_transfer_info.proto

package framework

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type GraphTransferInfo_Destination int32

const (
	GraphTransferInfo_NOP     GraphTransferInfo_Destination = 0
	GraphTransferInfo_HEXAGON GraphTransferInfo_Destination = 1
)

var GraphTransferInfo_Destination_name = map[int32]string{
	0: "NOP",
	1: "HEXAGON",
}

var GraphTransferInfo_Destination_value = map[string]int32{
	"NOP":     0,
	"HEXAGON": 1,
}

func (x GraphTransferInfo_Destination) String() string {
	return proto.EnumName(GraphTransferInfo_Destination_name, int32(x))
}

func (GraphTransferInfo_Destination) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c3a1e773f26c9475, []int{7, 0}
}

type GraphTransferNodeInput struct {
	NodeId     int32 `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	OutputPort int32 `protobuf:"varint,2,opt,name=output_port,json=outputPort,proto3" json:"output_port,omitempty"`
}

func (m *GraphTransferNodeInput) Reset()         { *m = GraphTransferNodeInput{} }
func (m *GraphTransferNodeInput) String() string { return proto.CompactTextString(m) }
func (*GraphTransferNodeInput) ProtoMessage()    {}
func (*GraphTransferNodeInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a1e773f26c9475, []int{0}
}
func (m *GraphTransferNodeInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GraphTransferNodeInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GraphTransferNodeInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GraphTransferNodeInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GraphTransferNodeInput.Merge(m, src)
}
func (m *GraphTransferNodeInput) XXX_Size() int {
	return m.Size()
}
func (m *GraphTransferNodeInput) XXX_DiscardUnknown() {
	xxx_messageInfo_GraphTransferNodeInput.DiscardUnknown(m)
}

var xxx_messageInfo_GraphTransferNodeInput proto.InternalMessageInfo

func (m *GraphTransferNodeInput) GetNodeId() int32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *GraphTransferNodeInput) GetOutputPort() int32 {
	if m != nil {
		return m.OutputPort
	}
	return 0
}

type GraphTransferNodeInfo struct {
	Name        string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	NodeId      int32  `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	TypeName    string `protobuf:"bytes,3,opt,name=type_name,json=typeName,proto3" json:"type_name,omitempty"`
	SocOpId     int32  `protobuf:"varint,4,opt,name=soc_op_id,json=socOpId,proto3" json:"soc_op_id,omitempty"`
	PaddingId   int32  `protobuf:"varint,5,opt,name=padding_id,json=paddingId,proto3" json:"padding_id,omitempty"`
	InputCount  int32  `protobuf:"varint,6,opt,name=input_count,json=inputCount,proto3" json:"input_count,omitempty"`
	OutputCount int32  `protobuf:"varint,7,opt,name=output_count,json=outputCount,proto3" json:"output_count,omitempty"`
}

func (m *GraphTransferNodeInfo) Reset()         { *m = GraphTransferNodeInfo{} }
func (m *GraphTransferNodeInfo) String() string { return proto.CompactTextString(m) }
func (*GraphTransferNodeInfo) ProtoMessage()    {}
func (*GraphTransferNodeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a1e773f26c9475, []int{1}
}
func (m *GraphTransferNodeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GraphTransferNodeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GraphTransferNodeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GraphTransferNodeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GraphTransferNodeInfo.Merge(m, src)
}
func (m *GraphTransferNodeInfo) XXX_Size() int {
	return m.Size()
}
func (m *GraphTransferNodeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GraphTransferNodeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GraphTransferNodeInfo proto.InternalMessageInfo

func (m *GraphTransferNodeInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GraphTransferNodeInfo) GetNodeId() int32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *GraphTransferNodeInfo) GetTypeName() string {
	if m != nil {
		return m.TypeName
	}
	return ""
}

func (m *GraphTransferNodeInfo) GetSocOpId() int32 {
	if m != nil {
		return m.SocOpId
	}
	return 0
}

func (m *GraphTransferNodeInfo) GetPaddingId() int32 {
	if m != nil {
		return m.PaddingId
	}
	return 0
}

func (m *GraphTransferNodeInfo) GetInputCount() int32 {
	if m != nil {
		return m.InputCount
	}
	return 0
}

func (m *GraphTransferNodeInfo) GetOutputCount() int32 {
	if m != nil {
		return m.OutputCount
	}
	return 0
}

type GraphTransferConstNodeInfo struct {
	Name   string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	NodeId int32    `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Shape  []int64  `protobuf:"varint,3,rep,packed,name=shape,proto3" json:"shape,omitempty"`
	Data   []byte   `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
	Dtype  DataType `protobuf:"varint,5,opt,name=dtype,proto3,enum=tensorflow.DataType" json:"dtype,omitempty"`
}

func (m *GraphTransferConstNodeInfo) Reset()         { *m = GraphTransferConstNodeInfo{} }
func (m *GraphTransferConstNodeInfo) String() string { return proto.CompactTextString(m) }
func (*GraphTransferConstNodeInfo) ProtoMessage()    {}
func (*GraphTransferConstNodeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a1e773f26c9475, []int{2}
}
func (m *GraphTransferConstNodeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GraphTransferConstNodeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GraphTransferConstNodeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GraphTransferConstNodeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GraphTransferConstNodeInfo.Merge(m, src)
}
func (m *GraphTransferConstNodeInfo) XXX_Size() int {
	return m.Size()
}
func (m *GraphTransferConstNodeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GraphTransferConstNodeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GraphTransferConstNodeInfo proto.InternalMessageInfo

func (m *GraphTransferConstNodeInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GraphTransferConstNodeInfo) GetNodeId() int32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *GraphTransferConstNodeInfo) GetShape() []int64 {
	if m != nil {
		return m.Shape
	}
	return nil
}

func (m *GraphTransferConstNodeInfo) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *GraphTransferConstNodeInfo) GetDtype() DataType {
	if m != nil {
		return m.Dtype
	}
	return DataType_DT_INVALID
}

type GraphTransferNodeInputInfo struct {
	NodeId    int32                     `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	NodeInput []*GraphTransferNodeInput `protobuf:"bytes,2,rep,name=node_input,json=nodeInput,proto3" json:"node_input,omitempty"`
}

func (m *GraphTransferNodeInputInfo) Reset()         { *m = GraphTransferNodeInputInfo{} }
func (m *GraphTransferNodeInputInfo) String() string { return proto.CompactTextString(m) }
func (*GraphTransferNodeInputInfo) ProtoMessage()    {}
func (*GraphTransferNodeInputInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a1e773f26c9475, []int{3}
}
func (m *GraphTransferNodeInputInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GraphTransferNodeInputInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GraphTransferNodeInputInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GraphTransferNodeInputInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GraphTransferNodeInputInfo.Merge(m, src)
}
func (m *GraphTransferNodeInputInfo) XXX_Size() int {
	return m.Size()
}
func (m *GraphTransferNodeInputInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GraphTransferNodeInputInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GraphTransferNodeInputInfo proto.InternalMessageInfo

func (m *GraphTransferNodeInputInfo) GetNodeId() int32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *GraphTransferNodeInputInfo) GetNodeInput() []*GraphTransferNodeInput {
	if m != nil {
		return m.NodeInput
	}
	return nil
}

type GraphTransferNodeOutputInfo struct {
	NodeId      int32   `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	MaxByteSize []int32 `protobuf:"varint,2,rep,packed,name=max_byte_size,json=maxByteSize,proto3" json:"max_byte_size,omitempty"`
}

func (m *GraphTransferNodeOutputInfo) Reset()         { *m = GraphTransferNodeOutputInfo{} }
func (m *GraphTransferNodeOutputInfo) String() string { return proto.CompactTextString(m) }
func (*GraphTransferNodeOutputInfo) ProtoMessage()    {}
func (*GraphTransferNodeOutputInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a1e773f26c9475, []int{4}
}
func (m *GraphTransferNodeOutputInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GraphTransferNodeOutputInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GraphTransferNodeOutputInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GraphTransferNodeOutputInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GraphTransferNodeOutputInfo.Merge(m, src)
}
func (m *GraphTransferNodeOutputInfo) XXX_Size() int {
	return m.Size()
}
func (m *GraphTransferNodeOutputInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GraphTransferNodeOutputInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GraphTransferNodeOutputInfo proto.InternalMessageInfo

func (m *GraphTransferNodeOutputInfo) GetNodeId() int32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *GraphTransferNodeOutputInfo) GetMaxByteSize() []int32 {
	if m != nil {
		return m.MaxByteSize
	}
	return nil
}

type GraphTransferGraphInputNodeInfo struct {
	Name  string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Shape []int64  `protobuf:"varint,2,rep,packed,name=shape,proto3" json:"shape,omitempty"`
	Dtype DataType `protobuf:"varint,3,opt,name=dtype,proto3,enum=tensorflow.DataType" json:"dtype,omitempty"`
}

func (m *GraphTransferGraphInputNodeInfo) Reset()         { *m = GraphTransferGraphInputNodeInfo{} }
func (m *GraphTransferGraphInputNodeInfo) String() string { return proto.CompactTextString(m) }
func (*GraphTransferGraphInputNodeInfo) ProtoMessage()    {}
func (*GraphTransferGraphInputNodeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a1e773f26c9475, []int{5}
}
func (m *GraphTransferGraphInputNodeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GraphTransferGraphInputNodeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GraphTransferGraphInputNodeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GraphTransferGraphInputNodeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GraphTransferGraphInputNodeInfo.Merge(m, src)
}
func (m *GraphTransferGraphInputNodeInfo) XXX_Size() int {
	return m.Size()
}
func (m *GraphTransferGraphInputNodeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GraphTransferGraphInputNodeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GraphTransferGraphInputNodeInfo proto.InternalMessageInfo

func (m *GraphTransferGraphInputNodeInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GraphTransferGraphInputNodeInfo) GetShape() []int64 {
	if m != nil {
		return m.Shape
	}
	return nil
}

func (m *GraphTransferGraphInputNodeInfo) GetDtype() DataType {
	if m != nil {
		return m.Dtype
	}
	return DataType_DT_INVALID
}

type GraphTransferGraphOutputNodeInfo struct {
	Name  string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Shape []int64  `protobuf:"varint,2,rep,packed,name=shape,proto3" json:"shape,omitempty"`
	Dtype DataType `protobuf:"varint,3,opt,name=dtype,proto3,enum=tensorflow.DataType" json:"dtype,omitempty"`
}

func (m *GraphTransferGraphOutputNodeInfo) Reset()         { *m = GraphTransferGraphOutputNodeInfo{} }
func (m *GraphTransferGraphOutputNodeInfo) String() string { return proto.CompactTextString(m) }
func (*GraphTransferGraphOutputNodeInfo) ProtoMessage()    {}
func (*GraphTransferGraphOutputNodeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a1e773f26c9475, []int{6}
}
func (m *GraphTransferGraphOutputNodeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GraphTransferGraphOutputNodeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GraphTransferGraphOutputNodeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GraphTransferGraphOutputNodeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GraphTransferGraphOutputNodeInfo.Merge(m, src)
}
func (m *GraphTransferGraphOutputNodeInfo) XXX_Size() int {
	return m.Size()
}
func (m *GraphTransferGraphOutputNodeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GraphTransferGraphOutputNodeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GraphTransferGraphOutputNodeInfo proto.InternalMessageInfo

func (m *GraphTransferGraphOutputNodeInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GraphTransferGraphOutputNodeInfo) GetShape() []int64 {
	if m != nil {
		return m.Shape
	}
	return nil
}

func (m *GraphTransferGraphOutputNodeInfo) GetDtype() DataType {
	if m != nil {
		return m.Dtype
	}
	return DataType_DT_INVALID
}

// Protocol buffer representing a handle to a tensorflow resource. Handles are
// not valid across executions, but can be serialized back and forth from within
// a single run.
type GraphTransferInfo struct {
	NodeInfo       []*GraphTransferNodeInfo       `protobuf:"bytes,1,rep,name=node_info,json=nodeInfo,proto3" json:"node_info,omitempty"`
	ConstNodeInfo  []*GraphTransferConstNodeInfo  `protobuf:"bytes,2,rep,name=const_node_info,json=constNodeInfo,proto3" json:"const_node_info,omitempty"`
	NodeInputInfo  []*GraphTransferNodeInputInfo  `protobuf:"bytes,3,rep,name=node_input_info,json=nodeInputInfo,proto3" json:"node_input_info,omitempty"`
	NodeOutputInfo []*GraphTransferNodeOutputInfo `protobuf:"bytes,4,rep,name=node_output_info,json=nodeOutputInfo,proto3" json:"node_output_info,omitempty"`
	// Input Node parameters of transferred graph
	GraphInputNodeInfo  []*GraphTransferGraphInputNodeInfo  `protobuf:"bytes,5,rep,name=graph_input_node_info,json=graphInputNodeInfo,proto3" json:"graph_input_node_info,omitempty"`
	GraphOutputNodeInfo []*GraphTransferGraphOutputNodeInfo `protobuf:"bytes,6,rep,name=graph_output_node_info,json=graphOutputNodeInfo,proto3" json:"graph_output_node_info,omitempty"`
	// Destination of graph transfer
	Destination GraphTransferInfo_Destination `protobuf:"varint,7,opt,name=destination,proto3,enum=tensorflow.GraphTransferInfo_Destination" json:"destination,omitempty"`
}

func (m *GraphTransferInfo) Reset()         { *m = GraphTransferInfo{} }
func (m *GraphTransferInfo) String() string { return proto.CompactTextString(m) }
func (*GraphTransferInfo) ProtoMessage()    {}
func (*GraphTransferInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3a1e773f26c9475, []int{7}
}
func (m *GraphTransferInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GraphTransferInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GraphTransferInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GraphTransferInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GraphTransferInfo.Merge(m, src)
}
func (m *GraphTransferInfo) XXX_Size() int {
	return m.Size()
}
func (m *GraphTransferInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GraphTransferInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GraphTransferInfo proto.InternalMessageInfo

func (m *GraphTransferInfo) GetNodeInfo() []*GraphTransferNodeInfo {
	if m != nil {
		return m.NodeInfo
	}
	return nil
}

func (m *GraphTransferInfo) GetConstNodeInfo() []*GraphTransferConstNodeInfo {
	if m != nil {
		return m.ConstNodeInfo
	}
	return nil
}

func (m *GraphTransferInfo) GetNodeInputInfo() []*GraphTransferNodeInputInfo {
	if m != nil {
		return m.NodeInputInfo
	}
	return nil
}

func (m *GraphTransferInfo) GetNodeOutputInfo() []*GraphTransferNodeOutputInfo {
	if m != nil {
		return m.NodeOutputInfo
	}
	return nil
}

func (m *GraphTransferInfo) GetGraphInputNodeInfo() []*GraphTransferGraphInputNodeInfo {
	if m != nil {
		return m.GraphInputNodeInfo
	}
	return nil
}

func (m *GraphTransferInfo) GetGraphOutputNodeInfo() []*GraphTransferGraphOutputNodeInfo {
	if m != nil {
		return m.GraphOutputNodeInfo
	}
	return nil
}

func (m *GraphTransferInfo) GetDestination() GraphTransferInfo_Destination {
	if m != nil {
		return m.Destination
	}
	return GraphTransferInfo_NOP
}

func init() {
	proto.RegisterEnum("tensorflow.GraphTransferInfo_Destination", GraphTransferInfo_Destination_name, GraphTransferInfo_Destination_value)
	proto.RegisterType((*GraphTransferNodeInput)(nil), "tensorflow.GraphTransferNodeInput")
	proto.RegisterType((*GraphTransferNodeInfo)(nil), "tensorflow.GraphTransferNodeInfo")
	proto.RegisterType((*GraphTransferConstNodeInfo)(nil), "tensorflow.GraphTransferConstNodeInfo")
	proto.RegisterType((*GraphTransferNodeInputInfo)(nil), "tensorflow.GraphTransferNodeInputInfo")
	proto.RegisterType((*GraphTransferNodeOutputInfo)(nil), "tensorflow.GraphTransferNodeOutputInfo")
	proto.RegisterType((*GraphTransferGraphInputNodeInfo)(nil), "tensorflow.GraphTransferGraphInputNodeInfo")
	proto.RegisterType((*GraphTransferGraphOutputNodeInfo)(nil), "tensorflow.GraphTransferGraphOutputNodeInfo")
	proto.RegisterType((*GraphTransferInfo)(nil), "tensorflow.GraphTransferInfo")
}

func init() {
	proto.RegisterFile("tensorflow/core/framework/graph_transfer_info.proto", fileDescriptor_c3a1e773f26c9475)
}

var fileDescriptor_c3a1e773f26c9475 = []byte{
	// 712 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x55, 0xdd, 0x4e, 0x13, 0x41,
	0x14, 0xee, 0xf6, 0x97, 0x9e, 0xf2, 0xe7, 0x0a, 0xd8, 0x40, 0x2c, 0xb0, 0x46, 0xc5, 0xbf, 0x36,
	0x81, 0x7b, 0x13, 0x0a, 0x06, 0x89, 0x49, 0x5b, 0x47, 0x2e, 0x0c, 0x17, 0x6e, 0x86, 0xee, 0x6c,
	0xd9, 0x48, 0x67, 0x36, 0xbb, 0xd3, 0x40, 0x79, 0x0a, 0x13, 0x1f, 0xc0, 0xd7, 0xf1, 0x92, 0x4b,
	0x2f, 0x09, 0xbc, 0x84, 0x89, 0x37, 0x66, 0xce, 0x94, 0xee, 0xae, 0xa5, 0xc5, 0x98, 0x78, 0x37,
	0x33, 0xe7, 0x9c, 0xef, 0x3b, 0x3f, 0xdf, 0xee, 0x81, 0x2d, 0xc9, 0x78, 0x28, 0x02, 0xf7, 0x44,
	0x9c, 0xd6, 0xda, 0x22, 0x60, 0x35, 0x37, 0xa0, 0x5d, 0x76, 0x2a, 0x82, 0xcf, 0xb5, 0x4e, 0x40,
	0xfd, 0x63, 0x5b, 0x06, 0x94, 0x87, 0x2e, 0x0b, 0x6c, 0x8f, 0xbb, 0xa2, 0xea, 0x07, 0x42, 0x0a,
	0x13, 0xa2, 0xa0, 0xe5, 0xc7, 0xe3, 0x01, 0x64, 0xdf, 0x67, 0xa1, 0x0e, 0xb1, 0x08, 0x2c, 0xed,
	0x29, 0xbc, 0x83, 0x01, 0x5c, 0x43, 0x38, 0x6c, 0x9f, 0xfb, 0x3d, 0x69, 0x3e, 0x80, 0x02, 0x17,
	0x0e, 0xb3, 0x3d, 0xa7, 0x6c, 0xac, 0x19, 0x1b, 0x39, 0x92, 0x57, 0xd7, 0x7d, 0xc7, 0x5c, 0x85,
	0x92, 0xe8, 0x49, 0xbf, 0x27, 0x6d, 0x5f, 0x04, 0xb2, 0x9c, 0x46, 0x23, 0xe8, 0xa7, 0x96, 0x08,
	0xa4, 0x75, 0x69, 0xc0, 0xe2, 0x2d, 0xa0, 0xae, 0x30, 0x4d, 0xc8, 0x72, 0xda, 0x65, 0x08, 0x58,
	0x24, 0x78, 0x8e, 0xf3, 0xa4, 0x13, 0x3c, 0x2b, 0x50, 0x54, 0x99, 0xda, 0x18, 0x91, 0xc1, 0x88,
	0x29, 0xf5, 0xd0, 0x50, 0x51, 0xcb, 0x50, 0x0c, 0x45, 0xdb, 0x16, 0xbe, 0x8a, 0xcb, 0x62, 0x5c,
	0x21, 0x14, 0xed, 0xa6, 0xbf, 0xef, 0x98, 0x0f, 0x01, 0x7c, 0xea, 0x38, 0x1e, 0xef, 0x28, 0x63,
	0x0e, 0x8d, 0xc5, 0xc1, 0x8b, 0xce, 0xdf, 0x53, 0x15, 0xda, 0x6d, 0xd1, 0xe3, 0xb2, 0x9c, 0xd7,
	0xf9, 0xe3, 0xd3, 0x8e, 0x7a, 0x31, 0xd7, 0x61, 0x7a, 0x50, 0xa0, 0xf6, 0x28, 0xa0, 0xc7, 0xa0,
	0x68, 0x74, 0xb1, 0xbe, 0x19, 0xb0, 0x9c, 0x28, 0x71, 0x47, 0xf0, 0x50, 0xfe, 0x5b, 0x9d, 0x0b,
	0x90, 0x0b, 0x8f, 0xa9, 0xaf, 0x6a, 0xcc, 0x6c, 0x64, 0x88, 0xbe, 0x28, 0x08, 0x87, 0x4a, 0x8a,
	0xb5, 0x4d, 0x13, 0x3c, 0x9b, 0xcf, 0x21, 0xe7, 0xa8, 0x0e, 0x60, 0x4d, 0xb3, 0x9b, 0x0b, 0xd5,
	0x68, 0xc6, 0xd5, 0x5d, 0x2a, 0xe9, 0x41, 0xdf, 0x67, 0x44, 0xbb, 0x58, 0x67, 0x7f, 0x24, 0x38,
	0x1c, 0x2c, 0x26, 0x38, 0x76, 0xb8, 0xdb, 0x00, 0xda, 0xa0, 0x5c, 0xcb, 0xe9, 0xb5, 0xcc, 0x46,
	0x69, 0xd3, 0x8a, 0xf3, 0xdc, 0x0e, 0x4a, 0x8a, 0xfc, 0xe6, 0x68, 0x1d, 0xc2, 0xca, 0x88, 0x53,
	0x13, 0x7b, 0x37, 0x99, 0xda, 0x82, 0x99, 0x2e, 0x3d, 0xb3, 0x8f, 0xfa, 0x92, 0xd9, 0xa1, 0x77,
	0xce, 0x90, 0x3d, 0x47, 0x4a, 0x5d, 0x7a, 0x56, 0xef, 0x4b, 0xf6, 0xc1, 0x3b, 0x67, 0xd6, 0x29,
	0xac, 0x26, 0xb0, 0xf1, 0x82, 0xb4, 0x13, 0x7b, 0x3f, 0x6c, 0x71, 0x3a, 0xde, 0xe2, 0x61, 0x3b,
	0x33, 0x7f, 0xd3, 0xce, 0xb5, 0x51, 0x62, 0x5d, 0xd5, 0x7f, 0x66, 0xfe, 0x95, 0x85, 0x7b, 0x09,
	0x6a, 0xe4, 0x7a, 0x0d, 0xc5, 0xc1, 0x9c, 0x5c, 0x51, 0x36, 0x70, 0x4c, 0xeb, 0x77, 0x8c, 0xc9,
	0x15, 0x64, 0x8a, 0xdf, 0xe4, 0xda, 0x80, 0xb9, 0xb6, 0x92, 0xac, 0x1d, 0xa1, 0xe8, 0x61, 0x3f,
	0x19, 0x8b, 0x92, 0x90, 0x38, 0x99, 0x69, 0x27, 0x14, 0xdf, 0x80, 0xb9, 0x48, 0x37, 0x1a, 0x2f,
	0x73, 0x07, 0x5e, 0x42, 0x91, 0x64, 0x86, 0x27, 0x04, 0xfa, 0x1e, 0xe6, 0x11, 0x6f, 0xf0, 0x21,
	0x22, 0x60, 0x16, 0x01, 0x9f, 0x4e, 0x04, 0x8c, 0x84, 0x46, 0x66, 0x79, 0x52, 0x78, 0x9f, 0x60,
	0x51, 0xff, 0x3a, 0x75, 0x8e, 0x51, 0xe1, 0x39, 0xc4, 0x7d, 0x31, 0x16, 0x77, 0x54, 0x64, 0xc4,
	0xec, 0x8c, 0x0a, 0x8f, 0xc2, 0x92, 0xc6, 0x1f, 0xe4, 0x1c, 0x11, 0xe4, 0x91, 0xe0, 0xe5, 0x64,
	0x82, 0xa4, 0x98, 0xc8, 0xfd, 0xce, 0x2d, 0x0a, 0x7b, 0x07, 0x25, 0x87, 0x85, 0xd2, 0xe3, 0x54,
	0x7a, 0x82, 0xe3, 0x8f, 0x69, 0x76, 0xf3, 0xd9, 0x58, 0x5c, 0x15, 0x53, 0xdd, 0x8d, 0x02, 0x48,
	0x3c, 0xda, 0x7a, 0x04, 0xa5, 0x98, 0xcd, 0x2c, 0x40, 0xa6, 0xd1, 0x6c, 0xcd, 0xa7, 0xcc, 0x12,
	0x14, 0xde, 0xbe, 0xf9, 0xb8, 0xbd, 0xd7, 0x6c, 0xcc, 0x1b, 0xf5, 0xaf, 0xc6, 0xf7, 0xab, 0x8a,
	0x71, 0x71, 0x55, 0x31, 0x2e, 0xaf, 0x2a, 0xc6, 0x97, 0xeb, 0x4a, 0xea, 0xe2, 0xba, 0x92, 0xfa,
	0x71, 0x5d, 0x49, 0x41, 0x59, 0x04, 0x9d, 0x38, 0xf5, 0x70, 0xc1, 0xd4, 0x97, 0x46, 0xb2, 0x68,
	0xa9, 0x65, 0xd3, 0x32, 0x0e, 0xeb, 0x1d, 0x4f, 0x1e, 0xf7, 0x8e, 0xaa, 0x6d, 0xd1, 0xad, 0x6d,
	0xfb, 0xfe, 0x89, 0xe7, 0x7a, 0x2c, 0xa8, 0x75, 0xc4, 0xab, 0xd8, 0xb6, 0xc2, 0xf5, 0x54, 0x1b,
	0xbb, 0xbe, 0x7e, 0x1a, 0xc6, 0x51, 0x1e, 0x97, 0xd7, 0xd6, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x56, 0x5e, 0x8e, 0x16, 0x26, 0x07, 0x00, 0x00,
}

func (m *GraphTransferNodeInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GraphTransferNodeInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GraphTransferNodeInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OutputPort != 0 {
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(m.OutputPort))
		i--
		dAtA[i] = 0x10
	}
	if m.NodeId != 0 {
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(m.NodeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GraphTransferNodeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GraphTransferNodeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GraphTransferNodeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OutputCount != 0 {
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(m.OutputCount))
		i--
		dAtA[i] = 0x38
	}
	if m.InputCount != 0 {
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(m.InputCount))
		i--
		dAtA[i] = 0x30
	}
	if m.PaddingId != 0 {
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(m.PaddingId))
		i--
		dAtA[i] = 0x28
	}
	if m.SocOpId != 0 {
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(m.SocOpId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.TypeName) > 0 {
		i -= len(m.TypeName)
		copy(dAtA[i:], m.TypeName)
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(len(m.TypeName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NodeId != 0 {
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(m.NodeId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GraphTransferConstNodeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GraphTransferConstNodeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GraphTransferConstNodeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Dtype != 0 {
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(m.Dtype))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Shape) > 0 {
		dAtA2 := make([]byte, len(m.Shape)*10)
		var j1 int
		for _, num1 := range m.Shape {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x1a
	}
	if m.NodeId != 0 {
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(m.NodeId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GraphTransferNodeInputInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GraphTransferNodeInputInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GraphTransferNodeInputInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeInput) > 0 {
		for iNdEx := len(m.NodeInput) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NodeInput[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGraphTransferInfo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.NodeId != 0 {
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(m.NodeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GraphTransferNodeOutputInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GraphTransferNodeOutputInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GraphTransferNodeOutputInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MaxByteSize) > 0 {
		dAtA4 := make([]byte, len(m.MaxByteSize)*10)
		var j3 int
		for _, num1 := range m.MaxByteSize {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x12
	}
	if m.NodeId != 0 {
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(m.NodeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GraphTransferGraphInputNodeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GraphTransferGraphInputNodeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GraphTransferGraphInputNodeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Dtype != 0 {
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(m.Dtype))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Shape) > 0 {
		dAtA6 := make([]byte, len(m.Shape)*10)
		var j5 int
		for _, num1 := range m.Shape {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GraphTransferGraphOutputNodeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GraphTransferGraphOutputNodeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GraphTransferGraphOutputNodeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Dtype != 0 {
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(m.Dtype))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Shape) > 0 {
		dAtA8 := make([]byte, len(m.Shape)*10)
		var j7 int
		for _, num1 := range m.Shape {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GraphTransferInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GraphTransferInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GraphTransferInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Destination != 0 {
		i = encodeVarintGraphTransferInfo(dAtA, i, uint64(m.Destination))
		i--
		dAtA[i] = 0x38
	}
	if len(m.GraphOutputNodeInfo) > 0 {
		for iNdEx := len(m.GraphOutputNodeInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GraphOutputNodeInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGraphTransferInfo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.GraphInputNodeInfo) > 0 {
		for iNdEx := len(m.GraphInputNodeInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GraphInputNodeInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGraphTransferInfo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.NodeOutputInfo) > 0 {
		for iNdEx := len(m.NodeOutputInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NodeOutputInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGraphTransferInfo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.NodeInputInfo) > 0 {
		for iNdEx := len(m.NodeInputInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NodeInputInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGraphTransferInfo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ConstNodeInfo) > 0 {
		for iNdEx := len(m.ConstNodeInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ConstNodeInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGraphTransferInfo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.NodeInfo) > 0 {
		for iNdEx := len(m.NodeInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NodeInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGraphTransferInfo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintGraphTransferInfo(dAtA []byte, offset int, v uint64) int {
	offset -= sovGraphTransferInfo(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GraphTransferNodeInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeId != 0 {
		n += 1 + sovGraphTransferInfo(uint64(m.NodeId))
	}
	if m.OutputPort != 0 {
		n += 1 + sovGraphTransferInfo(uint64(m.OutputPort))
	}
	return n
}

func (m *GraphTransferNodeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGraphTransferInfo(uint64(l))
	}
	if m.NodeId != 0 {
		n += 1 + sovGraphTransferInfo(uint64(m.NodeId))
	}
	l = len(m.TypeName)
	if l > 0 {
		n += 1 + l + sovGraphTransferInfo(uint64(l))
	}
	if m.SocOpId != 0 {
		n += 1 + sovGraphTransferInfo(uint64(m.SocOpId))
	}
	if m.PaddingId != 0 {
		n += 1 + sovGraphTransferInfo(uint64(m.PaddingId))
	}
	if m.InputCount != 0 {
		n += 1 + sovGraphTransferInfo(uint64(m.InputCount))
	}
	if m.OutputCount != 0 {
		n += 1 + sovGraphTransferInfo(uint64(m.OutputCount))
	}
	return n
}

func (m *GraphTransferConstNodeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGraphTransferInfo(uint64(l))
	}
	if m.NodeId != 0 {
		n += 1 + sovGraphTransferInfo(uint64(m.NodeId))
	}
	if len(m.Shape) > 0 {
		l = 0
		for _, e := range m.Shape {
			l += sovGraphTransferInfo(uint64(e))
		}
		n += 1 + sovGraphTransferInfo(uint64(l)) + l
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovGraphTransferInfo(uint64(l))
	}
	if m.Dtype != 0 {
		n += 1 + sovGraphTransferInfo(uint64(m.Dtype))
	}
	return n
}

func (m *GraphTransferNodeInputInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeId != 0 {
		n += 1 + sovGraphTransferInfo(uint64(m.NodeId))
	}
	if len(m.NodeInput) > 0 {
		for _, e := range m.NodeInput {
			l = e.Size()
			n += 1 + l + sovGraphTransferInfo(uint64(l))
		}
	}
	return n
}

func (m *GraphTransferNodeOutputInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeId != 0 {
		n += 1 + sovGraphTransferInfo(uint64(m.NodeId))
	}
	if len(m.MaxByteSize) > 0 {
		l = 0
		for _, e := range m.MaxByteSize {
			l += sovGraphTransferInfo(uint64(e))
		}
		n += 1 + sovGraphTransferInfo(uint64(l)) + l
	}
	return n
}

func (m *GraphTransferGraphInputNodeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGraphTransferInfo(uint64(l))
	}
	if len(m.Shape) > 0 {
		l = 0
		for _, e := range m.Shape {
			l += sovGraphTransferInfo(uint64(e))
		}
		n += 1 + sovGraphTransferInfo(uint64(l)) + l
	}
	if m.Dtype != 0 {
		n += 1 + sovGraphTransferInfo(uint64(m.Dtype))
	}
	return n
}

func (m *GraphTransferGraphOutputNodeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGraphTransferInfo(uint64(l))
	}
	if len(m.Shape) > 0 {
		l = 0
		for _, e := range m.Shape {
			l += sovGraphTransferInfo(uint64(e))
		}
		n += 1 + sovGraphTransferInfo(uint64(l)) + l
	}
	if m.Dtype != 0 {
		n += 1 + sovGraphTransferInfo(uint64(m.Dtype))
	}
	return n
}

func (m *GraphTransferInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NodeInfo) > 0 {
		for _, e := range m.NodeInfo {
			l = e.Size()
			n += 1 + l + sovGraphTransferInfo(uint64(l))
		}
	}
	if len(m.ConstNodeInfo) > 0 {
		for _, e := range m.ConstNodeInfo {
			l = e.Size()
			n += 1 + l + sovGraphTransferInfo(uint64(l))
		}
	}
	if len(m.NodeInputInfo) > 0 {
		for _, e := range m.NodeInputInfo {
			l = e.Size()
			n += 1 + l + sovGraphTransferInfo(uint64(l))
		}
	}
	if len(m.NodeOutputInfo) > 0 {
		for _, e := range m.NodeOutputInfo {
			l = e.Size()
			n += 1 + l + sovGraphTransferInfo(uint64(l))
		}
	}
	if len(m.GraphInputNodeInfo) > 0 {
		for _, e := range m.GraphInputNodeInfo {
			l = e.Size()
			n += 1 + l + sovGraphTransferInfo(uint64(l))
		}
	}
	if len(m.GraphOutputNodeInfo) > 0 {
		for _, e := range m.GraphOutputNodeInfo {
			l = e.Size()
			n += 1 + l + sovGraphTransferInfo(uint64(l))
		}
	}
	if m.Destination != 0 {
		n += 1 + sovGraphTransferInfo(uint64(m.Destination))
	}
	return n
}

func sovGraphTransferInfo(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGraphTransferInfo(x uint64) (n int) {
	return sovGraphTransferInfo(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GraphTransferNodeInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGraphTransferInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GraphTransferNodeInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GraphTransferNodeInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputPort", wireType)
			}
			m.OutputPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGraphTransferInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GraphTransferNodeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGraphTransferInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GraphTransferNodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GraphTransferNodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SocOpId", wireType)
			}
			m.SocOpId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SocOpId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaddingId", wireType)
			}
			m.PaddingId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PaddingId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputCount", wireType)
			}
			m.InputCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputCount", wireType)
			}
			m.OutputCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGraphTransferInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GraphTransferConstNodeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGraphTransferInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GraphTransferConstNodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GraphTransferConstNodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGraphTransferInfo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Shape = append(m.Shape, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGraphTransferInfo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGraphTransferInfo
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGraphTransferInfo
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Shape) == 0 {
					m.Shape = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGraphTransferInfo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Shape = append(m.Shape, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Shape", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dtype", wireType)
			}
			m.Dtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dtype |= DataType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGraphTransferInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GraphTransferNodeInputInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGraphTransferInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GraphTransferNodeInputInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GraphTransferNodeInputInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeInput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeInput = append(m.NodeInput, &GraphTransferNodeInput{})
			if err := m.NodeInput[len(m.NodeInput)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGraphTransferInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GraphTransferNodeOutputInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGraphTransferInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GraphTransferNodeOutputInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GraphTransferNodeOutputInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGraphTransferInfo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MaxByteSize = append(m.MaxByteSize, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGraphTransferInfo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGraphTransferInfo
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGraphTransferInfo
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.MaxByteSize) == 0 {
					m.MaxByteSize = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGraphTransferInfo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MaxByteSize = append(m.MaxByteSize, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxByteSize", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGraphTransferInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GraphTransferGraphInputNodeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGraphTransferInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GraphTransferGraphInputNodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GraphTransferGraphInputNodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGraphTransferInfo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Shape = append(m.Shape, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGraphTransferInfo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGraphTransferInfo
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGraphTransferInfo
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Shape) == 0 {
					m.Shape = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGraphTransferInfo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Shape = append(m.Shape, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Shape", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dtype", wireType)
			}
			m.Dtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dtype |= DataType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGraphTransferInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GraphTransferGraphOutputNodeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGraphTransferInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GraphTransferGraphOutputNodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GraphTransferGraphOutputNodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGraphTransferInfo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Shape = append(m.Shape, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGraphTransferInfo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGraphTransferInfo
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGraphTransferInfo
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Shape) == 0 {
					m.Shape = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGraphTransferInfo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Shape = append(m.Shape, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Shape", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dtype", wireType)
			}
			m.Dtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dtype |= DataType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGraphTransferInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GraphTransferInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGraphTransferInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GraphTransferInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GraphTransferInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeInfo = append(m.NodeInfo, &GraphTransferNodeInfo{})
			if err := m.NodeInfo[len(m.NodeInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstNodeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConstNodeInfo = append(m.ConstNodeInfo, &GraphTransferConstNodeInfo{})
			if err := m.ConstNodeInfo[len(m.ConstNodeInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeInputInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeInputInfo = append(m.NodeInputInfo, &GraphTransferNodeInputInfo{})
			if err := m.NodeInputInfo[len(m.NodeInputInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeOutputInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeOutputInfo = append(m.NodeOutputInfo, &GraphTransferNodeOutputInfo{})
			if err := m.NodeOutputInfo[len(m.NodeOutputInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphInputNodeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GraphInputNodeInfo = append(m.GraphInputNodeInfo, &GraphTransferGraphInputNodeInfo{})
			if err := m.GraphInputNodeInfo[len(m.GraphInputNodeInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphOutputNodeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GraphOutputNodeInfo = append(m.GraphOutputNodeInfo, &GraphTransferGraphOutputNodeInfo{})
			if err := m.GraphOutputNodeInfo[len(m.GraphOutputNodeInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			m.Destination = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Destination |= GraphTransferInfo_Destination(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGraphTransferInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGraphTransferInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGraphTransferInfo(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGraphTransferInfo
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGraphTransferInfo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGraphTransferInfo
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGraphTransferInfo
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGraphTransferInfo
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGraphTransferInfo        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGraphTransferInfo          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGraphTransferInfo = fmt.Errorf("proto: unexpected end of group")
)
