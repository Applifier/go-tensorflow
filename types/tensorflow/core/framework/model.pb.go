// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tensorflow/core/framework/model.proto

package framework

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Class of a node in the performance model.
type NodeClass int32

const (
	NodeClass_UNKNOWN               NodeClass = 0
	NodeClass_INTERLEAVE_MANY       NodeClass = 1
	NodeClass_ASYNC_INTERLEAVE_MANY NodeClass = 2
	NodeClass_KNOWN_RATIO           NodeClass = 3
	NodeClass_ASYNC_KNOWN_RATIO     NodeClass = 4
	NodeClass_UNKNOWN_RATIO         NodeClass = 5
)

var NodeClass_name = map[int32]string{
	0: "UNKNOWN",
	1: "INTERLEAVE_MANY",
	2: "ASYNC_INTERLEAVE_MANY",
	3: "KNOWN_RATIO",
	4: "ASYNC_KNOWN_RATIO",
	5: "UNKNOWN_RATIO",
}

var NodeClass_value = map[string]int32{
	"UNKNOWN":               0,
	"INTERLEAVE_MANY":       1,
	"ASYNC_INTERLEAVE_MANY": 2,
	"KNOWN_RATIO":           3,
	"ASYNC_KNOWN_RATIO":     4,
	"UNKNOWN_RATIO":         5,
}

func (x NodeClass) String() string {
	return proto.EnumName(NodeClass_name, int32(x))
}

func (NodeClass) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5a767be480809d52, []int{0}
}

// Algorithm used for model autotuning optimization.
type AutotuneAlgorithm int32

const (
	AutotuneAlgorithm_HILL_CLIMB       AutotuneAlgorithm = 0
	AutotuneAlgorithm_GRADIENT_DESCENT AutotuneAlgorithm = 1
)

var AutotuneAlgorithm_name = map[int32]string{
	0: "HILL_CLIMB",
	1: "GRADIENT_DESCENT",
}

var AutotuneAlgorithm_value = map[string]int32{
	"HILL_CLIMB":       0,
	"GRADIENT_DESCENT": 1,
}

func (x AutotuneAlgorithm) String() string {
	return proto.EnumName(AutotuneAlgorithm_name, int32(x))
}

func (AutotuneAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5a767be480809d52, []int{1}
}

// Protocol buffer representing the data used by the autotuning modeling
// framework.
type ModelProto struct {
	// Output node of this model.
	Output *ModelProto_Node `protobuf:"bytes,1,opt,name=output,proto3" json:"output,omitempty"`
	// Counter for node IDs of this model.
	IdCounter int64 `protobuf:"varint,2,opt,name=id_counter,json=idCounter,proto3" json:"id_counter,omitempty"`
	// Indicates whether the modeling framework should collect resource usage,
	// e.g. CPU, memory.
	CollectResourceUsage bool                           `protobuf:"varint,3,opt,name=collect_resource_usage,json=collectResourceUsage,proto3" json:"collect_resource_usage,omitempty"`
	OptimizationParams   *ModelProto_OptimizationParams `protobuf:"bytes,4,opt,name=optimization_params,json=optimizationParams,proto3" json:"optimization_params,omitempty"`
}

func (m *ModelProto) Reset()         { *m = ModelProto{} }
func (m *ModelProto) String() string { return proto.CompactTextString(m) }
func (*ModelProto) ProtoMessage()    {}
func (*ModelProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a767be480809d52, []int{0}
}
func (m *ModelProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelProto.Merge(m, src)
}
func (m *ModelProto) XXX_Size() int {
	return m.Size()
}
func (m *ModelProto) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelProto.DiscardUnknown(m)
}

var xxx_messageInfo_ModelProto proto.InternalMessageInfo

func (m *ModelProto) GetOutput() *ModelProto_Node {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *ModelProto) GetIdCounter() int64 {
	if m != nil {
		return m.IdCounter
	}
	return 0
}

func (m *ModelProto) GetCollectResourceUsage() bool {
	if m != nil {
		return m.CollectResourceUsage
	}
	return false
}

func (m *ModelProto) GetOptimizationParams() *ModelProto_OptimizationParams {
	if m != nil {
		return m.OptimizationParams
	}
	return nil
}

// General representation of a node in the model.
type ModelProto_Node struct {
	// Unique node ID.
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Human-readable name of the node.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// An indication whether autotuning is enabled for this node.
	Autotune bool `protobuf:"varint,3,opt,name=autotune,proto3" json:"autotune,omitempty"`
	// The number of bytes stored in this node's buffer.
	BufferedBytes int64 `protobuf:"varint,4,opt,name=buffered_bytes,json=bufferedBytes,proto3" json:"buffered_bytes,omitempty"`
	// The number of elements stored in this node's buffer.
	BufferedElements int64 `protobuf:"varint,5,opt,name=buffered_elements,json=bufferedElements,proto3" json:"buffered_elements,omitempty"`
	// The number of bytes consumed by the node.
	BytesConsumed int64 `protobuf:"varint,6,opt,name=bytes_consumed,json=bytesConsumed,proto3" json:"bytes_consumed,omitempty"`
	// The number of bytes produced by the node.
	BytesProduced int64 `protobuf:"varint,7,opt,name=bytes_produced,json=bytesProduced,proto3" json:"bytes_produced,omitempty"`
	// The number of elements produced by the node.
	NumElements int64 `protobuf:"varint,8,opt,name=num_elements,json=numElements,proto3" json:"num_elements,omitempty"`
	// The aggregate processing time spent in this node.
	ProcessingTime int64 `protobuf:"varint,9,opt,name=processing_time,json=processingTime,proto3" json:"processing_time,omitempty"`
	// An indication whether this node records metrics about produced and
	// consumed elements.
	RecordMetrics bool `protobuf:"varint,10,opt,name=record_metrics,json=recordMetrics,proto3" json:"record_metrics,omitempty"`
	// Parameters of this node.
	Parameters []*ModelProto_Node_Parameter `protobuf:"bytes,11,rep,name=parameters,proto3" json:"parameters,omitempty"`
	// Statistic of inputs processing time history.
	InputProcessingTimeSum   float64 `protobuf:"fixed64,12,opt,name=input_processing_time_sum,json=inputProcessingTimeSum,proto3" json:"input_processing_time_sum,omitempty"`
	InputProcessingTimeCount int64   `protobuf:"varint,13,opt,name=input_processing_time_count,json=inputProcessingTimeCount,proto3" json:"input_processing_time_count,omitempty"`
	// Inputs of this node.
	Inputs []*ModelProto_Node `protobuf:"bytes,14,rep,name=inputs,proto3" json:"inputs,omitempty"`
	// Class of this node.
	NodeClass NodeClass `protobuf:"varint,15,opt,name=node_class,json=nodeClass,proto3,enum=tensorflow.data.model.NodeClass" json:"node_class,omitempty"`
	// Ratio of input to output elements. This is only used by KNOWN_RATIO and
	// ASYNC_KNOWN_RATIO nodes.
	Ratio float64 `protobuf:"fixed64,16,opt,name=ratio,proto3" json:"ratio,omitempty"`
	// Ratio identifies how many parallelism calls are introduced by one
	// buffered element. This is only used by ASYNC_KNOWN_RATIO nodes.
	MemoryRatio float64 `protobuf:"fixed64,17,opt,name=memory_ratio,json=memoryRatio,proto3" json:"memory_ratio,omitempty"`
}

func (m *ModelProto_Node) Reset()         { *m = ModelProto_Node{} }
func (m *ModelProto_Node) String() string { return proto.CompactTextString(m) }
func (*ModelProto_Node) ProtoMessage()    {}
func (*ModelProto_Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a767be480809d52, []int{0, 0}
}
func (m *ModelProto_Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelProto_Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelProto_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelProto_Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelProto_Node.Merge(m, src)
}
func (m *ModelProto_Node) XXX_Size() int {
	return m.Size()
}
func (m *ModelProto_Node) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelProto_Node.DiscardUnknown(m)
}

var xxx_messageInfo_ModelProto_Node proto.InternalMessageInfo

func (m *ModelProto_Node) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ModelProto_Node) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ModelProto_Node) GetAutotune() bool {
	if m != nil {
		return m.Autotune
	}
	return false
}

func (m *ModelProto_Node) GetBufferedBytes() int64 {
	if m != nil {
		return m.BufferedBytes
	}
	return 0
}

func (m *ModelProto_Node) GetBufferedElements() int64 {
	if m != nil {
		return m.BufferedElements
	}
	return 0
}

func (m *ModelProto_Node) GetBytesConsumed() int64 {
	if m != nil {
		return m.BytesConsumed
	}
	return 0
}

func (m *ModelProto_Node) GetBytesProduced() int64 {
	if m != nil {
		return m.BytesProduced
	}
	return 0
}

func (m *ModelProto_Node) GetNumElements() int64 {
	if m != nil {
		return m.NumElements
	}
	return 0
}

func (m *ModelProto_Node) GetProcessingTime() int64 {
	if m != nil {
		return m.ProcessingTime
	}
	return 0
}

func (m *ModelProto_Node) GetRecordMetrics() bool {
	if m != nil {
		return m.RecordMetrics
	}
	return false
}

func (m *ModelProto_Node) GetParameters() []*ModelProto_Node_Parameter {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *ModelProto_Node) GetInputProcessingTimeSum() float64 {
	if m != nil {
		return m.InputProcessingTimeSum
	}
	return 0
}

func (m *ModelProto_Node) GetInputProcessingTimeCount() int64 {
	if m != nil {
		return m.InputProcessingTimeCount
	}
	return 0
}

func (m *ModelProto_Node) GetInputs() []*ModelProto_Node {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *ModelProto_Node) GetNodeClass() NodeClass {
	if m != nil {
		return m.NodeClass
	}
	return NodeClass_UNKNOWN
}

func (m *ModelProto_Node) GetRatio() float64 {
	if m != nil {
		return m.Ratio
	}
	return 0
}

func (m *ModelProto_Node) GetMemoryRatio() float64 {
	if m != nil {
		return m.MemoryRatio
	}
	return 0
}

// Represents a node parameter.
type ModelProto_Node_Parameter struct {
	// Human-readable name of the parameter.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Identifies the model value of the parameter. This can be different from
	// the actual value (e.g. during optimization search).
	Value float64 `protobuf:"fixed64,2,opt,name=value,proto3" json:"value,omitempty"`
	// The actual value of the parameter.
	StateValue float64 `protobuf:"fixed64,3,opt,name=state_value,json=stateValue,proto3" json:"state_value,omitempty"`
	// Minimum value of the parameter.
	Min float64 `protobuf:"fixed64,4,opt,name=min,proto3" json:"min,omitempty"`
	// Maximum value of the parameter.
	Max float64 `protobuf:"fixed64,5,opt,name=max,proto3" json:"max,omitempty"`
	// Identifies whether the parameter should participate in autotuning.
	Tunable bool `protobuf:"varint,6,opt,name=tunable,proto3" json:"tunable,omitempty"`
}

func (m *ModelProto_Node_Parameter) Reset()         { *m = ModelProto_Node_Parameter{} }
func (m *ModelProto_Node_Parameter) String() string { return proto.CompactTextString(m) }
func (*ModelProto_Node_Parameter) ProtoMessage()    {}
func (*ModelProto_Node_Parameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a767be480809d52, []int{0, 0, 0}
}
func (m *ModelProto_Node_Parameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelProto_Node_Parameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelProto_Node_Parameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelProto_Node_Parameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelProto_Node_Parameter.Merge(m, src)
}
func (m *ModelProto_Node_Parameter) XXX_Size() int {
	return m.Size()
}
func (m *ModelProto_Node_Parameter) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelProto_Node_Parameter.DiscardUnknown(m)
}

var xxx_messageInfo_ModelProto_Node_Parameter proto.InternalMessageInfo

func (m *ModelProto_Node_Parameter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ModelProto_Node_Parameter) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *ModelProto_Node_Parameter) GetStateValue() float64 {
	if m != nil {
		return m.StateValue
	}
	return 0
}

func (m *ModelProto_Node_Parameter) GetMin() float64 {
	if m != nil {
		return m.Min
	}
	return 0
}

func (m *ModelProto_Node_Parameter) GetMax() float64 {
	if m != nil {
		return m.Max
	}
	return 0
}

func (m *ModelProto_Node_Parameter) GetTunable() bool {
	if m != nil {
		return m.Tunable
	}
	return false
}

// Contains parameters of the model autotuning optimization.
type ModelProto_OptimizationParams struct {
	// Algorithm used for autotuning optimization.
	Algorithm AutotuneAlgorithm `protobuf:"varint,1,opt,name=algorithm,proto3,enum=tensorflow.data.model.AutotuneAlgorithm" json:"algorithm,omitempty"`
	// Number of available logical threads.
	CpuBudget int64 `protobuf:"varint,2,opt,name=cpu_budget,json=cpuBudget,proto3" json:"cpu_budget,omitempty"`
	// Amount of available memory in bytes.
	RamBudget int64 `protobuf:"varint,3,opt,name=ram_budget,json=ramBudget,proto3" json:"ram_budget,omitempty"`
	// Time between two consecutive `GetNext` calls to the iterator represented
	// by the output node.
	ModelInputTime float64 `protobuf:"fixed64,4,opt,name=model_input_time,json=modelInputTime,proto3" json:"model_input_time,omitempty"`
}

func (m *ModelProto_OptimizationParams) Reset()         { *m = ModelProto_OptimizationParams{} }
func (m *ModelProto_OptimizationParams) String() string { return proto.CompactTextString(m) }
func (*ModelProto_OptimizationParams) ProtoMessage()    {}
func (*ModelProto_OptimizationParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a767be480809d52, []int{0, 1}
}
func (m *ModelProto_OptimizationParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelProto_OptimizationParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelProto_OptimizationParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelProto_OptimizationParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelProto_OptimizationParams.Merge(m, src)
}
func (m *ModelProto_OptimizationParams) XXX_Size() int {
	return m.Size()
}
func (m *ModelProto_OptimizationParams) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelProto_OptimizationParams.DiscardUnknown(m)
}

var xxx_messageInfo_ModelProto_OptimizationParams proto.InternalMessageInfo

func (m *ModelProto_OptimizationParams) GetAlgorithm() AutotuneAlgorithm {
	if m != nil {
		return m.Algorithm
	}
	return AutotuneAlgorithm_HILL_CLIMB
}

func (m *ModelProto_OptimizationParams) GetCpuBudget() int64 {
	if m != nil {
		return m.CpuBudget
	}
	return 0
}

func (m *ModelProto_OptimizationParams) GetRamBudget() int64 {
	if m != nil {
		return m.RamBudget
	}
	return 0
}

func (m *ModelProto_OptimizationParams) GetModelInputTime() float64 {
	if m != nil {
		return m.ModelInputTime
	}
	return 0
}

func init() {
	proto.RegisterEnum("tensorflow.data.model.NodeClass", NodeClass_name, NodeClass_value)
	proto.RegisterEnum("tensorflow.data.model.AutotuneAlgorithm", AutotuneAlgorithm_name, AutotuneAlgorithm_value)
	proto.RegisterType((*ModelProto)(nil), "tensorflow.data.model.ModelProto")
	proto.RegisterType((*ModelProto_Node)(nil), "tensorflow.data.model.ModelProto.Node")
	proto.RegisterType((*ModelProto_Node_Parameter)(nil), "tensorflow.data.model.ModelProto.Node.Parameter")
	proto.RegisterType((*ModelProto_OptimizationParams)(nil), "tensorflow.data.model.ModelProto.OptimizationParams")
}

func init() {
	proto.RegisterFile("tensorflow/core/framework/model.proto", fileDescriptor_5a767be480809d52)
}

var fileDescriptor_5a767be480809d52 = []byte{
	// 882 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x55, 0x4d, 0x6f, 0x1b, 0x45,
	0x18, 0xf6, 0xc4, 0xf9, 0xf2, 0xeb, 0xc6, 0x59, 0x4f, 0x93, 0x6a, 0x1b, 0x84, 0x31, 0x48, 0x05,
	0xab, 0x08, 0x1b, 0x85, 0x5e, 0x7a, 0x00, 0x64, 0xbb, 0x06, 0x2c, 0x12, 0xc7, 0x9a, 0xb8, 0x45,
	0xe5, 0x32, 0x5a, 0xef, 0x8e, 0xdd, 0x15, 0x3b, 0x3b, 0xab, 0xd9, 0x19, 0xda, 0x70, 0xe5, 0x0f,
	0x70, 0xe0, 0x27, 0x71, 0x40, 0x9c, 0x7a, 0xe4, 0x88, 0x92, 0x3f, 0xd1, 0x23, 0xda, 0x77, 0xd7,
	0x1f, 0x34, 0x89, 0xe8, 0x6d, 0xe6, 0xf9, 0x98, 0x79, 0xdf, 0xd9, 0x67, 0x76, 0xe0, 0x81, 0x11,
	0x71, 0xaa, 0xf4, 0x2c, 0x52, 0x2f, 0x3b, 0xbe, 0xd2, 0xa2, 0x33, 0xd3, 0x9e, 0x14, 0x2f, 0x95,
	0xfe, 0xa9, 0x23, 0x55, 0x20, 0xa2, 0x76, 0xa2, 0x95, 0x51, 0xf4, 0x70, 0x25, 0x6b, 0x07, 0x9e,
	0xf1, 0xda, 0x48, 0x7e, 0xf4, 0x17, 0x00, 0x9c, 0x66, 0xa3, 0x31, 0xaa, 0xbe, 0x82, 0x6d, 0x65,
	0x4d, 0x62, 0x8d, 0x4b, 0x9a, 0xa4, 0x55, 0x3d, 0xfe, 0xb8, 0x7d, 0xa3, 0xad, 0xbd, 0xb2, 0xb4,
	0x47, 0x2a, 0x10, 0xac, 0x70, 0xd1, 0xf7, 0x01, 0xc2, 0x80, 0xfb, 0xca, 0xc6, 0x46, 0x68, 0x77,
	0xa3, 0x49, 0x5a, 0x65, 0x56, 0x09, 0x83, 0x7e, 0x0e, 0xd0, 0x47, 0x70, 0xcf, 0x57, 0x51, 0x24,
	0x7c, 0xc3, 0xb5, 0x48, 0x95, 0xd5, 0xbe, 0xe0, 0x36, 0xf5, 0xe6, 0xc2, 0x2d, 0x37, 0x49, 0x6b,
	0x97, 0x1d, 0x14, 0x2c, 0x2b, 0xc8, 0xa7, 0x19, 0x47, 0x05, 0xdc, 0x55, 0x89, 0x09, 0x65, 0xf8,
	0x8b, 0x67, 0x42, 0x15, 0xf3, 0xc4, 0xd3, 0x9e, 0x4c, 0xdd, 0x4d, 0xac, 0xf0, 0xd1, 0xff, 0x57,
	0x78, 0xb6, 0x66, 0x1e, 0xa3, 0x97, 0x51, 0x75, 0x0d, 0x3b, 0x7a, 0xb3, 0x0d, 0x9b, 0x59, 0x33,
	0xb4, 0x06, 0x1b, 0x61, 0x80, 0x07, 0x50, 0x66, 0x1b, 0x61, 0x40, 0x29, 0x6c, 0xc6, 0x9e, 0x14,
	0xd8, 0x4e, 0x85, 0xe1, 0x98, 0x1e, 0xc1, 0xae, 0x67, 0x8d, 0x32, 0x36, 0x5e, 0xd4, 0xbe, 0x9c,
	0xd3, 0x07, 0x50, 0x9b, 0xda, 0xd9, 0x4c, 0x68, 0x11, 0xf0, 0xe9, 0x85, 0x11, 0x79, 0xa9, 0x65,
	0xb6, 0xb7, 0x40, 0x7b, 0x19, 0x48, 0x3f, 0x85, 0xfa, 0x52, 0x26, 0x22, 0x21, 0x45, 0x6c, 0x52,
	0x77, 0x0b, 0x95, 0xce, 0x82, 0x18, 0x14, 0x38, 0xae, 0x99, 0xb9, 0xb8, 0xaf, 0xe2, 0xd4, 0x4a,
	0x11, 0xb8, 0xdb, 0xc5, 0x9a, 0x19, 0xda, 0x2f, 0xc0, 0x95, 0x2c, 0xd1, 0x2a, 0xb0, 0xbe, 0x08,
	0xdc, 0x9d, 0x35, 0xd9, 0xb8, 0x00, 0xe9, 0x87, 0x70, 0x27, 0xb6, 0x72, 0xb5, 0xeb, 0x2e, 0x8a,
	0xaa, 0xb1, 0x95, 0xcb, 0x0d, 0x3f, 0x81, 0xfd, 0x44, 0x2b, 0x5f, 0xa4, 0x69, 0x18, 0xcf, 0xb9,
	0x09, 0xa5, 0x70, 0x2b, 0xa8, 0xaa, 0xad, 0xe0, 0x49, 0x28, 0xb1, 0x5b, 0x2d, 0x7c, 0xa5, 0x03,
	0x2e, 0x85, 0xd1, 0xa1, 0x9f, 0xba, 0x80, 0xe7, 0xb1, 0x97, 0xa3, 0xa7, 0x39, 0x48, 0xc7, 0x00,
	0xf8, 0xdd, 0x84, 0x11, 0x3a, 0x75, 0xab, 0xcd, 0x72, 0xab, 0x7a, 0xfc, 0xf9, 0xbb, 0xa5, 0xab,
	0x3d, 0x5e, 0x18, 0xd9, 0xda, 0x1a, 0xf4, 0x31, 0xdc, 0x0f, 0xe3, 0xc4, 0x1a, 0xfe, 0x56, 0x9d,
	0x3c, 0xb5, 0xd2, 0xbd, 0xd3, 0x24, 0x2d, 0xc2, 0xee, 0xa1, 0x60, 0xfc, 0x9f, 0x82, 0xcf, 0xad,
	0xa4, 0x5f, 0xc2, 0x7b, 0x37, 0x5b, 0x31, 0xb9, 0xee, 0x1e, 0x36, 0xea, 0xde, 0x60, 0xc6, 0x20,
	0x67, 0xb7, 0x04, 0xb9, 0xd4, 0xad, 0x61, 0x1f, 0xef, 0x7c, 0x4b, 0x72, 0x17, 0xfd, 0x1a, 0x20,
	0x56, 0x81, 0xe0, 0x7e, 0xe4, 0xa5, 0xa9, 0xbb, 0xdf, 0x24, 0xad, 0xda, 0x71, 0xf3, 0x96, 0x35,
	0x32, 0x63, 0x3f, 0xd3, 0xb1, 0x4a, 0xbc, 0x18, 0xd2, 0x03, 0xd8, 0xd2, 0x59, 0x74, 0x5d, 0x07,
	0xdb, 0xcc, 0x27, 0xd9, 0x57, 0x95, 0x42, 0x2a, 0x7d, 0xc1, 0x73, 0xb2, 0x8e, 0x64, 0x35, 0xc7,
	0x58, 0x06, 0x1d, 0xfd, 0x4e, 0xa0, 0xb2, 0x3c, 0xcd, 0x65, 0xb0, 0xc9, 0x5a, 0xb0, 0x0f, 0x60,
	0xeb, 0x67, 0x2f, 0xb2, 0x79, 0xda, 0x09, 0xcb, 0x27, 0xf4, 0x03, 0xa8, 0xa6, 0xc6, 0x33, 0x82,
	0xe7, 0x5c, 0x19, 0x39, 0x40, 0xe8, 0x19, 0x0a, 0x1c, 0x28, 0xcb, 0x30, 0xc6, 0xa0, 0x13, 0x96,
	0x0d, 0x11, 0xf1, 0x5e, 0x61, 0xa0, 0x33, 0xc4, 0x7b, 0x45, 0x5d, 0xd8, 0x31, 0x36, 0xf6, 0xa6,
	0x91, 0xc0, 0xf0, 0xee, 0xb2, 0xc5, 0xf4, 0xe8, 0x0f, 0x02, 0xf4, 0xfa, 0x2d, 0xa5, 0xdf, 0x40,
	0xc5, 0x8b, 0xe6, 0x4a, 0x87, 0xe6, 0x85, 0xc4, 0x22, 0x6b, 0xc7, 0xad, 0x5b, 0x8e, 0xa9, 0x5b,
	0x5c, 0xbe, 0xee, 0x42, 0xcf, 0x56, 0xd6, 0xec, 0xaf, 0xe4, 0x27, 0x96, 0x4f, 0x6d, 0x30, 0x17,
	0x66, 0xf1, 0x57, 0xf2, 0x13, 0xdb, 0x43, 0x20, 0xa3, 0xb5, 0x27, 0x17, 0x74, 0x39, 0xa7, 0xb5,
	0x27, 0x0b, 0xba, 0x05, 0x0e, 0xee, 0xc1, 0xf3, 0xc8, 0xe0, 0x55, 0xc8, 0xfb, 0xac, 0x21, 0x3e,
	0xcc, 0xe0, 0x2c, 0x1c, 0x0f, 0x7f, 0x25, 0x50, 0x59, 0x7e, 0x2f, 0x5a, 0x85, 0x9d, 0xa7, 0xa3,
	0xef, 0x47, 0x67, 0x3f, 0x8c, 0x9c, 0x12, 0xbd, 0x0b, 0xfb, 0xc3, 0xd1, 0x64, 0xc0, 0x4e, 0x06,
	0xdd, 0x67, 0x03, 0x7e, 0xda, 0x1d, 0x3d, 0x77, 0x08, 0xbd, 0x0f, 0x87, 0xdd, 0xf3, 0xe7, 0xa3,
	0x3e, 0x7f, 0x9b, 0xda, 0xa0, 0xfb, 0x50, 0x45, 0x2b, 0x67, 0xdd, 0xc9, 0xf0, 0xcc, 0x29, 0xd3,
	0x43, 0xa8, 0xe7, 0xda, 0x75, 0x78, 0x93, 0xd6, 0x61, 0xaf, 0xd8, 0xa4, 0x80, 0xb6, 0x1e, 0x3e,
	0x86, 0xfa, 0xb5, 0xd3, 0xa0, 0x35, 0x80, 0xef, 0x86, 0x27, 0x27, 0xbc, 0x7f, 0x32, 0x3c, 0xed,
	0x39, 0x25, 0x7a, 0x00, 0xce, 0xb7, 0xac, 0xfb, 0x64, 0x38, 0x18, 0x4d, 0xf8, 0x93, 0xc1, 0x79,
	0x7f, 0x30, 0x9a, 0x38, 0xa4, 0xc7, 0xff, 0xbc, 0x6c, 0x90, 0xd7, 0x97, 0x0d, 0xf2, 0xcf, 0x65,
	0x83, 0xfc, 0x76, 0xd5, 0x28, 0xbd, 0xbe, 0x6a, 0x94, 0xfe, 0xbe, 0x6a, 0x94, 0x7e, 0xec, 0xcd,
	0x43, 0xf3, 0xc2, 0x4e, 0xdb, 0xbe, 0x92, 0x9d, 0x6e, 0x92, 0x44, 0xe1, 0x2c, 0x14, 0xba, 0x33,
	0x57, 0x9f, 0xad, 0xbd, 0x3e, 0xe6, 0x22, 0x11, 0x69, 0xe7, 0xd6, 0xe7, 0xe8, 0x0d, 0x21, 0xd3,
	0x6d, 0x7c, 0x8c, 0xbe, 0xf8, 0x37, 0x00, 0x00, 0xff, 0xff, 0x8a, 0xc1, 0xf3, 0x77, 0xb5, 0x06,
	0x00, 0x00,
}

func (m *ModelProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelProto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelProto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OptimizationParams != nil {
		{
			size, err := m.OptimizationParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModel(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.CollectResourceUsage {
		i--
		if m.CollectResourceUsage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.IdCounter != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.IdCounter))
		i--
		dAtA[i] = 0x10
	}
	if m.Output != nil {
		{
			size, err := m.Output.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModel(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelProto_Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelProto_Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelProto_Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MemoryRatio != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemoryRatio))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x89
	}
	if m.Ratio != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Ratio))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x81
	}
	if m.NodeClass != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.NodeClass))
		i--
		dAtA[i] = 0x78
	}
	if len(m.Inputs) > 0 {
		for iNdEx := len(m.Inputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Inputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModel(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if m.InputProcessingTimeCount != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.InputProcessingTimeCount))
		i--
		dAtA[i] = 0x68
	}
	if m.InputProcessingTimeSum != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.InputProcessingTimeSum))))
		i--
		dAtA[i] = 0x61
	}
	if len(m.Parameters) > 0 {
		for iNdEx := len(m.Parameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModel(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.RecordMetrics {
		i--
		if m.RecordMetrics {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.ProcessingTime != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.ProcessingTime))
		i--
		dAtA[i] = 0x48
	}
	if m.NumElements != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.NumElements))
		i--
		dAtA[i] = 0x40
	}
	if m.BytesProduced != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.BytesProduced))
		i--
		dAtA[i] = 0x38
	}
	if m.BytesConsumed != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.BytesConsumed))
		i--
		dAtA[i] = 0x30
	}
	if m.BufferedElements != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.BufferedElements))
		i--
		dAtA[i] = 0x28
	}
	if m.BufferedBytes != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.BufferedBytes))
		i--
		dAtA[i] = 0x20
	}
	if m.Autotune {
		i--
		if m.Autotune {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModel(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ModelProto_Node_Parameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelProto_Node_Parameter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelProto_Node_Parameter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Tunable {
		i--
		if m.Tunable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Max != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Max))))
		i--
		dAtA[i] = 0x29
	}
	if m.Min != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Min))))
		i--
		dAtA[i] = 0x21
	}
	if m.StateValue != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.StateValue))))
		i--
		dAtA[i] = 0x19
	}
	if m.Value != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Value))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModel(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelProto_OptimizationParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelProto_OptimizationParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelProto_OptimizationParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ModelInputTime != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ModelInputTime))))
		i--
		dAtA[i] = 0x21
	}
	if m.RamBudget != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.RamBudget))
		i--
		dAtA[i] = 0x18
	}
	if m.CpuBudget != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.CpuBudget))
		i--
		dAtA[i] = 0x10
	}
	if m.Algorithm != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.Algorithm))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintModel(dAtA []byte, offset int, v uint64) int {
	offset -= sovModel(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ModelProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.IdCounter != 0 {
		n += 1 + sovModel(uint64(m.IdCounter))
	}
	if m.CollectResourceUsage {
		n += 2
	}
	if m.OptimizationParams != nil {
		l = m.OptimizationParams.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *ModelProto_Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovModel(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Autotune {
		n += 2
	}
	if m.BufferedBytes != 0 {
		n += 1 + sovModel(uint64(m.BufferedBytes))
	}
	if m.BufferedElements != 0 {
		n += 1 + sovModel(uint64(m.BufferedElements))
	}
	if m.BytesConsumed != 0 {
		n += 1 + sovModel(uint64(m.BytesConsumed))
	}
	if m.BytesProduced != 0 {
		n += 1 + sovModel(uint64(m.BytesProduced))
	}
	if m.NumElements != 0 {
		n += 1 + sovModel(uint64(m.NumElements))
	}
	if m.ProcessingTime != 0 {
		n += 1 + sovModel(uint64(m.ProcessingTime))
	}
	if m.RecordMetrics {
		n += 2
	}
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	if m.InputProcessingTimeSum != 0 {
		n += 9
	}
	if m.InputProcessingTimeCount != 0 {
		n += 1 + sovModel(uint64(m.InputProcessingTimeCount))
	}
	if len(m.Inputs) > 0 {
		for _, e := range m.Inputs {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	if m.NodeClass != 0 {
		n += 1 + sovModel(uint64(m.NodeClass))
	}
	if m.Ratio != 0 {
		n += 10
	}
	if m.MemoryRatio != 0 {
		n += 10
	}
	return n
}

func (m *ModelProto_Node_Parameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Value != 0 {
		n += 9
	}
	if m.StateValue != 0 {
		n += 9
	}
	if m.Min != 0 {
		n += 9
	}
	if m.Max != 0 {
		n += 9
	}
	if m.Tunable {
		n += 2
	}
	return n
}

func (m *ModelProto_OptimizationParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Algorithm != 0 {
		n += 1 + sovModel(uint64(m.Algorithm))
	}
	if m.CpuBudget != 0 {
		n += 1 + sovModel(uint64(m.CpuBudget))
	}
	if m.RamBudget != 0 {
		n += 1 + sovModel(uint64(m.RamBudget))
	}
	if m.ModelInputTime != 0 {
		n += 9
	}
	return n
}

func sovModel(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozModel(x uint64) (n int) {
	return sovModel(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ModelProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output == nil {
				m.Output = &ModelProto_Node{}
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdCounter", wireType)
			}
			m.IdCounter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdCounter |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectResourceUsage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CollectResourceUsage = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizationParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptimizationParams == nil {
				m.OptimizationParams = &ModelProto_OptimizationParams{}
			}
			if err := m.OptimizationParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelProto_Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Autotune", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Autotune = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferedBytes", wireType)
			}
			m.BufferedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BufferedBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferedElements", wireType)
			}
			m.BufferedElements = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BufferedElements |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesConsumed", wireType)
			}
			m.BytesConsumed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesConsumed |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesProduced", wireType)
			}
			m.BytesProduced = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesProduced |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumElements", wireType)
			}
			m.NumElements = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumElements |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessingTime", wireType)
			}
			m.ProcessingTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessingTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordMetrics", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RecordMetrics = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, &ModelProto_Node_Parameter{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputProcessingTimeSum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.InputProcessingTimeSum = float64(math.Float64frombits(v))
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputProcessingTimeCount", wireType)
			}
			m.InputProcessingTimeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputProcessingTimeCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inputs = append(m.Inputs, &ModelProto_Node{})
			if err := m.Inputs[len(m.Inputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeClass", wireType)
			}
			m.NodeClass = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeClass |= NodeClass(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ratio", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Ratio = float64(math.Float64frombits(v))
		case 17:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryRatio", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemoryRatio = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelProto_Node_Parameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Parameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Parameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.StateValue = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Min", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Min = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Max = float64(math.Float64frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tunable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tunable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelProto_OptimizationParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OptimizationParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OptimizationParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algorithm", wireType)
			}
			m.Algorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Algorithm |= AutotuneAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuBudget", wireType)
			}
			m.CpuBudget = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuBudget |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RamBudget", wireType)
			}
			m.RamBudget = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RamBudget |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelInputTime", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ModelInputTime = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipModel(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowModel
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthModel
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupModel
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthModel
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthModel        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowModel          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupModel = fmt.Errorf("proto: unexpected end of group")
)
